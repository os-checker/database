{
  "env": {
    "tools": {
      "rust_toolchains": {
        "host": {
          "version": "1.83.0-nightly (9096f4faf 2024-10-05)",
          "commit_hash": "9096f4fafa2ac2d771f866337b4ee7064cde8575",
          "commit_date": "2024-10-05",
          "host": "x86_64-unknown-linux-gnu",
          "release": "1.83.0-nightly",
          "llvm_version": "19.1.0"
        },
        "installed": [
          {
            "channel": "nightly-x86_64-unknown-linux-gnu",
            "profile": null,
            "targets": [
              "x86_64-unknown-linux-gnu"
            ],
            "components": [
              "cargo-x86_64-unknown-linux-gnu",
              "clippy-x86_64-unknown-linux-gnu",
              "rust-std-x86_64-unknown-linux-gnu",
              "rustc-x86_64-unknown-linux-gnu",
              "rustfmt-x86_64-unknown-linux-gnu"
            ],
            "toml_path": "/home/runner/check",
            "need_install_clippy": false,
            "peculiar_targets": null
          }
        ]
      },
      "os_checker": {
        "start": 1728261811806,
        "finish": 1728261816129,
        "duration_ms": 4322,
        "git_time": "2024-10-06 20:26:23 +0800",
        "git_sha": "ca35711b92c9cf143cd6db91c8c154b3e921093b"
      }
    },
    "kinds": {
      "order": [
        "Cargo",
        "Clippy(Error)",
        "Clippy(Warn)",
        "Mirai",
        "Lockbud(Probably)",
        "Lockbud(Possibly)",
        "Unformatted"
      ],
      "mapping": {
        "cargo": [
          "Cargo"
        ],
        "clippy": [
          "Clippy(Error)",
          "Clippy(Warn)"
        ],
        "mirai": [
          "Mirai"
        ],
        "lockbud": [
          "Lockbud(Probably)",
          "Lockbud(Possibly)"
        ],
        "fmt": [
          "Unformatted"
        ]
      }
    },
    "repos": [
      {
        "user": "kern-crates",
        "repo": "loongArch64"
      },
      {
        "user": "kern-crates",
        "repo": "lwext4"
      },
      {
        "user": "kern-crates",
        "repo": "memory_addr"
      },
      {
        "user": "kern-crates",
        "repo": "of"
      },
      {
        "user": "kern-crates",
        "repo": "page_table"
      },
      {
        "user": "kern-crates",
        "repo": "page_table_entry"
      },
      {
        "user": "kern-crates",
        "repo": "pager"
      },
      {
        "user": "kern-crates",
        "repo": "pconst"
      }
    ],
    "packages": [
      {
        "name": "loongArch64",
        "repo": {
          "repo_idx": 0,
          "user": "kern-crates",
          "repo": "loongArch64"
        }
      },
      {
        "name": "lwext4-mkfs",
        "repo": {
          "repo_idx": 1,
          "user": "kern-crates",
          "repo": "lwext4"
        }
      },
      {
        "name": "lwext4-rs",
        "repo": {
          "repo_idx": 1,
          "user": "kern-crates",
          "repo": "lwext4"
        }
      },
      {
        "name": "lwext4-sys",
        "repo": {
          "repo_idx": 1,
          "user": "kern-crates",
          "repo": "lwext4"
        }
      },
      {
        "name": "memory_addr",
        "repo": {
          "repo_idx": 2,
          "user": "kern-crates",
          "repo": "memory_addr"
        }
      },
      {
        "name": "of",
        "repo": {
          "repo_idx": 3,
          "user": "kern-crates",
          "repo": "of"
        }
      },
      {
        "name": "page_table",
        "repo": {
          "repo_idx": 4,
          "user": "kern-crates",
          "repo": "page_table"
        }
      },
      {
        "name": "page_table_entry",
        "repo": {
          "repo_idx": 5,
          "user": "kern-crates",
          "repo": "page_table_entry"
        }
      },
      {
        "name": "pager",
        "repo": {
          "repo_idx": 6,
          "user": "kern-crates",
          "repo": "pager"
        }
      },
      {
        "name": "pconst",
        "repo": {
          "repo_idx": 7,
          "user": "kern-crates",
          "repo": "pconst"
        }
      }
    ]
  },
  "cmd": [
    {
      "package_idx": 0,
      "tool": "fmt",
      "cmd": "cargo +nightly-x86_64-unknown-linux-gnu fmt -p loongArch64 -- --emit=json",
      "count": 4,
      "duration_ms": 110,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 0,
      "tool": "clippy",
      "cmd": "cargo clippy --target x86_64-unknown-linux-gnu --no-deps --message-format=json",
      "count": 9,
      "duration_ms": 417,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 0,
      "tool": "mirai",
      "cmd": "cargo +nightly-2023-12-30 mirai --target x86_64-unknown-linux-gnu --message-format=json",
      "count": 0,
      "duration_ms": 46,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 0,
      "tool": "lockbud",
      "cmd": "cargo +nightly-2024-05-21 lockbud -k all -- --target x86_64-unknown-linux-gnu",
      "count": 0,
      "duration_ms": 344,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 0,
      "tool": "cargo",
      "cmd": "VRITUAL=clippy cargo",
      "count": 1,
      "duration_ms": 417,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 0,
      "tool": "cargo",
      "cmd": "VRITUAL=lockbud cargo",
      "count": 1,
      "duration_ms": 344,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 1,
      "tool": "fmt",
      "cmd": "cargo +nightly-x86_64-unknown-linux-gnu fmt -p lwext4-mkfs -- --emit=json",
      "count": 0,
      "duration_ms": 95,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 1,
      "tool": "clippy",
      "cmd": "cargo clippy --target x86_64-unknown-linux-gnu --no-deps --message-format=json",
      "count": 1,
      "duration_ms": 20030,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 1,
      "tool": "mirai",
      "cmd": "cargo +nightly-2023-12-30 mirai --target x86_64-unknown-linux-gnu --message-format=json",
      "count": 0,
      "duration_ms": 47,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 1,
      "tool": "lockbud",
      "cmd": "cargo +nightly-2024-05-21 lockbud -k all -- --target x86_64-unknown-linux-gnu",
      "count": 1,
      "duration_ms": 22207,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 2,
      "tool": "fmt",
      "cmd": "cargo +nightly-x86_64-unknown-linux-gnu fmt -p lwext4-rs -- --emit=json",
      "count": 0,
      "duration_ms": 116,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 2,
      "tool": "clippy",
      "cmd": "cargo clippy --target x86_64-unknown-linux-gnu --no-deps --message-format=json",
      "count": 30,
      "duration_ms": 11437,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 2,
      "tool": "mirai",
      "cmd": "cargo +nightly-2023-12-30 mirai --target x86_64-unknown-linux-gnu --message-format=json",
      "count": 0,
      "duration_ms": 48,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 2,
      "tool": "lockbud",
      "cmd": "cargo +nightly-2024-05-21 lockbud -k all -- --target x86_64-unknown-linux-gnu",
      "count": 1,
      "duration_ms": 14865,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 2,
      "tool": "cargo",
      "cmd": "VRITUAL=clippy cargo",
      "count": 1,
      "duration_ms": 11437,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 3,
      "tool": "fmt",
      "cmd": "cargo +nightly-x86_64-unknown-linux-gnu fmt -p lwext4-sys -- --emit=json",
      "count": 1,
      "duration_ms": 107,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 3,
      "tool": "clippy",
      "cmd": "cargo clippy --target x86_64-unknown-linux-gnu --no-deps --message-format=json",
      "count": 7,
      "duration_ms": 11391,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 3,
      "tool": "mirai",
      "cmd": "cargo +nightly-2023-12-30 mirai --target x86_64-unknown-linux-gnu --message-format=json",
      "count": 0,
      "duration_ms": 47,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 3,
      "tool": "lockbud",
      "cmd": "cargo +nightly-2024-05-21 lockbud -k all -- --target x86_64-unknown-linux-gnu",
      "count": 1,
      "duration_ms": 14711,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 4,
      "tool": "fmt",
      "cmd": "cargo +nightly-x86_64-unknown-linux-gnu fmt -p memory_addr -- --emit=json",
      "count": 0,
      "duration_ms": 94,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 4,
      "tool": "clippy",
      "cmd": "cargo clippy --target x86_64-unknown-linux-gnu --no-deps --message-format=json",
      "count": 1,
      "duration_ms": 195,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 4,
      "tool": "mirai",
      "cmd": "cargo +nightly-2023-12-30 mirai --target x86_64-unknown-linux-gnu --message-format=json",
      "count": 0,
      "duration_ms": 45,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 4,
      "tool": "lockbud",
      "cmd": "cargo +nightly-2024-05-21 lockbud -k all -- --target x86_64-unknown-linux-gnu",
      "count": 0,
      "duration_ms": 139,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 5,
      "tool": "fmt",
      "cmd": "cargo +nightly-x86_64-unknown-linux-gnu fmt -p of -- --emit=json",
      "count": 0,
      "duration_ms": 95,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 5,
      "tool": "clippy",
      "cmd": "cargo clippy --target x86_64-unknown-linux-gnu --no-deps --message-format=json",
      "count": 0,
      "duration_ms": 392,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 5,
      "tool": "mirai",
      "cmd": "cargo +nightly-2023-12-30 mirai --target x86_64-unknown-linux-gnu --message-format=json",
      "count": 0,
      "duration_ms": 46,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 5,
      "tool": "lockbud",
      "cmd": "cargo +nightly-2024-05-21 lockbud -k all -- --target x86_64-unknown-linux-gnu",
      "count": 0,
      "duration_ms": 385,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 6,
      "tool": "fmt",
      "cmd": "cargo +nightly-x86_64-unknown-linux-gnu fmt -p page_table -- --emit=json",
      "count": 0,
      "duration_ms": 99,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 6,
      "tool": "clippy",
      "cmd": "cargo clippy --target x86_64-unknown-linux-gnu --no-deps --message-format=json",
      "count": 0,
      "duration_ms": 2399,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 6,
      "tool": "mirai",
      "cmd": "cargo +nightly-2023-12-30 mirai --target x86_64-unknown-linux-gnu --message-format=json",
      "count": 0,
      "duration_ms": 46,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 6,
      "tool": "lockbud",
      "cmd": "cargo +nightly-2024-05-21 lockbud -k all -- --target x86_64-unknown-linux-gnu",
      "count": 1,
      "duration_ms": 2271,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 7,
      "tool": "fmt",
      "cmd": "cargo +nightly-x86_64-unknown-linux-gnu fmt -p page_table_entry -- --emit=json",
      "count": 0,
      "duration_ms": 97,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 7,
      "tool": "clippy",
      "cmd": "cargo clippy --target x86_64-unknown-linux-gnu --no-deps --message-format=json",
      "count": 0,
      "duration_ms": 2002,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 7,
      "tool": "mirai",
      "cmd": "cargo +nightly-2023-12-30 mirai --target x86_64-unknown-linux-gnu --message-format=json",
      "count": 0,
      "duration_ms": 45,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 7,
      "tool": "lockbud",
      "cmd": "cargo +nightly-2024-05-21 lockbud -k all -- --target x86_64-unknown-linux-gnu",
      "count": 0,
      "duration_ms": 2225,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 8,
      "tool": "fmt",
      "cmd": "cargo +nightly-x86_64-unknown-linux-gnu fmt -p pager -- --emit=json",
      "count": 1,
      "duration_ms": 101,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 8,
      "tool": "clippy",
      "cmd": "cargo clippy --target x86_64-unknown-linux-gnu --no-deps --message-format=json",
      "count": 3,
      "duration_ms": 743,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 8,
      "tool": "mirai",
      "cmd": "cargo +nightly-2023-12-30 mirai --target x86_64-unknown-linux-gnu --message-format=json",
      "count": 0,
      "duration_ms": 46,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 8,
      "tool": "lockbud",
      "cmd": "cargo +nightly-2024-05-21 lockbud -k all -- --target x86_64-unknown-linux-gnu",
      "count": 1,
      "duration_ms": 286,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 9,
      "tool": "fmt",
      "cmd": "cargo +nightly-x86_64-unknown-linux-gnu fmt -p pconst -- --emit=json",
      "count": 0,
      "duration_ms": 105,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 9,
      "tool": "clippy",
      "cmd": "cargo clippy --target x86_64-unknown-linux-gnu --no-deps --message-format=json",
      "count": 12,
      "duration_ms": 4981,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 9,
      "tool": "mirai",
      "cmd": "cargo +nightly-2023-12-30 mirai --target x86_64-unknown-linux-gnu --message-format=json",
      "count": 0,
      "duration_ms": 47,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 9,
      "tool": "lockbud",
      "cmd": "cargo +nightly-2024-05-21 lockbud -k all -- --target x86_64-unknown-linux-gnu",
      "count": 0,
      "duration_ms": 4667,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 9,
      "tool": "cargo",
      "cmd": "VRITUAL=clippy cargo",
      "count": 1,
      "duration_ms": 4981,
      "arch": "x86_64",
      "target_triple": "x86_64-unknown-linux-gnu",
      "rust_toolchain": "nightly-2024-10-04",
      "features": [],
      "flags": []
    }
  ],
  "data": [
    {
      "cmd_idx": 0,
      "file": "src/lib.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_8/kern-crates/loongArch64/src/lib.rs (original lines from 5 to 5)\n+pub mod consts;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/lib.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_8/kern-crates/loongArch64/src/lib.rs (original lines from 10 to 10)\n-pub mod consts;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/register/base/ecfg.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_8/kern-crates/loongArch64/src/register/base/ecfg.rs (original lines from 1 to 1)\n-use core::fmt::Debug;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/register/base/ecfg.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_8/kern-crates/loongArch64/src/register/base/ecfg.rs (original lines from 5 to 5)\n+use core::fmt::Debug;\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/lib.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: the feature `asm_const` has been stable since 1.82.0 and no longer requires an attribute to enable\n --> src/lib.rs:2:12\n  |\n2 | #![feature(asm_const)]\n  |            ^^^^^^^^^\n  |\n  = note: `#[warn(stable_features)]` on by default\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/iocsr.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: formatting may not be suitable for sub-register argument\n --> src/iocsr.rs:6:25\n  |\n6 |         asm!(\"iocsrwr.w {},{}\", in(reg) value, in(reg) reg);\n  |                         ^^              ----- for this argument\n  |\n  = help: use `{0:e}` to have the register formatted as `eax` (for 32-bit values)\n  = help: or use `{0:r}` to keep the default formatting of `rax` (for 64-bit values)\n  = note: `#[warn(asm_sub_register)]` on by default\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/iocsr.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: formatting may not be suitable for sub-register argument\n  --> src/iocsr.rs:18:25\n   |\n18 |         asm!(\"iocsrwr.h {},{}\", in(reg) value, in(reg) reg);\n   |                         ^^              ----- for this argument\n   |\n   = help: use `{0:x}` to have the register formatted as `ax` (for 16-bit values)\n   = help: or use `{0:r}` to keep the default formatting of `rax` (for 64-bit values)\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/iocsr.rs",
      "kind": "Clippy(Error)",
      "raw": "error: type `u8` cannot be used with this register class\n  --> src/iocsr.rs:24:41\n   |\n24 |         asm!(\"iocsrwr.b {},{}\", in(reg) value, in(reg) reg);\n   |                                         ^^^^^\n   |\n   = note: register class `reg` supports these types: i16, i32, i64, f16, f32, f64\n   = help: consider using the `reg_byte` register class instead\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/iocsr.rs",
      "kind": "Clippy(Error)",
      "raw": "error: type `u8` cannot be used with this register class\n  --> src/iocsr.rs:32:41\n   |\n32 |         asm!(\"iocsrrd.b {},{}\",out(reg) val, in(reg) reg);\n   |                                         ^^^\n   |\n   = note: register class `reg` supports these types: i16, i32, i64, f16, f32, f64\n   = help: consider using the `reg_byte` register class instead\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/iocsr.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: formatting may not be suitable for sub-register argument\n  --> src/iocsr.rs:41:25\n   |\n41 |         asm!(\"iocsrrd.h {},{}\",out(reg) val, in(reg) reg);\n   |                         ^^              --- for this argument\n   |\n   = help: use `{0:x}` to have the register formatted as `ax` (for 16-bit values)\n   = help: or use `{0:r}` to keep the default formatting of `rax` (for 64-bit values)\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/iocsr.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: formatting may not be suitable for sub-register argument\n  --> src/iocsr.rs:50:25\n   |\n50 |         asm!(\"iocsrrd.w {},{}\",out(reg) val, in(reg) reg);\n   |                         ^^              --- for this argument\n   |\n   = help: use `{0:e}` to have the register formatted as `eax` (for 32-bit values)\n   = help: or use `{0:r}` to keep the default formatting of `rax` (for 64-bit values)\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/ipi.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: formatting may not be suitable for sub-register argument\n --> src/ipi.rs:7:25\n  |\n7 |         asm!(\"iocsrwr.w {},{}\", in(reg) value,in(reg) addr);\n  |                         ^^              ----- for this argument\n  |\n  = help: use `{0:e}` to have the register formatted as `eax` (for 32-bit values)\n  = help: or use `{0:r}` to keep the default formatting of `rax` (for 64-bit values)\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/ipi.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: formatting may not be suitable for sub-register argument\n  --> src/ipi.rs:13:25\n   |\n13 |         asm!(\"iocsrrd.w {},{}\", out(reg) value, in(reg) addr);\n   |                         ^^               ----- for this argument\n   |\n   = help: use `{0:e}` to have the register formatted as `eax` (for 32-bit values)\n   = help: or use `{0:r}` to keep the default formatting of `rax` (for 64-bit values)\n\n"
    },
    {
      "cmd_idx": 4,
      "file": "(virtual) clippy",
      "kind": "Cargo",
      "raw": "// pkg_name=loongArch64, checker=Clippy\n// toolchain=nightly-x86_64-unknown-linux-gnu, target=x86_64-unknown-linux-gnu\n// pkg_dir=/home/runner/check/batch_8/kern-crates/loongArch64\n// cmd=cargo clippy --target x86_64-unknown-linux-gnu --no-deps --message-format=json\n    Updating crates.io index\n     Locking 2 packages to latest compatible versions\n      Adding bitflags v1.3.2 (available: v2.6.0)\n    Checking bit_field v0.10.2\n    Checking bitflags v1.3.2\n    Checking loongArch64 v0.2.4 (/home/runner/check/batch_8/kern-crates/loongArch64)\nerror: could not compile `loongArch64` (lib) due to 2 previous errors; 7 warnings emitted\n"
    },
    {
      "cmd_idx": 5,
      "file": "(virtual) lockbud",
      "kind": "Cargo",
      "raw": "// pkg_name=loongArch64, checker=Lockbud\n// toolchain=nightly-x86_64-unknown-linux-gnu, target=x86_64-unknown-linux-gnu\n// pkg_dir=/home/runner/check/batch_8/kern-crates/loongArch64\n// cmd=cargo +nightly-2024-05-21 lockbud -k all -- --target x86_64-unknown-linux-gnu\n   Compiling bit_field v0.10.2\n   Compiling bitflags v1.3.2\n   Compiling loongArch64 v0.2.4 (/home/runner/check/batch_8/kern-crates/loongArch64)\nwarning: formatting may not be suitable for sub-register argument\n --> src/iocsr.rs:6:25\n  |\n6 |         asm!(\"iocsrwr.w {},{}\", in(reg) value, in(reg) reg);\n  |                         ^^              ----- for this argument\n  |\n  = help: use `{0:e}` to have the register formatted as `eax` (for 32-bit values)\n  = help: or use `{0:r}` to keep the default formatting of `rax` (for 64-bit values)\n  = note: `#[warn(asm_sub_register)]` on by default\n\nwarning: formatting may not be suitable for sub-register argument\n  --> src/iocsr.rs:18:25\n   |\n18 |         asm!(\"iocsrwr.h {},{}\", in(reg) value, in(reg) reg);\n   |                         ^^              ----- for this argument\n   |\n   = help: use `{0:x}` to have the register formatted as `ax` (for 16-bit values)\n   = help: or use `{0:r}` to keep the default formatting of `rax` (for 64-bit values)\n\nerror: type `u8` cannot be used with this register class\n  --> src/iocsr.rs:24:41\n   |\n24 |         asm!(\"iocsrwr.b {},{}\", in(reg) value, in(reg) reg);\n   |                                         ^^^^^\n   |\n   = note: register class `reg` supports these types: i16, i32, i64, f32, f64\n   = help: consider using the `reg_byte` register class instead\n\nerror: type `u8` cannot be used with this register class\n  --> src/iocsr.rs:32:41\n   |\n32 |         asm!(\"iocsrrd.b {},{}\",out(reg) val, in(reg) reg);\n   |                                         ^^^\n   |\n   = note: register class `reg` supports these types: i16, i32, i64, f32, f64\n   = help: consider using the `reg_byte` register class instead\n\nwarning: formatting may not be suitable for sub-register argument\n  --> src/iocsr.rs:41:25\n   |\n41 |         asm!(\"iocsrrd.h {},{}\",out(reg) val, in(reg) reg);\n   |                         ^^              --- for this argument\n   |\n   = help: use `{0:x}` to have the register formatted as `ax` (for 16-bit values)\n   = help: or use `{0:r}` to keep the default formatting of `rax` (for 64-bit values)\n\nwarning: formatting may not be suitable for sub-register argument\n  --> src/iocsr.rs:50:25\n   |\n50 |         asm!(\"iocsrrd.w {},{}\",out(reg) val, in(reg) reg);\n   |                         ^^              --- for this argument\n   |\n   = help: use `{0:e}` to have the register formatted as `eax` (for 32-bit values)\n   = help: or use `{0:r}` to keep the default formatting of `rax` (for 64-bit values)\n\nwarning: formatting may not be suitable for sub-register argument\n --> src/ipi.rs:7:25\n  |\n7 |         asm!(\"iocsrwr.w {},{}\", in(reg) value,in(reg) addr);\n  |                         ^^              ----- for this argument\n  |\n  = help: use `{0:e}` to have the register formatted as `eax` (for 32-bit values)\n  = help: or use `{0:r}` to keep the default formatting of `rax` (for 64-bit values)\n\nwarning: formatting may not be suitable for sub-register argument\n  --> src/ipi.rs:13:25\n   |\n13 |         asm!(\"iocsrrd.w {},{}\", out(reg) value, in(reg) addr);\n   |                         ^^               ----- for this argument\n   |\n   = help: use `{0:e}` to have the register formatted as `eax` (for 32-bit values)\n   = help: or use `{0:r}` to keep the default formatting of `rax` (for 64-bit values)\n\nwarning: `loongArch64` (lib) generated 6 warnings\nerror: could not compile `loongArch64` (lib) due to 2 previous errors; 6 warnings emitted\n"
    },
    {
      "cmd_idx": 7,
      "file": "lwext4-rs/src/lib.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: the feature `error_in_core` has been stable since 1.81.0 and no longer requires an attribute to enable\n --> lwext4-rs/src/lib.rs:2:12\n  |\n2 | #![feature(error_in_core)]\n  |            ^^^^^^^^^^^^^\n  |\n  = note: `#[warn(stable_features)]` on by default\n\n"
    },
    {
      "cmd_idx": 9,
      "file": "Not supported to display yet.",
      "kind": "Lockbud(Possibly)",
      "raw": "[2024-10-05T04:19:19Z WARN  lockbud::callbacks] [\n      {\n        \"AtomicityViolation\": {\n          \"bug_kind\": \"AtomicityViolation\",\n          \"possibility\": \"Possibly\",\n          \"diagnosis\": {\n            \"fn_name\": \"set_logger_racy\",\n            \"atomic_reader\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/lib.rs:1447:11: 1447:40 (#0)\",\n            \"atomic_writer\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/lib.rs:1450:13: 1450:56 (#0)\",\n            \"dep_kind\": \"Control\"\n          },\n          \"explanation\": \"atomic::store is data/control dependent on atomic::load\"\n        }\n      }\n    ]\n[2024-10-05T04:19:19Z WARN  lockbud::callbacks] crate log contains bugs: { probably: 0, possibly: 0 }, conflictlock: { probably: 0, possibly: 0 }, condvar_deadlock: { probably: 0, possibly: 0 }, atomicity_violation: { possibly: 1 }, invalid_free: { possibly: 0 }, use_after_free: { possibly: 0 }\n[2024-10-05T04:19:21Z WARN  lockbud::callbacks] [\n      {\n        \"AtomicityViolation\": {\n          \"bug_kind\": \"AtomicityViolation\",\n          \"possibility\": \"Possibly\",\n          \"diagnosis\": {\n            \"fn_name\": \"set_logger_racy\",\n            \"atomic_reader\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/lib.rs:1447:11: 1447:40 (#0)\",\n            \"atomic_writer\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/lib.rs:1450:13: 1450:56 (#0)\",\n            \"dep_kind\": \"Control\"\n          },\n          \"explanation\": \"atomic::store is data/control dependent on atomic::load\"\n        }\n      }\n    ]\n[2024-10-05T04:19:21Z WARN  lockbud::callbacks] crate log contains bugs: { probably: 0, possibly: 0 }, conflictlock: { probably: 0, possibly: 0 }, condvar_deadlock: { probably: 0, possibly: 0 }, atomicity_violation: { possibly: 1 }, invalid_free: { possibly: 0 }, use_after_free: { possibly: 0 }\n[2024-10-05T04:19:24Z WARN  lockbud::callbacks] [\n      {\n        \"AtomicityViolation\": {\n          \"bug_kind\": \"AtomicityViolation\",\n          \"possibility\": \"Possibly\",\n          \"diagnosis\": {\n            \"fn_name\": \"regex_automata::util::pool::inner::Pool::<T, F>::get\",\n            \"atomic_reader\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.8/src/util/pool.rs:525:25: 525:59 (#0)\",\n            \"atomic_writer\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.8/src/util/pool.rs:530:17: 530:69 (#0)\",\n            \"dep_kind\": \"Control\"\n          },\n          \"explanation\": \"atomic::store is data/control dependent on atomic::load\"\n        }\n      }\n    ]\n[2024-10-05T04:19:24Z WARN  lockbud::callbacks] crate bindgen contains bugs: { probably: 0, possibly: 0 }, conflictlock: { probably: 0, possibly: 0 }, condvar_deadlock: { probably: 0, possibly: 0 }, atomicity_violation: { possibly: 1 }, invalid_free: { possibly: 0 }, use_after_free: { possibly: 0 }"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/lib.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: the feature `error_in_core` has been stable since 1.81.0 and no longer requires an attribute to enable\n --> lwext4-rs/src/lib.rs:2:12\n  |\n2 | #![feature(error_in_core)]\n  |            ^^^^^^^^^^^^^\n  |\n  = note: `#[warn(stable_features)]` on by default\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/block.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: transmute from a reference to a pointer\n  --> lwext4-rs/src/block.rs:41:25\n   |\n41 |                 p_user: transmute(Box::leak(Box::new(interface))),\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::leak(Box::new(interface)) as *mut T as *mut std::ffi::c_void`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_transmute\n   = note: `#[warn(clippy::useless_transmute)]` on by default\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/block.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: transmute from a pointer type (`*mut std::ffi::c_void`) to a reference type (`&T`)\n  --> lwext4-rs/src/block.rs:81:18\n   |\n81 |         unsafe { transmute((*self.raw.bdif).p_user) }\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*((*self.raw.bdif).p_user as *const T)`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ref\n   = note: `#[warn(clippy::transmute_ptr_to_ref)]` on by default\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/block.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: transmute from a pointer type (`*mut std::ffi::c_void`) to a reference type (`&mut T`)\n  --> lwext4-rs/src/block.rs:86:18\n   |\n86 |         unsafe { transmute((*self.raw.bdif).p_user) }\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&mut *((*self.raw.bdif).p_user as *mut T)`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ref\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/block.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: transmute from a reference to a pointer\n   --> lwext4-rs/src/block.rs:120:50\n    |\n120 |             errno_to_result(ext4_device_register(transmute(&bdev.raw), c_name.as_ptr()))?;\n    |                                                  ^^^^^^^^^^^^^^^^^^^^ help: try: `&bdev.raw as *const lwext4_sys::ext4::ext4_blockdev as *mut lwext4_sys::ext4::ext4_blockdev`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_transmute\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/block.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: transmute from a pointer type (`*mut lwext4_sys::ext4::ext4_blockdev`) to a reference type (`&mut block::BlockDevice<T>`)\n   --> lwext4-rs/src/block.rs:234:47\n    |\n234 |             let device: &mut BlockDevice<T> = transmute(bdev);\n    |                                               ^^^^^^^^^^^^^^^ help: try: `&mut *(bdev as *mut block::BlockDevice<T>)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ref\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/block.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: transmute from a pointer type (`*mut lwext4_sys::ext4::ext4_blockdev`) to a reference type (`&mut block::BlockDevice<T>`)\n   --> lwext4-rs/src/block.rs:252:47\n    |\n252 |             let device: &mut BlockDevice<T> = transmute(bdev);\n    |                                               ^^^^^^^^^^^^^^^ help: try: `&mut *(bdev as *mut block::BlockDevice<T>)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ref\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/block.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: transmute used without annotations\n   --> lwext4-rs/src/block.rs:256:36\n    |\n256 |                 from_raw_parts_mut(transmute(buf), (blk_cnt * bsize) as usize),\n    |                                    ^^^^^^^^^ help: consider adding missing annotations: `transmute::<*mut std::ffi::c_void, *mut u8>`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#missing_transmute_annotations\n    = note: `#[warn(clippy::missing_transmute_annotations)]` on by default\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/block.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: transmute from a pointer type (`*mut lwext4_sys::ext4::ext4_blockdev`) to a reference type (`&mut block::BlockDevice<T>`)\n   --> lwext4-rs/src/block.rs:271:47\n    |\n271 |             let device: &mut BlockDevice<T> = transmute(bdev);\n    |                                               ^^^^^^^^^^^^^^^ help: try: `&mut *(bdev as *mut block::BlockDevice<T>)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ref\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/block.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: transmute used without annotations\n   --> lwext4-rs/src/block.rs:275:32\n    |\n275 |                 from_raw_parts(transmute(buf), (blk_cnt * bsize) as usize),\n    |                                ^^^^^^^^^ help: consider adding missing annotations: `transmute::<*const std::ffi::c_void, *const u8>`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#missing_transmute_annotations\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/block.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: transmute from a pointer type (`*mut lwext4_sys::ext4::ext4_blockdev`) to a reference type (`&mut block::BlockDevice<T>`)\n   --> lwext4-rs/src/block.rs:285:47\n    |\n285 |             let device: &mut BlockDevice<T> = transmute(bdev);\n    |                                               ^^^^^^^^^^^^^^^ help: try: `&mut *(bdev as *mut block::BlockDevice<T>)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ref\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/block.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: transmute from a pointer type (`*mut lwext4_sys::ext4::ext4_blockdev`) to a reference type (`&mut block::BlockDevice<T>`)\n   --> lwext4-rs/src/block.rs:293:47\n    |\n293 |             let device: &mut BlockDevice<T> = transmute(bdev);\n    |                                               ^^^^^^^^^^^^^^^ help: try: `&mut *(bdev as *mut block::BlockDevice<T>)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ref\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/block.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: transmute from a pointer type (`*mut lwext4_sys::ext4::ext4_blockdev`) to a reference type (`&mut block::BlockDevice<T>`)\n   --> lwext4-rs/src/block.rs:301:47\n    |\n301 |             let device: &mut BlockDevice<T> = transmute(bdev);\n    |                                               ^^^^^^^^^^^^^^^ help: try: `&mut *(bdev as *mut block::BlockDevice<T>)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ref\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/dir.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: using `clone` on type `ext4_file` which implements the `Copy` trait\n  --> lwext4-rs/src/dir.rs:37:19\n   |\n37 |         File::new(self.raw.f.clone(), self.path.clone())\n   |                   ^^^^^^^^^^^^^^^^^^ help: try removing the `clone` call: `self.raw.f`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_copy\n   = note: `#[warn(clippy::clone_on_copy)]` on by default\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/dir.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: using `clone` on type `ext4_direntry` which implements the `Copy` trait\n   --> lwext4-rs/src/dir.rs:108:26\n    |\n108 |                     raw: (*transmute::<_, &ext4_direntry>(result)).clone(),\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try removing the `clone` call: `(*transmute::<_, &ext4_direntry>(result))`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_copy\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/dir.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: transmute from a pointer type (`*const lwext4_sys::ext4::ext4_direntry`) to a reference type (`&lwext4_sys::ext4::ext4_direntry`)\n   --> lwext4-rs/src/dir.rs:108:28\n    |\n108 |                     raw: (*transmute::<_, &ext4_direntry>(result)).clone(),\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&*result.cast::<ext4_direntry>()`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ref\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/dir.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: transmute used without annotations\n   --> lwext4-rs/src/dir.rs:108:28\n    |\n108 |                     raw: (*transmute::<_, &ext4_direntry>(result)).clone(),\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider adding missing annotations: `transmute::<*const lwext4_sys::ext4::ext4_direntry, &lwext4_sys::ext4::ext4_direntry>`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#missing_transmute_annotations\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/error.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n   --> lwext4-rs/src/error.rs:103:1\n    |\n103 | impl Into<std::io::Error> for Error {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: `impl From<Local> for Foreign` is allowed by the orphan rules, for more information see\n            https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#from_over_into\n    = note: `#[warn(clippy::from_over_into)]` on by default\nhelp: replace the `Into` implementation with `From<error::Error>`\n    |\n103 ~ impl From<Error> for std::io::Error {\n104 ~     fn from(val: Error) -> Self {\n105 ~         std::io::Error::from_raw_os_error(val as i32)\n    |\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/standard.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this expression creates a reference which is immediately dereferenced by the compiler\n  --> lwext4-rs/src/standard.rs:28:27\n   |\n28 |         self.0.read_exact(&mut buf).unwrap();\n   |                           ^^^^^^^^ help: change this to: `buf`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrow\n   = note: `#[warn(clippy::needless_borrow)]` on by default\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/fs.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: length comparison to zero\n   --> lwext4-rs/src/fs.rs:230:16\n    |\n230 |             if x.len() > 0 {\n    |                ^^^^^^^^^^^ help: using `!is_empty` is clearer and more explicit: `!x.is_empty()`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#len_zero\n    = note: `#[warn(clippy::len_zero)]` on by default\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/mkfs.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: transmute from a reference to a pointer\n  --> lwext4-rs/src/mkfs.rs:68:27\n   |\n68 |                     bdev: transmute(&bdev.raw),\n   |                           ^^^^^^^^^^^^^^^^^^^^ help: try: `&bdev.raw as *const lwext4_sys::ext4::ext4_blockdev as *mut lwext4_sys::ext4::ext4_blockdev`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_transmute\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/mkfs.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: you should consider adding a `Default` implementation for `FsBuilder`\n   --> lwext4-rs/src/mkfs.rs:181:5\n    |\n181 | /     pub fn new() -> Self {\n182 | |         Self {\n183 | |             block_size: 1024,\n184 | |             ty: None,\n...   |\n187 | |         }\n188 | |     }\n    | |_____^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#new_without_default\n    = note: `#[warn(clippy::new_without_default)]` on by default\nhelp: try adding this\n    |\n180 + impl Default for FsBuilder {\n181 +     fn default() -> Self {\n182 +         Self::new()\n183 +     }\n184 + }\n    |\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/mkfs.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: transmute from a reference to a pointer\n   --> lwext4-rs/src/mkfs.rs:251:17\n    |\n251 |                 transmute(&fs.device.raw),\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&fs.device.raw as *const lwext4_sys::ext4::ext4_blockdev as *mut lwext4_sys::ext4::ext4_blockdev`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_transmute\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/mkfs.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: transmute from a reference to a pointer\n   --> lwext4-rs/src/mkfs.rs:267:17\n    |\n267 |                 transmute(&self.device.raw),\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&self.device.raw as *const lwext4_sys::ext4::ext4_blockdev as *mut lwext4_sys::ext4::ext4_blockdev`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_transmute\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/mkfs.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: transmute from a reference to a pointer\n   --> lwext4-rs/src/mkfs.rs:268:17\n    |\n268 |                 transmute(&self.raw_info),\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `&self.raw_info as *const lwext4_sys::ext4::ext4_mkfs_info as *mut lwext4_sys::ext4::ext4_mkfs_info`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#useless_transmute\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/types.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value\n   --> lwext4-rs/src/types.rs:102:27\n    |\n102 |     pub(super) fn to_ext4(&self) -> u8 {\n    |                           ^^^^^\n    |\n    = help: consider choosing a less ambiguous name\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#wrong_self_convention\n    = note: `#[warn(clippy::wrong_self_convention)]` on by default\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/types.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: you should consider adding a `Default` implementation for `MountStats`\n   --> lwext4-rs/src/types.rs:121:5\n    |\n121 | /     pub fn new() -> Self {\n122 | |         Self(ext4_mount_stats {\n123 | |             inodes_count: 0,\n124 | |             free_inodes_count: 0,\n...   |\n132 | |         })\n133 | |     }\n    | |_____^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#new_without_default\nhelp: try adding this\n    |\n120 + impl Default for MountStats {\n121 +     fn default() -> Self {\n122 +         Self::new()\n123 +     }\n124 + }\n    |\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs",
      "kind": "Clippy(Error)",
      "raw": "error: &-masking with zero\n   --> lwext4-rs/src/types.rs:166:1\n    |\n166 | / bitflags! {\n167 | |     pub struct OpenFlags:u32{\n168 | |         const RDONLY = O_RDONLY;\n169 | |         const WRONLY = O_WRONLY;\n...   |\n175 | |     }\n176 | | }\n    | |_^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#bad_bit_mask\n    = note: `#[deny(clippy::bad_bit_mask)]` on by default\n    = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/types.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: struct `Metadata` has a public `len` method, but no `is_empty` method\n   --> lwext4-rs/src/types.rs:379:5\n    |\n379 |     pub fn len(&self) -> u64 {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#len_without_is_empty\n    = note: `#[warn(clippy::len_without_is_empty)]` on by default\n\n"
    },
    {
      "cmd_idx": 11,
      "file": "lwext4-rs/src/types.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n   --> lwext4-rs/src/types.rs:517:1\n    |\n517 | impl Into<u32> for Time {\n    | ^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: `impl From<Local> for Foreign` is allowed by the orphan rules, for more information see\n            https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#from_over_into\nhelp: replace the `Into` implementation with `From<types::Time>`\n    |\n517 ~ impl From<Time> for u32 {\n518 ~     fn from(val: Time) -> Self {\n519 ~         val.epoch_secs as u32\n    |\n\n"
    },
    {
      "cmd_idx": 13,
      "file": "Not supported to display yet.",
      "kind": "Lockbud(Possibly)",
      "raw": "[2024-10-05T04:19:53Z WARN  lockbud::callbacks] [\n      {\n        \"AtomicityViolation\": {\n          \"bug_kind\": \"AtomicityViolation\",\n          \"possibility\": \"Possibly\",\n          \"diagnosis\": {\n            \"fn_name\": \"set_logger_racy\",\n            \"atomic_reader\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/lib.rs:1447:11: 1447:40 (#0)\",\n            \"atomic_writer\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/lib.rs:1450:13: 1450:56 (#0)\",\n            \"dep_kind\": \"Control\"\n          },\n          \"explanation\": \"atomic::store is data/control dependent on atomic::load\"\n        }\n      }\n    ]\n[2024-10-05T04:19:53Z WARN  lockbud::callbacks] crate log contains bugs: { probably: 0, possibly: 0 }, conflictlock: { probably: 0, possibly: 0 }, condvar_deadlock: { probably: 0, possibly: 0 }, atomicity_violation: { possibly: 1 }, invalid_free: { possibly: 0 }, use_after_free: { possibly: 0 }\n[2024-10-05T04:19:21Z WARN  lockbud::callbacks] [\n      {\n        \"AtomicityViolation\": {\n          \"bug_kind\": \"AtomicityViolation\",\n          \"possibility\": \"Possibly\",\n          \"diagnosis\": {\n            \"fn_name\": \"set_logger_racy\",\n            \"atomic_reader\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/lib.rs:1447:11: 1447:40 (#0)\",\n            \"atomic_writer\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/lib.rs:1450:13: 1450:56 (#0)\",\n            \"dep_kind\": \"Control\"\n          },\n          \"explanation\": \"atomic::store is data/control dependent on atomic::load\"\n        }\n      }\n    ]\n[2024-10-05T04:19:21Z WARN  lockbud::callbacks] crate log contains bugs: { probably: 0, possibly: 0 }, conflictlock: { probably: 0, possibly: 0 }, condvar_deadlock: { probably: 0, possibly: 0 }, atomicity_violation: { possibly: 1 }, invalid_free: { possibly: 0 }, use_after_free: { possibly: 0 }\n[2024-10-05T04:19:57Z WARN  lockbud::callbacks] [\n      {\n        \"AtomicityViolation\": {\n          \"bug_kind\": \"AtomicityViolation\",\n          \"possibility\": \"Possibly\",\n          \"diagnosis\": {\n            \"fn_name\": \"regex_automata::util::pool::inner::Pool::<T, F>::get\",\n            \"atomic_reader\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.8/src/util/pool.rs:525:25: 525:59 (#0)\",\n            \"atomic_writer\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.8/src/util/pool.rs:530:17: 530:69 (#0)\",\n            \"dep_kind\": \"Control\"\n          },\n          \"explanation\": \"atomic::store is data/control dependent on atomic::load\"\n        }\n      }\n    ]\n[2024-10-05T04:19:57Z WARN  lockbud::callbacks] crate bindgen contains bugs: { probably: 0, possibly: 0 }, conflictlock: { probably: 0, possibly: 0 }, condvar_deadlock: { probably: 0, possibly: 0 }, atomicity_violation: { possibly: 1 }, invalid_free: { possibly: 0 }, use_after_free: { possibly: 0 }"
    },
    {
      "cmd_idx": 14,
      "file": "(virtual) clippy",
      "kind": "Cargo",
      "raw": "// pkg_name=lwext4-rs, checker=Clippy\n// toolchain=nightly-x86_64-unknown-linux-gnu, target=x86_64-unknown-linux-gnu\n// pkg_dir=/home/runner/check/batch_8/kern-crates/lwext4/lwext4-rs\n// cmd=cargo clippy --target x86_64-unknown-linux-gnu --no-deps --message-format=json\n   Compiling proc-macro2 v1.0.86\n   Compiling glob v0.3.1\n   Compiling unicode-ident v1.0.13\n   Compiling prettyplease v0.2.22\n   Compiling libc v0.2.159\n   Compiling rustix v0.38.37\n   Compiling minimal-lexical v0.2.1\n   Compiling memchr v2.7.4\n   Compiling clang-sys v1.8.1\n   Compiling bitflags v2.6.0\n   Compiling quote v1.0.37\n   Compiling regex-syntax v0.8.5\n   Compiling linux-raw-sys v0.4.14\n   Compiling cfg-if v1.0.0\n   Compiling libloading v0.8.5\n   Compiling nom v7.1.3\n   Compiling syn v2.0.79\n   Compiling regex-automata v0.4.8\n   Compiling either v1.13.0\n   Compiling bindgen v0.65.1\n   Compiling home v0.5.9\n   Compiling which v4.4.2\n   Compiling regex v1.11.0\n   Compiling cexpr v0.6.0\n   Compiling peeking_take_while v0.1.2\n   Compiling rustc-hash v1.1.0\n   Compiling lazycell v1.3.0\n   Compiling shlex v1.3.0\n   Compiling log v0.4.22\n   Compiling bitflags v1.3.2\n   Compiling lazy_static v1.5.0\n   Compiling lwext4-sys v0.1.0 (/home/runner/check/batch_8/kern-crates/lwext4/lwext4-sys)\n    Checking lwext4-rs v0.1.0 (/home/runner/check/batch_8/kern-crates/lwext4/lwext4-rs)\nerror: could not compile `lwext4-rs` (lib) due to 1 previous error; 29 warnings emitted\n"
    },
    {
      "cmd_idx": 15,
      "file": "src/ext4.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_8/kern-crates/lwext4/lwext4-sys/src/ext4.rs (original lines from 3 to 3)\n-# [repr (C)] # [derive (Default)] pub struct __IncompleteArrayField < T > (:: core :: marker :: PhantomData < T > , [T ; 0]) ; impl < T > __IncompleteArrayField < T > { # [inline] pub const fn new () -> Self { __IncompleteArrayField (:: core :: marker :: PhantomData , []) } # [inline] pub fn as_ptr (& self) -> * const T { self as * const _ as * const T } # [inline] pub fn as_mut_ptr (& mut self) -> * mut T { self as * mut _ as * mut T } # [inline] pub unsafe fn as_slice (& self , len : usize) -> & [T] { :: core :: slice :: from_raw_parts (self . as_ptr () , len) } # [inline] pub unsafe fn as_mut_slice (& mut self , len : usize) -> & mut [T] { :: core :: slice :: from_raw_parts_mut (self . as_mut_ptr () , len) } } impl < T > :: core :: fmt :: Debug for __IncompleteArrayField < T > { fn fmt (& self , fmt : & mut :: core :: fmt :: Formatter < '_ >) -> :: core :: fmt :: Result { fmt . write_str (\"__IncompleteArrayField\") } } pub const _STDINT_H : u32 = 1 ; pub const _FEATURES_H : u32 = 1 ; pub const _DEFAULT_SOURCE : u32 = 1 ; pub const __GLIBC_USE_ISOC2X : u32 = 0 ; pub const __USE_ISOC11 : u32 = 1 ; pub const __USE_ISOC99 : u32 = 1 ; pub const __USE_ISOC95 : u32 = 1 ; pub const __USE_POSIX_IMPLICITLY : u32 = 1 ; pub const _POSIX_SOURCE : u32 = 1 ; pub const _POSIX_C_SOURCE : u32 = 200809 ; pub const __USE_POSIX : u32 = 1 ; pub const __USE_POSIX2 : u32 = 1 ; pub const __USE_POSIX199309 : u32 = 1 ; pub const __USE_POSIX199506 : u32 = 1 ; pub const __USE_XOPEN2K : u32 = 1 ; pub const __USE_XOPEN2K8 : u32 = 1 ; pub const _ATFILE_SOURCE : u32 = 1 ; pub const __WORDSIZE : u32 = 64 ; pub const __WORDSIZE_TIME64_COMPAT32 : u32 = 1 ; pub const __SYSCALL_WORDSIZE : u32 = 64 ; pub const __TIMESIZE : u32 = 64 ; pub const __USE_MISC : u32 = 1 ; pub const __USE_ATFILE : u32 = 1 ; pub const __USE_FORTIFY_LEVEL : u32 = 0 ; pub const __GLIBC_USE_DEPRECATED_GETS : u32 = 0 ; pub const __GLIBC_USE_DEPRECATED_SCANF : u32 = 0 ; pub const _STDC_PREDEF_H : u32 = 1 ; pub const __STDC_IEC_559__ : u32 = 1 ; pub const __STDC_IEC_60559_BFP__ : u32 = 201404 ; pub const __STDC_IEC_559_COMPLEX__ : u32 = 1 ; pub const __STDC_IEC_60559_COMPLEX__ : u32 = 201404 ; pub const __STDC_ISO_10646__ : u32 = 201706 ; pub const __GNU_LIBRARY__ : u32 = 6 ; pub const __GLIBC__ : u32 = 2 ; pub const __GLIBC_MINOR__ : u32 = 35 ; pub const _SYS_CDEFS_H : u32 = 1 ; pub const __glibc_c99_flexarr_available : u32 = 1 ; pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI : u32 = 0 ; pub const __HAVE_GENERIC_SELECTION : u32 = 1 ; pub const __GLIBC_USE_LIB_EXT2 : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_BFP_EXT : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_EXT : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_FUNCS_EXT : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X : u32 = 0 ; pub const __GLIBC_USE_IEC_60559_TYPES_EXT : u32 = 0 ; pub const _BITS_TYPES_H : u32 = 1 ; pub const _BITS_TYPESIZES_H : u32 = 1 ; pub const __OFF_T_MATCHES_OFF64_T : u32 = 1 ; pub const __INO_T_MATCHES_INO64_T : u32 = 1 ; pub const __RLIM_T_MATCHES_RLIM64_T : u32 = 1 ; pub const __STATFS_MATCHES_STATFS64 : u32 = 1 ; pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 : u32 = 1 ; pub const __FD_SETSIZE : u32 = 1024 ; pub const _BITS_TIME64_H : u32 = 1 ; pub const _BITS_WCHAR_H : u32 = 1 ; pub const _BITS_STDINT_INTN_H : u32 = 1 ; pub const _BITS_STDINT_UINTN_H : u32 = 1 ; pub const INT8_MIN : i32 = - 128 ; pub const INT16_MIN : i32 = - 32768 ; pub const INT32_MIN : i32 = - 2147483648 ; pub const INT8_MAX : u32 = 127 ; pub const INT16_MAX : u32 = 32767 ; pub const INT32_MAX : u32 = 2147483647 ; pub const UINT8_MAX : u32 = 255 ; pub const UINT16_MAX : u32 = 65535 ; pub const UINT32_MAX : u32 = 4294967295 ; pub const INT_LEAST8_MIN : i32 = - 128 ; pub const INT_LEAST16_MIN : i32 = - 32768 ; pub const INT_LEAST32_MIN : i32 = - 2147483648 ; pub const INT_LEAST8_MAX : u32 = 127 ; pub const INT_LEAST16_MAX : u32 = 32767 ; pub const INT_LEAST32_MAX : u32 = 2147483647 ; pub const UINT_LEAST8_MAX : u32 = 255 ; pub const UINT_LEAST16_MAX : u32 = 65535 ; pub const UINT_LEAST32_MAX : u32 = 4294967295 ; pub const INT_FAST8_MIN : i32 = - 128 ; pub const INT_FAST16_MIN : i64 = - 9223372036854775808 ; pub const INT_FAST32_MIN : i64 = - 9223372036854775808 ; pub const INT_FAST8_MAX : u32 = 127 ; pub const INT_FAST16_MAX : u64 = 9223372036854775807 ; pub const INT_FAST32_MAX : u64 = 9223372036854775807 ; pub const UINT_FAST8_MAX : u32 = 255 ; pub const UINT_FAST16_MAX : i32 = - 1 ; pub const UINT_FAST32_MAX : i32 = - 1 ; pub const INTPTR_MIN : i64 = - 9223372036854775808 ; pub const INTPTR_MAX : u64 = 9223372036854775807 ; pub const UINTPTR_MAX : i32 = - 1 ; pub const PTRDIFF_MIN : i64 = - 9223372036854775808 ; pub const PTRDIFF_MAX : u64 = 9223372036854775807 ; pub const SIG_ATOMIC_MIN : i32 = - 2147483648 ; pub const SIG_ATOMIC_MAX : u32 = 2147483647 ; pub const SIZE_MAX : i32 = - 1 ; pub const WINT_MIN : u32 = 0 ; pub const WINT_MAX : u32 = 4294967295 ; pub const CONFIG_USE_DEFAULT_CONFIG : u32 = 0 ; pub const CONFIG_DEBUG_PRINTF : u32 = 1 ; pub const CONFIG_HAVE_OWN_OFLAGS : u32 = 1 ; pub const CONFIG_HAVE_OWN_ERRNO : u32 = 1 ; pub const CONFIG_HAVE_OWN_ASSERT : u32 = 1 ; pub const CONFIG_BLOCK_DEV_CACHE_SIZE : u32 = 16 ; pub const F_SET_EXT2 : u32 = 2 ; pub const F_SET_EXT3 : u32 = 3 ; pub const F_SET_EXT4 : u32 = 4 ; pub const CONFIG_EXT_FEATURE_SET_LVL : u32 = 4 ; pub const CONFIG_JOURNALING_ENABLE : u32 = 1 ; pub const CONFIG_XATTR_ENABLE : u32 = 1 ; pub const CONFIG_EXTENTS_ENABLE : u32 = 1 ; pub const CONFIG_DEBUG_ASSERT : u32 = 1 ; pub const CONFIG_BLOCK_DEV_ENABLE_STATS : u32 = 1 ; pub const CONFIG_EXT4_MAX_BLOCKDEV_NAME : u32 = 32 ; pub const CONFIG_EXT4_BLOCKDEVS_COUNT : u32 = 2 ; pub const CONFIG_EXT4_MAX_MP_NAME : u32 = 32 ; pub const CONFIG_EXT4_MOUNTPOINTS_COUNT : u32 = 2 ; pub const CONFIG_MAX_TRUNCATE_SIZE : u32 = 16777216 ; pub const CONFIG_UNALIGNED_ACCESS : u32 = 0 ; pub const CONFIG_USE_USER_MALLOC : u32 = 0 ; pub const true_ : u32 = 1 ; pub const false_ : u32 = 0 ; pub const __bool_true_false_are_defined : u32 = 1 ; pub const SPLAY_NEGINF : i32 = - 1 ; pub const SPLAY_INF : u32 = 1 ; pub const RB_BLACK : u32 = 0 ; pub const RB_RED : u32 = 1 ; pub const RB_NEGINF : i32 = - 1 ; pub const RB_INF : u32 = 1 ; pub const EXT4_CHECKSUM_CRC32C : u32 = 1 ; pub const UUID_SIZE : u32 = 16 ; pub const EXT4_SUPERBLOCK_MAGIC : u32 = 61267 ; pub const EXT4_SUPERBLOCK_SIZE : u32 = 1024 ; pub const EXT4_SUPERBLOCK_OFFSET : u32 = 1024 ; pub const EXT4_SUPERBLOCK_OS_LINUX : u32 = 0 ; pub const EXT4_SUPERBLOCK_OS_HURD : u32 = 1 ; pub const EXT4_SUPERBLOCK_FLAGS_SIGNED_HASH : u32 = 1 ; pub const EXT4_SUPERBLOCK_FLAGS_UNSIGNED_HASH : u32 = 2 ; pub const EXT4_SUPERBLOCK_FLAGS_TEST_FILESYS : u32 = 4 ; pub const EXT4_SUPERBLOCK_STATE_VALID_FS : u32 = 1 ; pub const EXT4_SUPERBLOCK_STATE_ERROR_FS : u32 = 2 ; pub const EXT4_SUPERBLOCK_STATE_ORPHAN_FS : u32 = 4 ; pub const EXT4_SUPERBLOCK_ERRORS_CONTINUE : u32 = 1 ; pub const EXT4_SUPERBLOCK_ERRORS_RO : u32 = 2 ; pub const EXT4_SUPERBLOCK_ERRORS_PANIC : u32 = 3 ; pub const EXT4_FCOM_DIR_PREALLOC : u32 = 1 ; pub const EXT4_FCOM_IMAGIC_INODES : u32 = 2 ; pub const EXT4_FCOM_HAS_JOURNAL : u32 = 4 ; pub const EXT4_FCOM_EXT_ATTR : u32 = 8 ; pub const EXT4_FCOM_RESIZE_INODE : u32 = 16 ; pub const EXT4_FCOM_DIR_INDEX : u32 = 32 ; pub const EXT4_FRO_COM_SPARSE_SUPER : u32 = 1 ; pub const EXT4_FRO_COM_LARGE_FILE : u32 = 2 ; pub const EXT4_FRO_COM_BTREE_DIR : u32 = 4 ; pub const EXT4_FRO_COM_HUGE_FILE : u32 = 8 ; pub const EXT4_FRO_COM_GDT_CSUM : u32 = 16 ; pub const EXT4_FRO_COM_DIR_NLINK : u32 = 32 ; pub const EXT4_FRO_COM_EXTRA_ISIZE : u32 = 64 ; pub const EXT4_FRO_COM_QUOTA : u32 = 256 ; pub const EXT4_FRO_COM_BIGALLOC : u32 = 512 ; pub const EXT4_FRO_COM_METADATA_CSUM : u32 = 1024 ; pub const EXT4_FINCOM_COMPRESSION : u32 = 1 ; pub const EXT4_FINCOM_FILETYPE : u32 = 2 ; pub const EXT4_FINCOM_RECOVER : u32 = 4 ; pub const EXT4_FINCOM_JOURNAL_DEV : u32 = 8 ; pub const EXT4_FINCOM_META_BG : u32 = 16 ; pub const EXT4_FINCOM_EXTENTS : u32 = 64 ; pub const EXT4_FINCOM_64BIT : u32 = 128 ; pub const EXT4_FINCOM_MMP : u32 = 256 ; pub const EXT4_FINCOM_FLEX_BG : u32 = 512 ; pub const EXT4_FINCOM_EA_INODE : u32 = 1024 ; pub const EXT4_FINCOM_DIRDATA : u32 = 4096 ; pub const EXT4_FINCOM_BG_USE_META_CSUM : u32 = 8192 ; pub const EXT4_FINCOM_LARGEDIR : u32 = 16384 ; pub const EXT4_FINCOM_INLINE_DATA : u32 = 32768 ; pub const EXT2_SUPPORTED_FCOM : u32 = 0 ; pub const EXT2_SUPPORTED_FINCOM : u32 = 18 ; pub const EXT2_SUPPORTED_FRO_COM : u32 = 3 ; pub const EXT3_SUPPORTED_FCOM : u32 = 32 ; pub const EXT3_SUPPORTED_FINCOM : u32 = 18 ; pub const EXT3_SUPPORTED_FRO_COM : u32 = 3 ; pub const EXT4_SUPPORTED_FCOM : u32 = 32 ; pub const EXT4_SUPPORTED_FINCOM : u32 = 722 ; pub const EXT4_SUPPORTED_FRO_COM : u32 = 1147 ; pub const EXT_FINCOM_IGNORED : u32 = 260 ; pub const EXT4_BLOCK_GROUP_INODE_UNINIT : u32 = 1 ; pub const EXT4_BLOCK_GROUP_BLOCK_UNINIT : u32 = 2 ; pub const EXT4_BLOCK_GROUP_ITABLE_ZEROED : u32 = 4 ; pub const EXT4_MIN_BLOCK_GROUP_DESCRIPTOR_SIZE : u32 = 32 ; pub const EXT4_MAX_BLOCK_GROUP_DESCRIPTOR_SIZE : u32 = 64 ; pub const EXT4_MIN_BLOCK_SIZE : u32 = 1024 ; pub const EXT4_MAX_BLOCK_SIZE : u32 = 65536 ; pub const EXT4_REV0_INODE_SIZE : u32 = 128 ; pub const EXT4_INODE_BLOCK_SIZE : u32 = 512 ; pub const EXT4_INODE_DIRECT_BLOCK_COUNT : u32 = 12 ; pub const EXT4_INODE_INDIRECT_BLOCK : u32 = 12 ; pub const EXT4_INODE_DOUBLE_INDIRECT_BLOCK : u32 = 13 ; pub const EXT4_INODE_TRIPPLE_INDIRECT_BLOCK : u32 = 14 ; pub const EXT4_INODE_BLOCKS : u32 = 15 ; pub const EXT4_INODE_INDIRECT_BLOCK_COUNT : u32 = 3 ; pub const EXT4_INODE_MODE_FIFO : u32 = 4096 ; pub const EXT4_INODE_MODE_CHARDEV : u32 = 8192 ; pub const EXT4_INODE_MODE_DIRECTORY : u32 = 16384 ; pub const EXT4_INODE_MODE_BLOCKDEV : u32 = 24576 ; pub const EXT4_INODE_MODE_FILE : u32 = 32768 ; pub const EXT4_INODE_MODE_SOFTLINK : u32 = 40960 ; pub const EXT4_INODE_MODE_SOCKET : u32 = 49152 ; pub const EXT4_INODE_MODE_TYPE_MASK : u32 = 61440 ; pub const EXT4_INODE_FLAG_SECRM : u32 = 1 ; pub const EXT4_INODE_FLAG_UNRM : u32 = 2 ; pub const EXT4_INODE_FLAG_COMPR : u32 = 4 ; pub const EXT4_INODE_FLAG_SYNC : u32 = 8 ; pub const EXT4_INODE_FLAG_IMMUTABLE : u32 = 16 ; pub const EXT4_INODE_FLAG_APPEND : u32 = 32 ; pub const EXT4_INODE_FLAG_NODUMP : u32 = 64 ; pub const EXT4_INODE_FLAG_NOATIME : u32 = 128 ; pub const EXT4_INODE_FLAG_DIRTY : u32 = 256 ; pub const EXT4_INODE_FLAG_COMPRBLK : u32 = 512 ; pub const EXT4_INODE_FLAG_NOCOMPR : u32 = 1024 ; pub const EXT4_INODE_FLAG_ECOMPR : u32 = 2048 ; pub const EXT4_INODE_FLAG_INDEX : u32 = 4096 ; pub const EXT4_INODE_FLAG_IMAGIC : u32 = 8192 ; pub const EXT4_INODE_FLAG_JOURNAL_DATA : u32 = 16384 ; pub const EXT4_INODE_FLAG_NOTAIL : u32 = 32768 ; pub const EXT4_INODE_FLAG_DIRSYNC : u32 = 65536 ; pub const EXT4_INODE_FLAG_TOPDIR : u32 = 131072 ; pub const EXT4_INODE_FLAG_HUGE_FILE : u32 = 262144 ; pub const EXT4_INODE_FLAG_EXTENTS : u32 = 524288 ; pub const EXT4_INODE_FLAG_EA_INODE : u32 = 2097152 ; pub const EXT4_INODE_FLAG_EOFBLOCKS : u32 = 4194304 ; pub const EXT4_INODE_FLAG_RESERVED : u32 = 2147483648 ; pub const EXT4_INODE_ROOT_INDEX : u32 = 2 ; pub const EXT4_DIRECTORY_FILENAME_LEN : u32 = 255 ; pub const EXT4_DIRENTRY_DIR_CSUM : u32 = 222 ; pub const EXT4_ERR_BAD_DX_DIR : i32 = - 25000 ; pub const EXT4_LINK_MAX : u32 = 65000 ; pub const EXT4_BAD_INO : u32 = 1 ; pub const EXT4_ROOT_INO : u32 = 2 ; pub const EXT4_BOOT_LOADER_INO : u32 = 5 ; pub const EXT4_UNDEL_DIR_INO : u32 = 6 ; pub const EXT4_RESIZE_INO : u32 = 7 ; pub const EXT4_JOURNAL_INO : u32 = 8 ; pub const EXT4_GOOD_OLD_FIRST_INO : u32 = 11 ; pub const EXT2_HTREE_LEGACY : u32 = 0 ; pub const EXT2_HTREE_HALF_MD4 : u32 = 1 ; pub const EXT2_HTREE_TEA : u32 = 2 ; pub const EXT2_HTREE_LEGACY_UNSIGNED : u32 = 3 ; pub const EXT2_HTREE_HALF_MD4_UNSIGNED : u32 = 4 ; pub const EXT2_HTREE_TEA_UNSIGNED : u32 = 5 ; pub const EXT2_HTREE_EOF : u32 = 2147483647 ; pub const EXT4_GOOD_OLD_INODE_SIZE : u32 = 128 ; pub const JBD_MAGIC_NUMBER : u32 = 3225106840 ; pub const JBD_DESCRIPTOR_BLOCK : u32 = 1 ; pub const JBD_COMMIT_BLOCK : u32 = 2 ; pub const JBD_SUPERBLOCK : u32 = 3 ; pub const JBD_SUPERBLOCK_V2 : u32 = 4 ; pub const JBD_REVOKE_BLOCK : u32 = 5 ; pub const JBD_CRC32_CHKSUM : u32 = 1 ; pub const JBD_MD5_CHKSUM : u32 = 2 ; pub const JBD_SHA1_CHKSUM : u32 = 3 ; pub const JBD_CRC32C_CHKSUM : u32 = 4 ; pub const JBD_CRC32_CHKSUM_SIZE : u32 = 4 ; pub const JBD_FLAG_ESCAPE : u32 = 1 ; pub const JBD_FLAG_SAME_UUID : u32 = 2 ; pub const JBD_FLAG_DELETED : u32 = 4 ; pub const JBD_FLAG_LAST_TAG : u32 = 8 ; pub const JBD_USERS_MAX : u32 = 48 ; pub const JBD_USERS_SIZE : u32 = 768 ; pub const JBD_FEATURE_COMPAT_CHECKSUM : u32 = 1 ; pub const JBD_FEATURE_INCOMPAT_REVOKE : u32 = 1 ; pub const JBD_FEATURE_INCOMPAT_64BIT : u32 = 2 ; pub const JBD_FEATURE_INCOMPAT_ASYNC_COMMIT : u32 = 4 ; pub const JBD_FEATURE_INCOMPAT_CSUM_V2 : u32 = 8 ; pub const JBD_FEATURE_INCOMPAT_CSUM_V3 : u32 = 16 ; pub const JBD_KNOWN_COMPAT_FEATURES : u32 = 0 ; pub const JBD_KNOWN_ROCOMPAT_FEATURES : u32 = 0 ; pub const JBD_KNOWN_INCOMPAT_FEATURES : u32 = 31 ; pub const EXT4_CRC32_INIT : u32 = 4294967295 ; pub const EPERM : u32 = 1 ; pub const ENOENT : u32 = 2 ; pub const EIO : u32 = 5 ; pub const ENXIO : u32 = 6 ; pub const E2BIG : u32 = 7 ; pub const ENOMEM : u32 = 12 ; pub const EACCES : u32 = 13 ; pub const EFAULT : u32 = 14 ; pub const EEXIST : u32 = 17 ; pub const ENODEV : u32 = 19 ; pub const ENOTDIR : u32 = 20 ; pub const EISDIR : u32 = 21 ; pub const EINVAL : u32 = 22 ; pub const EFBIG : u32 = 27 ; pub const ENOSPC : u32 = 28 ; pub const EROFS : u32 = 30 ; pub const EMLINK : u32 = 31 ; pub const ERANGE : u32 = 34 ; pub const ENOTEMPTY : u32 = 39 ; pub const ENODATA : u32 = 61 ; pub const ENOTSUP : u32 = 95 ; pub const EOK : u32 = 0 ; pub const O_RDONLY : u32 = 0 ; pub const O_WRONLY : u32 = 1 ; pub const O_RDWR : u32 = 2 ; pub const O_CREAT : u32 = 64 ; pub const O_EXCL : u32 = 128 ; pub const O_TRUNC : u32 = 512 ; pub const O_APPEND : u32 = 1024 ; pub const SEEK_SET : u32 = 0 ; pub const SEEK_CUR : u32 = 1 ; pub const SEEK_END : u32 = 2 ; pub const _INTTYPES_H : u32 = 1 ; pub const ____gwchar_t_defined : u32 = 1 ; pub const __PRI64_PREFIX : & [u8 ; 2usize] = b\"l\\0\" ; pub const __PRIPTR_PREFIX : & [u8 ; 2usize] = b\"l\\0\" ; pub const PRId8 : & [u8 ; 2usize] = b\"d\\0\" ; pub const PRId16 : & [u8 ; 2usize] = b\"d\\0\" ; pub const PRId32 : & [u8 ; 2usize] = b\"d\\0\" ; pub const PRId64 : & [u8 ; 3usize] = b\"ld\\0\" ; pub const PRIdLEAST8 : & [u8 ; 2usize] = b\"d\\0\" ; pub const PRIdLEAST16 : & [u8 ; 2usize] = b\"d\\0\" ; pub const PRIdLEAST32 : & [u8 ; 2usize] = b\"d\\0\" ; pub const PRIdLEAST64 : & [u8 ; 3usize] = b\"ld\\0\" ; pub const PRIdFAST8 : & [u8 ; 2usize] = b\"d\\0\" ; pub const PRIdFAST16 : & [u8 ; 3usize] = b\"ld\\0\" ; pub const PRIdFAST32 : & [u8 ; 3usize] = b\"ld\\0\" ; pub const PRIdFAST64 : & [u8 ; 3usize] = b\"ld\\0\" ; pub const PRIi8 : & [u8 ; 2usize] = b\"i\\0\" ; pub const PRIi16 : & [u8 ; 2usize] = b\"i\\0\" ; pub const PRIi32 : & [u8 ; 2usize] = b\"i\\0\" ; pub const PRIi64 : & [u8 ; 3usize] = b\"li\\0\" ; pub const PRIiLEAST8 : & [u8 ; 2usize] = b\"i\\0\" ; pub const PRIiLEAST16 : & [u8 ; 2usize] = b\"i\\0\" ; pub const PRIiLEAST32 : & [u8 ; 2usize] = b\"i\\0\" ; pub const PRIiLEAST64 : & [u8 ; 3usize] = b\"li\\0\" ; pub const PRIiFAST8 : & [u8 ; 2usize] = b\"i\\0\" ; pub const PRIiFAST16 : & [u8 ; 3usize] = b\"li\\0\" ; pub const PRIiFAST32 : & [u8 ; 3usize] = b\"li\\0\" ; pub const PRIiFAST64 : & [u8 ; 3usize] = b\"li\\0\" ; pub const PRIo8 : & [u8 ; 2usize] = b\"o\\0\" ; pub const PRIo16 : & [u8 ; 2usize] = b\"o\\0\" ; pub const PRIo32 : & [u8 ; 2usize] = b\"o\\0\" ; pub const PRIo64 : & [u8 ; 3usize] = b\"lo\\0\" ; pub const PRIoLEAST8 : & [u8 ; 2usize] = b\"o\\0\" ; pub const PRIoLEAST16 : & [u8 ; 2usize] = b\"o\\0\" ; pub const PRIoLEAST32 : & [u8 ; 2usize] = b\"o\\0\" ; pub const PRIoLEAST64 : & [u8 ; 3usize] = b\"lo\\0\" ; pub const PRIoFAST8 : & [u8 ; 2usize] = b\"o\\0\" ; pub const PRIoFAST16 : & [u8 ; 3usize] = b\"lo\\0\" ; pub const PRIoFAST32 : & [u8 ; 3usize] = b\"lo\\0\" ; pub const PRIoFAST64 : & [u8 ; 3usize] = b\"lo\\0\" ; pub const PRIu8 : & [u8 ; 2usize] = b\"u\\0\" ; pub const PRIu16 : & [u8 ; 2usize] = b\"u\\0\" ; pub const PRIu32 : & [u8 ; 2usize] = b\"u\\0\" ; pub const PRIu64 : & [u8 ; 3usize] = b\"lu\\0\" ; pub const PRIuLEAST8 : & [u8 ; 2usize] = b\"u\\0\" ; pub const PRIuLEAST16 : & [u8 ; 2usize] = b\"u\\0\" ; pub const PRIuLEAST32 : & [u8 ; 2usize] = b\"u\\0\" ; pub const PRIuLEAST64 : & [u8 ; 3usize] = b\"lu\\0\" ; pub const PRIuFAST8 : & [u8 ; 2usize] = b\"u\\0\" ; pub const PRIuFAST16 : & [u8 ; 3usize] = b\"lu\\0\" ; pub const PRIuFAST32 : & [u8 ; 3usize] = b\"lu\\0\" ; pub const PRIuFAST64 : & [u8 ; 3usize] = b\"lu\\0\" ; pub const PRIx8 : & [u8 ; 2usize] = b\"x\\0\" ; pub const PRIx16 : & [u8 ; 2usize] = b\"x\\0\" ; pub const PRIx32 : & [u8 ; 2usize] = b\"x\\0\" ; pub const PRIx64 : & [u8 ; 3usize] = b\"lx\\0\" ; pub const PRIxLEAST8 : & [u8 ; 2usize] = b\"x\\0\" ; pub const PRIxLEAST16 : & [u8 ; 2usize] = b\"x\\0\" ; pub const PRIxLEAST32 : & [u8 ; 2usize] = b\"x\\0\" ; pub const PRIxLEAST64 : & [u8 ; 3usize] = b\"lx\\0\" ; pub const PRIxFAST8 : & [u8 ; 2usize] = b\"x\\0\" ; pub const PRIxFAST16 : & [u8 ; 3usize] = b\"lx\\0\" ; pub const PRIxFAST32 : & [u8 ; 3usize] = b\"lx\\0\" ; pub const PRIxFAST64 : & [u8 ; 3usize] = b\"lx\\0\" ; pub const PRIX8 : & [u8 ; 2usize] = b\"X\\0\" ; pub const PRIX16 : & [u8 ; 2usize] = b\"X\\0\" ; pub const PRIX32 : & [u8 ; 2usize] = b\"X\\0\" ; pub const PRIX64 : & [u8 ; 3usize] = b\"lX\\0\" ; pub const PRIXLEAST8 : & [u8 ; 2usize] = b\"X\\0\" ; pub const PRIXLEAST16 : & [u8 ; 2usize] = b\"X\\0\" ; pub const PRIXLEAST32 : & [u8 ; 2usize] = b\"X\\0\" ; pub const PRIXLEAST64 : & [u8 ; 3usize] = b\"lX\\0\" ; pub const PRIXFAST8 : & [u8 ; 2usize] = b\"X\\0\" ; pub const PRIXFAST16 : & [u8 ; 3usize] = b\"lX\\0\" ; pub const PRIXFAST32 : & [u8 ; 3usize] = b\"lX\\0\" ; pub const PRIXFAST64 : & [u8 ; 3usize] = b\"lX\\0\" ; pub const PRIdMAX : & [u8 ; 3usize] = b\"ld\\0\" ; pub const PRIiMAX : & [u8 ; 3usize] = b\"li\\0\" ; pub const PRIoMAX : & [u8 ; 3usize] = b\"lo\\0\" ; pub const PRIuMAX : & [u8 ; 3usize] = b\"lu\\0\" ; pub const PRIxMAX : & [u8 ; 3usize] = b\"lx\\0\" ; pub const PRIXMAX : & [u8 ; 3usize] = b\"lX\\0\" ; pub const PRIdPTR : & [u8 ; 3usize] = b\"ld\\0\" ; pub const PRIiPTR : & [u8 ; 3usize] = b\"li\\0\" ; pub const PRIoPTR : & [u8 ; 3usize] = b\"lo\\0\" ; pub const PRIuPTR : & [u8 ; 3usize] = b\"lu\\0\" ; pub const PRIxPTR : & [u8 ; 3usize] = b\"lx\\0\" ; pub const PRIXPTR : & [u8 ; 3usize] = b\"lX\\0\" ; pub const SCNd8 : & [u8 ; 4usize] = b\"hhd\\0\" ; pub const SCNd16 : & [u8 ; 3usize] = b\"hd\\0\" ; pub const SCNd32 : & [u8 ; 2usize] = b\"d\\0\" ; pub const SCNd64 : & [u8 ; 3usize] = b\"ld\\0\" ; pub const SCNdLEAST8 : & [u8 ; 4usize] = b\"hhd\\0\" ; pub const SCNdLEAST16 : & [u8 ; 3usize] = b\"hd\\0\" ; pub const SCNdLEAST32 : & [u8 ; 2usize] = b\"d\\0\" ; pub const SCNdLEAST64 : & [u8 ; 3usize] = b\"ld\\0\" ; pub const SCNdFAST8 : & [u8 ; 4usize] = b\"hhd\\0\" ; pub const SCNdFAST16 : & [u8 ; 3usize] = b\"ld\\0\" ; pub const SCNdFAST32 : & [u8 ; 3usize] = b\"ld\\0\" ; pub const SCNdFAST64 : & [u8 ; 3usize] = b\"ld\\0\" ; pub const SCNi8 : & [u8 ; 4usize] = b\"hhi\\0\" ; pub const SCNi16 : & [u8 ; 3usize] = b\"hi\\0\" ; pub const SCNi32 : & [u8 ; 2usize] = b\"i\\0\" ; pub const SCNi64 : & [u8 ; 3usize] = b\"li\\0\" ; pub const SCNiLEAST8 : & [u8 ; 4usize] = b\"hhi\\0\" ; pub const SCNiLEAST16 : & [u8 ; 3usize] = b\"hi\\0\" ; pub const SCNiLEAST32 : & [u8 ; 2usize] = b\"i\\0\" ; pub const SCNiLEAST64 : & [u8 ; 3usize] = b\"li\\0\" ; pub const SCNiFAST8 : & [u8 ; 4usize] = b\"hhi\\0\" ; pub const SCNiFAST16 : & [u8 ; 3usize] = b\"li\\0\" ; pub const SCNiFAST32 : & [u8 ; 3usize] = b\"li\\0\" ; pub const SCNiFAST64 : & [u8 ; 3usize] = b\"li\\0\" ; pub const SCNu8 : & [u8 ; 4usize] = b\"hhu\\0\" ; pub const SCNu16 : & [u8 ; 3usize] = b\"hu\\0\" ; pub const SCNu32 : & [u8 ; 2usize] = b\"u\\0\" ; pub const SCNu64 : & [u8 ; 3usize] = b\"lu\\0\" ; pub const SCNuLEAST8 : & [u8 ; 4usize] = b\"hhu\\0\" ; pub const SCNuLEAST16 : & [u8 ; 3usize] = b\"hu\\0\" ; pub const SCNuLEAST32 : & [u8 ; 2usize] = b\"u\\0\" ; pub const SCNuLEAST64 : & [u8 ; 3usize] = b\"lu\\0\" ; pub const SCNuFAST8 : & [u8 ; 4usize] = b\"hhu\\0\" ; pub const SCNuFAST16 : & [u8 ; 3usize] = b\"lu\\0\" ; pub const SCNuFAST32 : & [u8 ; 3usize] = b\"lu\\0\" ; pub const SCNuFAST64 : & [u8 ; 3usize] = b\"lu\\0\" ; pub const SCNo8 : & [u8 ; 4usize] = b\"hho\\0\" ; pub const SCNo16 : & [u8 ; 3usize] = b\"ho\\0\" ; pub const SCNo32 : & [u8 ; 2usize] = b\"o\\0\" ; pub const SCNo64 : & [u8 ; 3usize] = b\"lo\\0\" ; pub const SCNoLEAST8 : & [u8 ; 4usize] = b\"hho\\0\" ; pub const SCNoLEAST16 : & [u8 ; 3usize] = b\"ho\\0\" ; pub const SCNoLEAST32 : & [u8 ; 2usize] = b\"o\\0\" ; pub const SCNoLEAST64 : & [u8 ; 3usize] = b\"lo\\0\" ; pub const SCNoFAST8 : & [u8 ; 4usize] = b\"hho\\0\" ; pub const SCNoFAST16 : & [u8 ; 3usize] = b\"lo\\0\" ; pub const SCNoFAST32 : & [u8 ; 3usize] = b\"lo\\0\" ; pub const SCNoFAST64 : & [u8 ; 3usize] = b\"lo\\0\" ; pub const SCNx8 : & [u8 ; 4usize] = b\"hhx\\0\" ; pub const SCNx16 : & [u8 ; 3usize] = b\"hx\\0\" ; pub const SCNx32 : & [u8 ; 2usize] = b\"x\\0\" ; pub const SCNx64 : & [u8 ; 3usize] = b\"lx\\0\" ; pub const SCNxLEAST8 : & [u8 ; 4usize] = b\"hhx\\0\" ; pub const SCNxLEAST16 : & [u8 ; 3usize] = b\"hx\\0\" ; pub const SCNxLEAST32 : & [u8 ; 2usize] = b\"x\\0\" ; pub const SCNxLEAST64 : & [u8 ; 3usize] = b\"lx\\0\" ; pub const SCNxFAST8 : & [u8 ; 4usize] = b\"hhx\\0\" ; pub const SCNxFAST16 : & [u8 ; 3usize] = b\"lx\\0\" ; pub const SCNxFAST32 : & [u8 ; 3usize] = b\"lx\\0\" ; pub const SCNxFAST64 : & [u8 ; 3usize] = b\"lx\\0\" ; pub const SCNdMAX : & [u8 ; 3usize] = b\"ld\\0\" ; pub const SCNiMAX : & [u8 ; 3usize] = b\"li\\0\" ; pub const SCNoMAX : & [u8 ; 3usize] = b\"lo\\0\" ; pub const SCNuMAX : & [u8 ; 3usize] = b\"lu\\0\" ; pub const SCNxMAX : & [u8 ; 3usize] = b\"lx\\0\" ; pub const SCNdPTR : & [u8 ; 3usize] = b\"ld\\0\" ; pub const SCNiPTR : & [u8 ; 3usize] = b\"li\\0\" ; pub const SCNoPTR : & [u8 ; 3usize] = b\"lo\\0\" ; pub const SCNuPTR : & [u8 ; 3usize] = b\"lu\\0\" ; pub const SCNxPTR : & [u8 ; 3usize] = b\"lx\\0\" ; pub const DEBUG_BALLOC : u32 = 1 ; pub const DEBUG_BCACHE : u32 = 2 ; pub const DEBUG_BITMAP : u32 = 4 ; pub const DEBUG_BLOCK_GROUP : u32 = 8 ; pub const DEBUG_BLOCKDEV : u32 = 16 ; pub const DEBUG_DIR_IDX : u32 = 32 ; pub const DEBUG_DIR : u32 = 64 ; pub const DEBUG_EXTENT : u32 = 128 ; pub const DEBUG_FS : u32 = 256 ; pub const DEBUG_HASH : u32 = 512 ; pub const DEBUG_IALLOC : u32 = 1024 ; pub const DEBUG_INODE : u32 = 2048 ; pub const DEBUG_SUPER : u32 = 4096 ; pub const DEBUG_XATTR : u32 = 8192 ; pub const DEBUG_MKFS : u32 = 16384 ; pub const DEBUG_EXT4 : u32 = 32768 ; pub const DEBUG_JBD : u32 = 65536 ; pub const DEBUG_MBR : u32 = 131072 ; pub const DEBUG_NOPREFIX : u32 = 2147483648 ; pub const DEBUG_ALL : u32 = 4294967295 ; pub const DBG_NONE : & [u8 ; 1usize] = b\"\\0\" ; pub const DBG_INFO : & [u8 ; 9usize] = b\"[info]  \\0\" ; pub const DBG_WARN : & [u8 ; 9usize] = b\"[warn]  \\0\" ; pub const DBG_ERROR : & [u8 ; 9usize] = b\"[error] \\0\" ; pub const _STDIO_H : u32 = 1 ; pub const __GNUC_VA_LIST : u32 = 1 ; pub const _____fpos_t_defined : u32 = 1 ; pub const ____mbstate_t_defined : u32 = 1 ; pub const _____fpos64_t_defined : u32 = 1 ; pub const ____FILE_defined : u32 = 1 ; pub const __FILE_defined : u32 = 1 ; pub const __struct_FILE_defined : u32 = 1 ; pub const _IO_EOF_SEEN : u32 = 16 ; pub const _IO_ERR_SEEN : u32 = 32 ; pub const _IO_USER_LOCK : u32 = 32768 ; pub const _IOFBF : u32 = 0 ; pub const _IOLBF : u32 = 1 ; pub const _IONBF : u32 = 2 ; pub const BUFSIZ : u32 = 8192 ; pub const EOF : i32 = - 1 ; pub const P_tmpdir : & [u8 ; 5usize] = b\"/tmp\\0\" ; pub const _BITS_STDIO_LIM_H : u32 = 1 ; pub const L_tmpnam : u32 = 20 ; pub const TMP_MAX : u32 = 238328 ; pub const FILENAME_MAX : u32 = 4096 ; pub const L_ctermid : u32 = 9 ; pub const FOPEN_MAX : u32 = 16 ; pub const __HAVE_FLOAT128 : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT128 : u32 = 0 ; pub const __HAVE_FLOAT64X : u32 = 1 ; pub const __HAVE_FLOAT64X_LONG_DOUBLE : u32 = 1 ; pub const __HAVE_FLOAT16 : u32 = 0 ; pub const __HAVE_FLOAT32 : u32 = 1 ; pub const __HAVE_FLOAT64 : u32 = 1 ; pub const __HAVE_FLOAT32X : u32 = 1 ; pub const __HAVE_FLOAT128X : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT16 : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT32 : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT64 : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT32X : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT64X : u32 = 0 ; pub const __HAVE_DISTINCT_FLOAT128X : u32 = 0 ; pub const __HAVE_FLOATN_NOT_TYPEDEF : u32 = 0 ; pub type __u_char = :: core :: ffi :: c_uchar ; pub type __u_short = :: core :: ffi :: c_ushort ; pub type __u_int = :: core :: ffi :: c_uint ; pub type __u_long = :: core :: ffi :: c_ulong ; pub type __int8_t = :: core :: ffi :: c_schar ; pub type __uint8_t = :: core :: ffi :: c_uchar ; pub type __int16_t = :: core :: ffi :: c_short ; pub type __uint16_t = :: core :: ffi :: c_ushort ; pub type __int32_t = :: core :: ffi :: c_int ; pub type __uint32_t = :: core :: ffi :: c_uint ; pub type __int64_t = :: core :: ffi :: c_long ; pub type __uint64_t = :: core :: ffi :: c_ulong ; pub type __int_least8_t = __int8_t ; pub type __uint_least8_t = __uint8_t ; pub type __int_least16_t = __int16_t ; pub type __uint_least16_t = __uint16_t ; pub type __int_least32_t = __int32_t ; pub type __uint_least32_t = __uint32_t ; pub type __int_least64_t = __int64_t ; pub type __uint_least64_t = __uint64_t ; pub type __quad_t = :: core :: ffi :: c_long ; pub type __u_quad_t = :: core :: ffi :: c_ulong ; pub type __intmax_t = :: core :: ffi :: c_long ; pub type __uintmax_t = :: core :: ffi :: c_ulong ; pub type __dev_t = :: core :: ffi :: c_ulong ; pub type __uid_t = :: core :: ffi :: c_uint ; pub type __gid_t = :: core :: ffi :: c_uint ; pub type __ino_t = :: core :: ffi :: c_ulong ; pub type __ino64_t = :: core :: ffi :: c_ulong ; pub type __mode_t = :: core :: ffi :: c_uint ; pub type __nlink_t = :: core :: ffi :: c_ulong ; pub type __off_t = :: core :: ffi :: c_long ; pub type __off64_t = :: core :: ffi :: c_long ; pub type __pid_t = :: core :: ffi :: c_int ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __fsid_t { pub __val : [:: core :: ffi :: c_int ; 2usize] , } pub type __clock_t = :: core :: ffi :: c_long ; pub type __rlim_t = :: core :: ffi :: c_ulong ; pub type __rlim64_t = :: core :: ffi :: c_ulong ; pub type __id_t = :: core :: ffi :: c_uint ; pub type __time_t = :: core :: ffi :: c_long ; pub type __useconds_t = :: core :: ffi :: c_uint ; pub type __suseconds_t = :: core :: ffi :: c_long ; pub type __suseconds64_t = :: core :: ffi :: c_long ; pub type __daddr_t = :: core :: ffi :: c_int ; pub type __key_t = :: core :: ffi :: c_int ; pub type __clockid_t = :: core :: ffi :: c_int ; pub type __timer_t = * mut :: core :: ffi :: c_void ; pub type __blksize_t = :: core :: ffi :: c_long ; pub type __blkcnt_t = :: core :: ffi :: c_long ; pub type __blkcnt64_t = :: core :: ffi :: c_long ; pub type __fsblkcnt_t = :: core :: ffi :: c_ulong ; pub type __fsblkcnt64_t = :: core :: ffi :: c_ulong ; pub type __fsfilcnt_t = :: core :: ffi :: c_ulong ; pub type __fsfilcnt64_t = :: core :: ffi :: c_ulong ; pub type __fsword_t = :: core :: ffi :: c_long ; pub type __ssize_t = :: core :: ffi :: c_long ; pub type __syscall_slong_t = :: core :: ffi :: c_long ; pub type __syscall_ulong_t = :: core :: ffi :: c_ulong ; pub type __loff_t = __off64_t ; pub type __caddr_t = * mut :: core :: ffi :: c_char ; pub type __intptr_t = :: core :: ffi :: c_long ; pub type __socklen_t = :: core :: ffi :: c_uint ; pub type __sig_atomic_t = :: core :: ffi :: c_int ; pub type int_least8_t = __int_least8_t ; pub type int_least16_t = __int_least16_t ; pub type int_least32_t = __int_least32_t ; pub type int_least64_t = __int_least64_t ; pub type uint_least8_t = __uint_least8_t ; pub type uint_least16_t = __uint_least16_t ; pub type uint_least32_t = __uint_least32_t ; pub type uint_least64_t = __uint_least64_t ; pub type int_fast8_t = :: core :: ffi :: c_schar ; pub type int_fast16_t = :: core :: ffi :: c_long ; pub type int_fast32_t = :: core :: ffi :: c_long ; pub type int_fast64_t = :: core :: ffi :: c_long ; pub type uint_fast8_t = :: core :: ffi :: c_uchar ; pub type uint_fast16_t = :: core :: ffi :: c_ulong ; pub type uint_fast32_t = :: core :: ffi :: c_ulong ; pub type uint_fast64_t = :: core :: ffi :: c_ulong ; pub type intmax_t = __intmax_t ; pub type uintmax_t = __uintmax_t ; pub type wchar_t = :: core :: ffi :: c_int ; # [repr (C)] # [repr (align (16))] # [derive (Debug , Copy , Clone)] pub struct max_align_t { pub __clang_max_align_nonce1 : :: core :: ffi :: c_longlong , pub __bindgen_padding_0 : u64 , pub __clang_max_align_nonce2 : u128 , } # [doc = \"@brief   Single block descriptor\"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_block { # [doc = \"@brief   Logical block ID\"] pub lb_id : u64 , # [doc = \"@brief   Buffer\"] pub buf : * mut ext4_buf , # [doc = \"@brief   Data buffer.\"] pub data : * mut u8 , } # [doc = \"@brief   Single block descriptor\"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_buf { # [doc = \"@brief   Flags\"] pub flags : :: core :: ffi :: c_int , # [doc = \"@brief   Logical block address\"] pub lba : u64 , # [doc = \"@brief   Data buffer.\"] pub data : * mut u8 , # [doc = \"@brief   LRU priority. (unused)\"] pub lru_prio : u32 , # [doc = \"@brief   LRU id.\"] pub lru_id : u32 , # [doc = \"@brief   Reference count table\"] pub refctr : u32 , # [doc = \"@brief   The block cache this buffer belongs to.\"] pub bc : * mut ext4_bcache , # [doc = \"@brief   Whether or not buffer is on dirty list.\"] pub on_dirty_list : bool , # [doc = \"@brief   LBA tree node\"] pub lba_node : ext4_buf__bindgen_ty_1 , # [doc = \"@brief   LRU tree node\"] pub lru_node : ext4_buf__bindgen_ty_2 , # [doc = \"@brief   Dirty list node\"] pub dirty_node : ext4_buf__bindgen_ty_3 , # [doc = \"@brief   Callback routine after a disk-write operation.\\n @param   bc block cache descriptor\\n @param   buf buffer descriptor\\n @param   standard error code returned by bdev->bwrite()\\n @param   arg argument passed to this routine\"] pub end_write : :: core :: option :: Option < unsafe extern \"C\" fn (bc : * mut ext4_bcache , buf : * mut ext4_buf , res : :: core :: ffi :: c_int , arg : * mut :: core :: ffi :: c_void) > , # [doc = \"@brief   argument passed to end_write() callback.\"] pub end_write_arg : * mut :: core :: ffi :: c_void , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_buf__bindgen_ty_1 { pub rbe_left : * mut ext4_buf , pub rbe_right : * mut ext4_buf , pub rbe_parent : * mut ext4_buf , pub rbe_color : :: core :: ffi :: c_int , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_buf__bindgen_ty_2 { pub rbe_left : * mut ext4_buf , pub rbe_right : * mut ext4_buf , pub rbe_parent : * mut ext4_buf , pub rbe_color : :: core :: ffi :: c_int , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_buf__bindgen_ty_3 { pub sle_next : * mut ext4_buf , } # [doc = \"@brief   Block cache descriptor\"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_bcache { # [doc = \"@brief   Item count in block cache\"] pub cnt : u32 , # [doc = \"@brief   Item size in block cache\"] pub itemsize : u32 , # [doc = \"@brief   Last recently used counter\"] pub lru_ctr : u32 , # [doc = \"@brief   Currently referenced datablocks\"] pub ref_blocks : u32 , # [doc = \"@brief   Maximum referenced datablocks\"] pub max_ref_blocks : u32 , # [doc = \"@brief   The blockdev binded to this block cache\"] pub bdev : * mut ext4_blockdev , # [doc = \"@brief   The cache should not be shaked\"] pub dont_shake : bool , # [doc = \"@brief   A tree holding all bufs\"] pub lba_root : ext4_bcache_ext4_buf_lba , # [doc = \"@brief   A tree holding unreferenced bufs\"] pub lru_root : ext4_bcache_ext4_buf_lru , # [doc = \"@brief   A singly-linked list holding dirty buffers\"] pub dirty_list : ext4_bcache_ext4_buf_dirty , } # [doc = \"@brief   A tree holding all bufs\"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_bcache_ext4_buf_lba { pub rbh_root : * mut ext4_buf , } # [doc = \"@brief   A tree holding unreferenced bufs\"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_bcache_ext4_buf_lru { pub rbh_root : * mut ext4_buf , } # [doc = \"@brief   A singly-linked list holding dirty buffers\"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_bcache_ext4_buf_dirty { pub slh_first : * mut ext4_buf , } pub const bcache_state_bits_BC_UPTODATE : bcache_state_bits = 0 ; pub const bcache_state_bits_BC_DIRTY : bcache_state_bits = 1 ; pub const bcache_state_bits_BC_FLUSH : bcache_state_bits = 2 ; pub const bcache_state_bits_BC_TMP : bcache_state_bits = 3 ; # [doc = \"@brief buffer state bits\\n\\n  - BC♡UPTODATE: Buffer contains valid data.\\n  - BC_DIRTY: Buffer is dirty.\\n  - BC_FLUSH: Buffer will be immediately flushed,\\n              when no one references it.\\n  - BC_TMP: Buffer will be dropped once its refctr\\n            reaches zero.\"] pub type bcache_state_bits = :: core :: ffi :: c_uint ; extern \"C\" { # [doc = \"@brief   Dynamic initialization of block cache.\\n @param   bc block cache descriptor\\n @param   cnt items count in block cache\\n @param   itemsize single item size (in bytes)\\n @return  standard error code\"] pub fn ext4_bcache_init_dynamic (bc : * mut ext4_bcache , cnt : u32 , itemsize : u32) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Do cleanup works on block cache.\\n @param   bc block cache descriptor.\"] pub fn ext4_bcache_cleanup (bc : * mut ext4_bcache) ; } extern \"C\" { # [doc = \"@brief   Dynamic de-initialization of block cache.\\n @param   bc block cache descriptor\\n @return  standard error code\"] pub fn ext4_bcache_fini_dynamic (bc : * mut ext4_bcache) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Get a buffer with the lowest LRU counter in bcache.\\n @param   bc block cache descriptor\\n @return  buffer with the lowest LRU counter\"] pub fn ext4_buf_lowest_lru (bc : * mut ext4_bcache) -> * mut ext4_buf ; } extern \"C\" { # [doc = \"@brief   Drop unreferenced buffer from bcache.\\n @param   bc block cache descriptor\\n @param   buf buffer\"] pub fn ext4_bcache_drop_buf (bc : * mut ext4_bcache , buf : * mut ext4_buf) ; } extern \"C\" { # [doc = \"@brief   Invalidate a buffer.\\n @param   bc block cache descriptor\\n @param   buf buffer\"] pub fn ext4_bcache_invalidate_buf (bc : * mut ext4_bcache , buf : * mut ext4_buf) ; } extern \"C\" { # [doc = \"@brief   Invalidate a range of buffers.\\n @param   bc block cache descriptor\\n @param   from starting lba\\n @param   cnt block counts\"] pub fn ext4_bcache_invalidate_lba (bc : * mut ext4_bcache , from : u64 , cnt : u32) ; } extern \"C\" { # [doc = \"@brief   Find existing buffer from block cache memory.\\n          Unreferenced block allocation is based on LRU\\n          (Last Recently Used) algorithm.\\n @param   bc block cache descriptor\\n @param   b block to alloc\\n @param   lba logical block address\\n @return  block cache buffer\"] pub fn ext4_bcache_find_get (bc : * mut ext4_bcache , b : * mut ext4_block , lba : u64) -> * mut ext4_buf ; } extern \"C\" { # [doc = \"@brief   Allocate block from block cache memory.\\n          Unreferenced block allocation is based on LRU\\n          (Last Recently Used) algorithm.\\n @param   bc block cache descriptor\\n @param   b block to alloc\\n @param   is_new block is new (needs to be read)\\n @return  standard error code\"] pub fn ext4_bcache_alloc (bc : * mut ext4_bcache , b : * mut ext4_block , is_new : * mut bool) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Free block from cache memory (decrement reference counter).\\n @param   bc block cache descriptor\\n @param   b block to free\\n @return  standard error code\"] pub fn ext4_bcache_free (bc : * mut ext4_bcache , b : * mut ext4_block) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Return a full status of block cache.\\n @param   bc block cache descriptor\\n @return  full status\"] pub fn ext4_bcache_is_full (bc : * mut ext4_bcache) -> bool ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_blockdev_iface { # [doc = \"@brief   Open device function\\n @param   bdev block device.\"] pub open : :: core :: option :: Option < unsafe extern \"C\" fn (bdev : * mut ext4_blockdev) -> :: core :: ffi :: c_int > , # [doc = \"@brief   Block read function.\\n @param   bdev block device\\n @param   buf output buffer\\n @param   blk_id block id\\n @param   blk_cnt block count\"] pub bread : :: core :: option :: Option < unsafe extern \"C\" fn (bdev : * mut ext4_blockdev , buf : * mut :: core :: ffi :: c_void , blk_id : u64 , blk_cnt : u32) -> :: core :: ffi :: c_int > , # [doc = \"@brief   Block write function.\\n @param   buf input buffer\\n @param   blk_id block id\\n @param   blk_cnt block count\"] pub bwrite : :: core :: option :: Option < unsafe extern \"C\" fn (bdev : * mut ext4_blockdev , buf : * const :: core :: ffi :: c_void , blk_id : u64 , blk_cnt : u32) -> :: core :: ffi :: c_int > , # [doc = \"@brief   Close device function.\\n @param   bdev block device.\"] pub close : :: core :: option :: Option < unsafe extern \"C\" fn (bdev : * mut ext4_blockdev) -> :: core :: ffi :: c_int > , # [doc = \"@brief   Lock block device. Required in multi partition mode\\n          operations. Not mandatory field.\\n @param   bdev block device.\"] pub lock : :: core :: option :: Option < unsafe extern \"C\" fn (bdev : * mut ext4_blockdev) -> :: core :: ffi :: c_int > , # [doc = \"@brief   Unlock block device. Required in multi partition mode\\n          operations. Not mandatory field.\\n @param   bdev block device.\"] pub unlock : :: core :: option :: Option < unsafe extern \"C\" fn (bdev : * mut ext4_blockdev) -> :: core :: ffi :: c_int > , # [doc = \"@brief   Block size (bytes): physical\"] pub ph_bsize : u32 , # [doc = \"@brief   Block count: physical\"] pub ph_bcnt : u64 , # [doc = \"@brief   Block size buffer: physical\"] pub ph_bbuf : * mut u8 , # [doc = \"@brief   Reference counter to block device interface\"] pub ph_refctr : u32 , # [doc = \"@brief   Physical read counter\"] pub bread_ctr : u32 , # [doc = \"@brief   Physical write counter\"] pub bwrite_ctr : u32 , # [doc = \"@brief   User data pointer\"] pub p_user : * mut :: core :: ffi :: c_void , } # [doc = \"@brief   Definition of the simple block device.\"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_blockdev { # [doc = \"@brief Block device interface\"] pub bdif : * mut ext4_blockdev_iface , # [doc = \"@brief Offset in bdif. For multi partition mode.\"] pub part_offset : u64 , # [doc = \"@brief Part size in bdif. For multi partition mode.\"] pub part_size : u64 , # [doc = \"@brief   Block cache.\"] pub bc : * mut ext4_bcache , # [doc = \"@brief   Block size (bytes) logical\"] pub lg_bsize : u32 , # [doc = \"@brief   Block count: logical\"] pub lg_bcnt : u64 , # [doc = \"@brief   Cache write back mode reference counter\"] pub cache_write_back : u32 , # [doc = \"@brief   The filesystem this block device belongs to.\"] pub fs : * mut ext4_fs , pub journal : * mut :: core :: ffi :: c_void , } extern \"C\" { # [doc = \"@brief   Block device initialization.\\n @param   bdev block device descriptor\\n @return  standard error code\"] pub fn ext4_block_init (bdev : * mut ext4_blockdev) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Binds a bcache to block device.\\n @param   bdev block device descriptor\\n @param   bc block cache descriptor\\n @return  standard error code\"] pub fn ext4_block_bind_bcache (bdev : * mut ext4_blockdev , bc : * mut ext4_bcache) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Close block device\\n @param   bdev block device descriptor\\n @return  standard error code\"] pub fn ext4_block_fini (bdev : * mut ext4_blockdev) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Flush data in given buffer to disk.\\n @param   bdev block device descriptor\\n @param   buf buffer\\n @return  standard error code\"] pub fn ext4_block_flush_buf (bdev : * mut ext4_blockdev , buf : * mut ext4_buf) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Flush data in buffer of given lba to disk,\\n          if that buffer exists in block cache.\\n @param   bdev block device descriptor\\n @param   lba logical block address\\n @return  standard error code\"] pub fn ext4_block_flush_lba (bdev : * mut ext4_blockdev , lba : u64) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Set logical block size in block device.\\n @param   bdev block device descriptor\\n @param   lb_bsize logical block size (in bytes)\"] pub fn ext4_block_set_lb_size (bdev : * mut ext4_blockdev , lb_bsize : u32) ; } extern \"C\" { # [doc = \"@brief   Block get function (through cache, don't read).\\n @param   bdev block device descriptor\\n @param   b block descriptor\\n @param   lba logical block address\\n @return  standard error code\"] pub fn ext4_block_get_noread (bdev : * mut ext4_blockdev , b : * mut ext4_block , lba : u64) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Block get function (through cache).\\n @param   bdev block device descriptor\\n @param   b block descriptor\\n @param   lba logical block address\\n @return  standard error code\"] pub fn ext4_block_get (bdev : * mut ext4_blockdev , b : * mut ext4_block , lba : u64) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Block set procedure (through cache).\\n @param   bdev block device descriptor\\n @param   b block descriptor\\n @return  standard error code\"] pub fn ext4_block_set (bdev : * mut ext4_blockdev , b : * mut ext4_block) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Block read procedure (without cache)\\n @param   bdev block device descriptor\\n @param   buf output buffer\\n @param   lba logical block address\\n @return  standard error code\"] pub fn ext4_blocks_get_direct (bdev : * mut ext4_blockdev , buf : * mut :: core :: ffi :: c_void , lba : u64 , cnt : u32) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Block write procedure (without cache)\\n @param   bdev block device descriptor\\n @param   buf output buffer\\n @param   lba logical block address\\n @return  standard error code\"] pub fn ext4_blocks_set_direct (bdev : * mut ext4_blockdev , buf : * const :: core :: ffi :: c_void , lba : u64 , cnt : u32) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Write to block device (by direct address).\\n @param   bdev block device descriptor\\n @param   off byte offset in block device\\n @param   buf input buffer\\n @param   len length of the write buffer\\n @return  standard error code\"] pub fn ext4_block_writebytes (bdev : * mut ext4_blockdev , off : u64 , buf : * const :: core :: ffi :: c_void , len : u32) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Read freom block device (by direct address).\\n @param   bdev block device descriptor\\n @param   off byte offset in block device\\n @param   buf input buffer\\n @param   len length of the write buffer\\n @return  standard error code\"] pub fn ext4_block_readbytes (bdev : * mut ext4_blockdev , off : u64 , buf : * mut :: core :: ffi :: c_void , len : u32) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Flush all dirty buffers to disk\\n @param   bdev block device descriptor\\n @return  standard error code\"] pub fn ext4_block_cache_flush (bdev : * mut ext4_blockdev) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Enable/disable write back cache mode\\n @param   bdev block device descriptor\\n @param   on_off\\n              !0 - ENABLE\\n               0 - DISABLE (all delayed cache buffers will be flushed)\\n @return  standard error code\"] pub fn ext4_block_cache_write_back (bdev : * mut ext4_blockdev , on_off : u8) -> :: core :: ffi :: c_int ; } pub type ext4_lblk_t = u32 ; pub type ext4_fsblk_t = u64 ; # [repr (C , packed)] # [derive (Debug , Copy , Clone)] pub struct ext4_sblock { pub inodes_count : u32 , pub blocks_count_lo : u32 , pub reserved_blocks_count_lo : u32 , pub free_blocks_count_lo : u32 , pub free_inodes_count : u32 , pub first_data_block : u32 , pub log_block_size : u32 , pub log_cluster_size : u32 , pub blocks_per_group : u32 , pub frags_per_group : u32 , pub inodes_per_group : u32 , pub mount_time : u32 , pub write_time : u32 , pub mount_count : u16 , pub max_mount_count : u16 , pub magic : u16 , pub state : u16 , pub errors : u16 , pub minor_rev_level : u16 , pub last_check_time : u32 , pub check_interval : u32 , pub creator_os : u32 , pub rev_level : u32 , pub def_resuid : u16 , pub def_resgid : u16 , pub first_inode : u32 , pub inode_size : u16 , pub block_group_index : u16 , pub features_compatible : u32 , pub features_incompatible : u32 , pub features_read_only : u32 , pub uuid : [u8 ; 16usize] , pub volume_name : [:: core :: ffi :: c_char ; 16usize] , pub last_mounted : [:: core :: ffi :: c_char ; 64usize] , pub algorithm_usage_bitmap : u32 , pub s_prealloc_blocks : u8 , pub s_prealloc_dir_blocks : u8 , pub s_reserved_gdt_blocks : u16 , pub journal_uuid : [u8 ; 16usize] , pub journal_inode_number : u32 , pub journal_dev : u32 , pub last_orphan : u32 , pub hash_seed : [u32 ; 4usize] , pub default_hash_version : u8 , pub journal_backup_type : u8 , pub desc_size : u16 , pub default_mount_opts : u32 , pub first_meta_bg : u32 , pub mkfs_time : u32 , pub journal_blocks : [u32 ; 17usize] , pub blocks_count_hi : u32 , pub reserved_blocks_count_hi : u32 , pub free_blocks_count_hi : u32 , pub min_extra_isize : u16 , pub want_extra_isize : u16 , pub flags : u32 , pub raid_stride : u16 , pub mmp_interval : u16 , pub mmp_block : u64 , pub raid_stripe_width : u32 , pub log_groups_per_flex : u8 , pub checksum_type : u8 , pub reserved_pad : u16 , pub kbytes_written : u64 , pub snapshot_inum : u32 , pub snapshot_id : u32 , pub snapshot_r_blocks_count : u64 , pub snapshot_list : u32 , pub error_count : u32 , pub first_error_time : u32 , pub first_error_ino : u32 , pub first_error_block : u64 , pub first_error_func : [u8 ; 32usize] , pub first_error_line : u32 , pub last_error_time : u32 , pub last_error_ino : u32 , pub last_error_line : u32 , pub last_error_block : u64 , pub last_error_func : [u8 ; 32usize] , pub mount_opts : [u8 ; 64usize] , pub usr_quota_inum : u32 , pub grp_quota_inum : u32 , pub overhead_clusters : u32 , pub backup_bgs : [u32 ; 2usize] , pub encrypt_algos : [u8 ; 4usize] , pub encrypt_pw_salt : [u8 ; 16usize] , pub lpf_ino : u32 , pub padding : [u32 ; 100usize] , pub checksum : u32 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_bgroup { pub block_bitmap_lo : u32 , pub inode_bitmap_lo : u32 , pub inode_table_first_block_lo : u32 , pub free_blocks_count_lo : u16 , pub free_inodes_count_lo : u16 , pub used_dirs_count_lo : u16 , pub flags : u16 , pub exclude_bitmap_lo : u32 , pub block_bitmap_csum_lo : u16 , pub inode_bitmap_csum_lo : u16 , pub itable_unused_lo : u16 , pub checksum : u16 , pub block_bitmap_hi : u32 , pub inode_bitmap_hi : u32 , pub inode_table_first_block_hi : u32 , pub free_blocks_count_hi : u16 , pub free_inodes_count_hi : u16 , pub used_dirs_count_hi : u16 , pub itable_unused_hi : u16 , pub exclude_bitmap_hi : u32 , pub block_bitmap_csum_hi : u16 , pub inode_bitmap_csum_hi : u16 , pub reserved : u32 , } # [repr (C , packed)] # [derive (Copy , Clone)] pub struct ext4_inode { pub mode : u16 , pub uid : u16 , pub size_lo : u32 , pub access_time : u32 , pub change_inode_time : u32 , pub modification_time : u32 , pub deletion_time : u32 , pub gid : u16 , pub links_count : u16 , pub blocks_count_lo : u32 , pub flags : u32 , pub unused_osd1 : u32 , pub blocks : [u32 ; 15usize] , pub generation : u32 , pub file_acl_lo : u32 , pub size_hi : u32 , pub obso_faddr : u32 , pub osd2 : ext4_inode__bindgen_ty_1 , pub extra_isize : u16 , pub checksum_hi : u16 , pub ctime_extra : u32 , pub mtime_extra : u32 , pub atime_extra : u32 , pub crtime : u32 , pub crtime_extra : u32 , pub version_hi : u32 , } # [repr (C)] # [derive (Copy , Clone)] pub union ext4_inode__bindgen_ty_1 { pub linux2 : ext4_inode__bindgen_ty_1__bindgen_ty_1 , pub hurd2 : ext4_inode__bindgen_ty_1__bindgen_ty_2 , } # [repr (C , packed)] # [derive (Debug , Copy , Clone)] pub struct ext4_inode__bindgen_ty_1__bindgen_ty_1 { pub blocks_high : u16 , pub file_acl_high : u16 , pub uid_high : u16 , pub gid_high : u16 , pub checksum_lo : u16 , pub reserved2 : u16 , } # [repr (C , packed)] # [derive (Debug , Copy , Clone)] pub struct ext4_inode__bindgen_ty_1__bindgen_ty_2 { pub reserved1 : u16 , pub mode_high : u16 , pub uid_high : u16 , pub gid_high : u16 , pub author : u32 , } pub const EXT4_DE_UNKNOWN : _bindgen_ty_1 = 0 ; pub const EXT4_DE_REG_FILE : _bindgen_ty_1 = 1 ; pub const EXT4_DE_DIR : _bindgen_ty_1 = 2 ; pub const EXT4_DE_CHRDEV : _bindgen_ty_1 = 3 ; pub const EXT4_DE_BLKDEV : _bindgen_ty_1 = 4 ; pub const EXT4_DE_FIFO : _bindgen_ty_1 = 5 ; pub const EXT4_DE_SOCK : _bindgen_ty_1 = 6 ; pub const EXT4_DE_SYMLINK : _bindgen_ty_1 = 7 ; # [doc = \"@brief   Directory entry types.\"] pub type _bindgen_ty_1 = :: core :: ffi :: c_uint ; # [repr (C)] # [derive (Copy , Clone)] pub union ext4_dir_en_internal { pub name_length_high : u8 , pub inode_type : u8 , } # [doc = \" Linked list directory entry structure\"] # [repr (C , packed)] pub struct ext4_dir_en { pub inode : u32 , pub entry_len : u16 , pub name_len : u8 , pub in_ : ext4_dir_en_internal , pub name : __IncompleteArrayField < u8 > , } # [repr (C , packed)] # [derive (Debug , Copy , Clone)] pub struct ext4_dir_idx_climit { pub limit : u16 , pub count : u16 , } # [repr (C , packed)] # [derive (Debug , Copy , Clone)] pub struct ext4_dir_idx_dot_en { pub inode : u32 , pub entry_length : u16 , pub name_length : u8 , pub inode_type : u8 , pub name : [u8 ; 4usize] , } # [repr (C , packed)] # [derive (Debug , Copy , Clone)] pub struct ext4_dir_idx_rinfo { pub reserved_zero : u32 , pub hash_version : u8 , pub info_length : u8 , pub indirect_levels : u8 , pub unused_flags : u8 , } # [repr (C , packed)] # [derive (Debug , Copy , Clone)] pub struct ext4_dir_idx_entry { pub hash : u32 , pub block : u32 , } # [repr (C)] # [derive (Debug)] pub struct ext4_dir_idx_root { pub dots : [ext4_dir_idx_dot_en ; 2usize] , pub info : ext4_dir_idx_rinfo , pub en : __IncompleteArrayField < ext4_dir_idx_entry > , } # [repr (C , packed)] # [derive (Debug , Copy , Clone)] pub struct ext4_fake_dir_entry { pub inode : u32 , pub entry_length : u16 , pub name_length : u8 , pub inode_type : u8 , } # [repr (C)] # [derive (Debug)] pub struct ext4_dir_idx_node { pub fake : ext4_fake_dir_entry , pub entries : __IncompleteArrayField < ext4_dir_idx_entry > , } # [repr (C , packed)] # [derive (Debug , Copy , Clone)] pub struct ext4_dir_idx_tail { pub reserved : u32 , pub checksum : u32 , } # [repr (C , packed)] # [derive (Debug , Copy , Clone)] pub struct ext4_dir_entry_tail { pub reserved_zero1 : u32 , pub rec_len : u16 , pub reserved_zero2 : u8 , pub reserved_ft : u8 , pub checksum : u32 , } # [repr (C , packed)] # [derive (Debug , Copy , Clone)] pub struct jbd_bhdr { pub magic : u32 , pub blocktype : u32 , pub sequence : u32 , } # [repr (C , packed)] # [derive (Debug , Copy , Clone)] pub struct jbd_commit_header { pub header : jbd_bhdr , pub chksum_type : u8 , pub chksum_size : u8 , pub padding : [u8 ; 2usize] , pub chksum : [u32 ; 8usize] , pub commit_sec : u64 , pub commit_nsec : u32 , } # [repr (C , packed)] # [derive (Debug , Copy , Clone)] pub struct jbd_block_tag3 { pub blocknr : u32 , pub flags : u32 , pub blocknr_high : u32 , pub checksum : u32 , } # [repr (C , packed)] # [derive (Debug , Copy , Clone)] pub struct jbd_block_tag { pub blocknr : u32 , pub checksum : u16 , pub flags : u16 , pub blocknr_high : u32 , } # [repr (C , packed)] # [derive (Debug , Copy , Clone)] pub struct jbd_block_tail { pub checksum : u32 , } # [repr (C , packed)] # [derive (Debug , Copy , Clone)] pub struct jbd_revoke_header { pub header : jbd_bhdr , pub count : u32 , } # [repr (C , packed)] # [derive (Debug , Copy , Clone)] pub struct jbd_revoke_tail { pub checksum : u32 , } # [repr (C , packed)] # [derive (Debug , Copy , Clone)] pub struct jbd_sb { pub header : jbd_bhdr , pub blocksize : u32 , pub maxlen : u32 , pub first : u32 , pub sequence : u32 , pub start : u32 , pub error_val : i32 , pub feature_compat : u32 , pub feature_incompat : u32 , pub feature_ro_compat : u32 , pub uuid : [u8 ; 16usize] , pub nr_users : u32 , pub dynsuper : u32 , pub max_transaction : u32 , pub max_trandata : u32 , pub checksum_type : u8 , pub padding2 : [u8 ; 3usize] , pub padding : [u32 ; 42usize] , pub checksum : u32 , pub users : [u8 ; 768usize] , } pub type __gwchar_t = :: core :: ffi :: c_int ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct imaxdiv_t { pub quot : :: core :: ffi :: c_long , pub rem : :: core :: ffi :: c_long , } extern \"C\" { pub fn imaxabs (__n : intmax_t) -> intmax_t ; } extern \"C\" { pub fn imaxdiv (__numer : intmax_t , __denom : intmax_t) -> imaxdiv_t ; } extern \"C\" { pub fn strtoimax (__nptr : * const :: core :: ffi :: c_char , __endptr : * mut * mut :: core :: ffi :: c_char , __base : :: core :: ffi :: c_int) -> intmax_t ; } extern \"C\" { pub fn strtoumax (__nptr : * const :: core :: ffi :: c_char , __endptr : * mut * mut :: core :: ffi :: c_char , __base : :: core :: ffi :: c_int) -> uintmax_t ; } extern \"C\" { pub fn wcstoimax (__nptr : * const __gwchar_t , __endptr : * mut * mut __gwchar_t , __base : :: core :: ffi :: c_int) -> intmax_t ; } extern \"C\" { pub fn wcstoumax (__nptr : * const __gwchar_t , __endptr : * mut * mut __gwchar_t , __base : :: core :: ffi :: c_int) -> uintmax_t ; } extern \"C\" { # [doc = \"@brief   Global mask debug set.\\n @param   m new debug mask.\"] pub fn ext4_dmask_set (m : u32) ; } extern \"C\" { # [doc = \"@brief   Global mask debug clear.\\n @param   m new debug mask.\"] pub fn ext4_dmask_clr (m : u32) ; } extern \"C\" { # [doc = \"@brief   Global debug mask get.\\n @return  debug mask\"] pub fn ext4_dmask_get () -> u32 ; } pub type va_list = __builtin_va_list ; pub type __gnuc_va_list = __builtin_va_list ; # [repr (C)] # [derive (Copy , Clone)] pub struct __mbstate_t { pub __count : :: core :: ffi :: c_int , pub __value : __mbstate_t__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] pub union __mbstate_t__bindgen_ty_1 { pub __wch : :: core :: ffi :: c_uint , pub __wchb : [:: core :: ffi :: c_char ; 4usize] , } # [repr (C)] # [derive (Copy , Clone)] pub struct _G_fpos_t { pub __pos : __off_t , pub __state : __mbstate_t , } pub type __fpos_t = _G_fpos_t ; # [repr (C)] # [derive (Copy , Clone)] pub struct _G_fpos64_t { pub __pos : __off64_t , pub __state : __mbstate_t , } pub type __fpos64_t = _G_fpos64_t ; pub type __FILE = _IO_FILE ; pub type FILE = _IO_FILE ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _IO_marker { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _IO_codecvt { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _IO_wide_data { _unused : [u8 ; 0] , } pub type _IO_lock_t = :: core :: ffi :: c_void ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _IO_FILE { pub _flags : :: core :: ffi :: c_int , pub _IO_read_ptr : * mut :: core :: ffi :: c_char , pub _IO_read_end : * mut :: core :: ffi :: c_char , pub _IO_read_base : * mut :: core :: ffi :: c_char , pub _IO_write_base : * mut :: core :: ffi :: c_char , pub _IO_write_ptr : * mut :: core :: ffi :: c_char , pub _IO_write_end : * mut :: core :: ffi :: c_char , pub _IO_buf_base : * mut :: core :: ffi :: c_char , pub _IO_buf_end : * mut :: core :: ffi :: c_char , pub _IO_save_base : * mut :: core :: ffi :: c_char , pub _IO_backup_base : * mut :: core :: ffi :: c_char , pub _IO_save_end : * mut :: core :: ffi :: c_char , pub _markers : * mut _IO_marker , pub _chain : * mut _IO_FILE , pub _fileno : :: core :: ffi :: c_int , pub _flags2 : :: core :: ffi :: c_int , pub _old_offset : __off_t , pub _cur_column : :: core :: ffi :: c_ushort , pub _vtable_offset : :: core :: ffi :: c_schar , pub _shortbuf : [:: core :: ffi :: c_char ; 1usize] , pub _lock : * mut _IO_lock_t , pub _offset : __off64_t , pub _codecvt : * mut _IO_codecvt , pub _wide_data : * mut _IO_wide_data , pub _freeres_list : * mut _IO_FILE , pub _freeres_buf : * mut :: core :: ffi :: c_void , pub __pad5 : usize , pub _mode : :: core :: ffi :: c_int , pub _unused2 : [:: core :: ffi :: c_char ; 20usize] , } pub type off_t = __off_t ; pub type fpos_t = __fpos_t ; extern \"C\" { pub static mut stdin : * mut FILE ; } extern \"C\" { pub static mut stdout : * mut FILE ; } extern \"C\" { pub static mut stderr : * mut FILE ; } extern \"C\" { pub fn remove (__filename : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn rename (__old : * const :: core :: ffi :: c_char , __new : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn renameat (__oldfd : :: core :: ffi :: c_int , __old : * const :: core :: ffi :: c_char , __newfd : :: core :: ffi :: c_int , __new : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn fclose (__stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn tmpfile () -> * mut FILE ; } extern \"C\" { pub fn tmpnam (arg1 : * mut :: core :: ffi :: c_char) -> * mut :: core :: ffi :: c_char ; } extern \"C\" { pub fn tmpnam_r (__s : * mut :: core :: ffi :: c_char) -> * mut :: core :: ffi :: c_char ; } extern \"C\" { pub fn tempnam (__dir : * const :: core :: ffi :: c_char , __pfx : * const :: core :: ffi :: c_char) -> * mut :: core :: ffi :: c_char ; } extern \"C\" { pub fn fflush (__stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn fflush_unlocked (__stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn fopen (__filename : * const :: core :: ffi :: c_char , __modes : * const :: core :: ffi :: c_char) -> * mut FILE ; } extern \"C\" { pub fn freopen (__filename : * const :: core :: ffi :: c_char , __modes : * const :: core :: ffi :: c_char , __stream : * mut FILE) -> * mut FILE ; } extern \"C\" { pub fn fdopen (__fd : :: core :: ffi :: c_int , __modes : * const :: core :: ffi :: c_char) -> * mut FILE ; } extern \"C\" { pub fn fmemopen (__s : * mut :: core :: ffi :: c_void , __len : usize , __modes : * const :: core :: ffi :: c_char) -> * mut FILE ; } extern \"C\" { pub fn open_memstream (__bufloc : * mut * mut :: core :: ffi :: c_char , __sizeloc : * mut usize) -> * mut FILE ; } extern \"C\" { pub fn setbuf (__stream : * mut FILE , __buf : * mut :: core :: ffi :: c_char) ; } extern \"C\" { pub fn setvbuf (__stream : * mut FILE , __buf : * mut :: core :: ffi :: c_char , __modes : :: core :: ffi :: c_int , __n : usize) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn setbuffer (__stream : * mut FILE , __buf : * mut :: core :: ffi :: c_char , __size : usize) ; } extern \"C\" { pub fn setlinebuf (__stream : * mut FILE) ; } extern \"C\" { pub fn fprintf (__stream : * mut FILE , __format : * const :: core :: ffi :: c_char , ...) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn printf (__format : * const :: core :: ffi :: c_char , ...) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn sprintf (__s : * mut :: core :: ffi :: c_char , __format : * const :: core :: ffi :: c_char , ...) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn vfprintf (__s : * mut FILE , __format : * const :: core :: ffi :: c_char , __arg : * mut __va_list_tag) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn vprintf (__format : * const :: core :: ffi :: c_char , __arg : * mut __va_list_tag) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn vsprintf (__s : * mut :: core :: ffi :: c_char , __format : * const :: core :: ffi :: c_char , __arg : * mut __va_list_tag) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn snprintf (__s : * mut :: core :: ffi :: c_char , __maxlen : :: core :: ffi :: c_ulong , __format : * const :: core :: ffi :: c_char , ...) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn vsnprintf (__s : * mut :: core :: ffi :: c_char , __maxlen : :: core :: ffi :: c_ulong , __format : * const :: core :: ffi :: c_char , __arg : * mut __va_list_tag) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn vdprintf (__fd : :: core :: ffi :: c_int , __fmt : * const :: core :: ffi :: c_char , __arg : * mut __va_list_tag) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn dprintf (__fd : :: core :: ffi :: c_int , __fmt : * const :: core :: ffi :: c_char , ...) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn fscanf (__stream : * mut FILE , __format : * const :: core :: ffi :: c_char , ...) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn scanf (__format : * const :: core :: ffi :: c_char , ...) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn sscanf (__s : * const :: core :: ffi :: c_char , __format : * const :: core :: ffi :: c_char , ...) -> :: core :: ffi :: c_int ; } pub type _Float32 = f32 ; pub type _Float64 = f64 ; pub type _Float32x = f64 ; pub type _Float64x = u128 ; extern \"C\" { # [link_name = \"\\u{1}__isoc99_fscanf\"] pub fn fscanf1 (__stream : * mut FILE , __format : * const :: core :: ffi :: c_char , ...) -> :: core :: ffi :: c_int ; } extern \"C\" { # [link_name = \"\\u{1}__isoc99_scanf\"] pub fn scanf1 (__format : * const :: core :: ffi :: c_char , ...) -> :: core :: ffi :: c_int ; } extern \"C\" { # [link_name = \"\\u{1}__isoc99_sscanf\"] pub fn sscanf1 (__s : * const :: core :: ffi :: c_char , __format : * const :: core :: ffi :: c_char , ...) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn vfscanf (__s : * mut FILE , __format : * const :: core :: ffi :: c_char , __arg : * mut __va_list_tag) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn vscanf (__format : * const :: core :: ffi :: c_char , __arg : * mut __va_list_tag) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn vsscanf (__s : * const :: core :: ffi :: c_char , __format : * const :: core :: ffi :: c_char , __arg : * mut __va_list_tag) -> :: core :: ffi :: c_int ; } extern \"C\" { # [link_name = \"\\u{1}__isoc99_vfscanf\"] pub fn vfscanf1 (__s : * mut FILE , __format : * const :: core :: ffi :: c_char , __arg : * mut __va_list_tag) -> :: core :: ffi :: c_int ; } extern \"C\" { # [link_name = \"\\u{1}__isoc99_vscanf\"] pub fn vscanf1 (__format : * const :: core :: ffi :: c_char , __arg : * mut __va_list_tag) -> :: core :: ffi :: c_int ; } extern \"C\" { # [link_name = \"\\u{1}__isoc99_vsscanf\"] pub fn vsscanf1 (__s : * const :: core :: ffi :: c_char , __format : * const :: core :: ffi :: c_char , __arg : * mut __va_list_tag) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn fgetc (__stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn getc (__stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn getchar () -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn getc_unlocked (__stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn getchar_unlocked () -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn fgetc_unlocked (__stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn fputc (__c : :: core :: ffi :: c_int , __stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn putc (__c : :: core :: ffi :: c_int , __stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn putchar (__c : :: core :: ffi :: c_int) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn fputc_unlocked (__c : :: core :: ffi :: c_int , __stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn putc_unlocked (__c : :: core :: ffi :: c_int , __stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn putchar_unlocked (__c : :: core :: ffi :: c_int) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn getw (__stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn putw (__w : :: core :: ffi :: c_int , __stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn fgets (__s : * mut :: core :: ffi :: c_char , __n : :: core :: ffi :: c_int , __stream : * mut FILE) -> * mut :: core :: ffi :: c_char ; } extern \"C\" { pub fn __getdelim (__lineptr : * mut * mut :: core :: ffi :: c_char , __n : * mut usize , __delimiter : :: core :: ffi :: c_int , __stream : * mut FILE) -> __ssize_t ; } extern \"C\" { pub fn getdelim (__lineptr : * mut * mut :: core :: ffi :: c_char , __n : * mut usize , __delimiter : :: core :: ffi :: c_int , __stream : * mut FILE) -> __ssize_t ; } extern \"C\" { pub fn getline (__lineptr : * mut * mut :: core :: ffi :: c_char , __n : * mut usize , __stream : * mut FILE) -> __ssize_t ; } extern \"C\" { pub fn fputs (__s : * const :: core :: ffi :: c_char , __stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn puts (__s : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn ungetc (__c : :: core :: ffi :: c_int , __stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn fread (__ptr : * mut :: core :: ffi :: c_void , __size : :: core :: ffi :: c_ulong , __n : :: core :: ffi :: c_ulong , __stream : * mut FILE) -> :: core :: ffi :: c_ulong ; } extern \"C\" { pub fn fwrite (__ptr : * const :: core :: ffi :: c_void , __size : :: core :: ffi :: c_ulong , __n : :: core :: ffi :: c_ulong , __s : * mut FILE) -> :: core :: ffi :: c_ulong ; } extern \"C\" { pub fn fread_unlocked (__ptr : * mut :: core :: ffi :: c_void , __size : usize , __n : usize , __stream : * mut FILE) -> usize ; } extern \"C\" { pub fn fwrite_unlocked (__ptr : * const :: core :: ffi :: c_void , __size : usize , __n : usize , __stream : * mut FILE) -> usize ; } extern \"C\" { pub fn fseek (__stream : * mut FILE , __off : :: core :: ffi :: c_long , __whence : :: core :: ffi :: c_int) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn ftell (__stream : * mut FILE) -> :: core :: ffi :: c_long ; } extern \"C\" { pub fn rewind (__stream : * mut FILE) ; } extern \"C\" { pub fn fseeko (__stream : * mut FILE , __off : __off_t , __whence : :: core :: ffi :: c_int) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn ftello (__stream : * mut FILE) -> __off_t ; } extern \"C\" { pub fn fgetpos (__stream : * mut FILE , __pos : * mut fpos_t) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn fsetpos (__stream : * mut FILE , __pos : * const fpos_t) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn clearerr (__stream : * mut FILE) ; } extern \"C\" { pub fn feof (__stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn ferror (__stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn clearerr_unlocked (__stream : * mut FILE) ; } extern \"C\" { pub fn feof_unlocked (__stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn ferror_unlocked (__stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn perror (__s : * const :: core :: ffi :: c_char) ; } extern \"C\" { pub fn fileno (__stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn fileno_unlocked (__stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn pclose (__stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn popen (__command : * const :: core :: ffi :: c_char , __modes : * const :: core :: ffi :: c_char) -> * mut FILE ; } extern \"C\" { pub fn ctermid (__s : * mut :: core :: ffi :: c_char) -> * mut :: core :: ffi :: c_char ; } extern \"C\" { pub fn flockfile (__stream : * mut FILE) ; } extern \"C\" { pub fn ftrylockfile (__stream : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn funlockfile (__stream : * mut FILE) ; } extern \"C\" { pub fn __uflow (arg1 : * mut FILE) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn __overflow (arg1 : * mut FILE , arg2 : :: core :: ffi :: c_int) -> :: core :: ffi :: c_int ; } # [doc = \"@brief   OS dependent lock interface.\"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_lock { # [doc = \"@brief   Lock access to mount point.\"] pub lock : :: core :: option :: Option < unsafe extern \"C\" fn () > , # [doc = \"@brief   Unlock access to mount point.\"] pub unlock : :: core :: option :: Option < unsafe extern \"C\" fn () > , } # [doc = \"@brief   File descriptor.\"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_file { # [doc = \"@brief   Mount point handle.\"] pub mp : * mut ext4_mountpoint , # [doc = \"@brief   File inode id.\"] pub inode : u32 , # [doc = \"@brief   Open flags.\"] pub flags : u32 , # [doc = \"@brief   File size.\"] pub fsize : u64 , # [doc = \"@brief   Actual file position.\"] pub fpos : u64 , } # [doc = \"@brief   Directory entry descriptor.\"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_direntry { pub inode : u32 , pub entry_length : u16 , pub name_length : u8 , pub inode_type : u8 , pub name : [u8 ; 255usize] , } # [doc = \"@brief   Directory descriptor.\"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_dir { # [doc = \"@brief   File descriptor.\"] pub f : ext4_file , # [doc = \"@brief   Current directory entry.\"] pub de : ext4_direntry , # [doc = \"@brief   Next entry offset.\"] pub next_off : u64 , } extern \"C\" { # [doc = \"@brief   Register block device.\\n\\n @param   bd Block device.\\n @param   dev_name Block device name.\\n\\n @return  Standard error code.\"] pub fn ext4_device_register (bd : * mut ext4_blockdev , dev_name : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Un-register block device.\\n\\n @param   dev_name Block device name.\\n\\n @return  Standard error code.\"] pub fn ext4_device_unregister (dev_name : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Un-register all block devices.\\n\\n @return  Standard error code.\"] pub fn ext4_device_unregister_all () -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Mount a block device with EXT4 partition to the mount point.\\n\\n @param   dev_name Block device name (@ref ext4_device_register).\\n @param   mount_point Mount point, for example:\\n          -   /\\n          -   /my_partition/\\n          -   /my_second_partition/\\n @param   read_only mount as read-only mode.\\n\\n @return Standard error code\"] pub fn ext4_mount (dev_name : * const :: core :: ffi :: c_char , mount_point : * const :: core :: ffi :: c_char , read_only : bool) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Umount operation.\\n\\n @param   mount_point Mount point.\\n\\n @return  Standard error code\"] pub fn ext4_umount (mount_point : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Starts journaling. Journaling start/stop functions are transparent\\n          and might be used on filesystems without journaling support.\\n @warning Usage:\\n              ext4_mount(\\\"sda1\\\", \\\"/\\\");\\n              ext4_journal_start(\\\"/\\\");\\n\\n              //File operations here...\\n\\n              ext4_journal_stop(\\\"/\\\");\\n              ext4_umount(\\\"/\\\");\\n @param   mount_point Mount point.\\n\\n @return  Standard error code.\"] pub fn ext4_journal_start (mount_point : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Stops journaling. Journaling start/stop functions are transparent\\n          and might be used on filesystems without journaling support.\\n\\n @param   mount_point Mount point name.\\n\\n @return  Standard error code.\"] pub fn ext4_journal_stop (mount_point : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Journal recovery.\\n @warning Must be called after @ref ext4_mount.\\n\\n @param   mount_point Mount point.\\n\\n @return Standard error code.\"] pub fn ext4_recover (mount_point : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } # [doc = \"@brief   Some of the filesystem stats.\"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_mount_stats { pub inodes_count : u32 , pub free_inodes_count : u32 , pub blocks_count : u64 , pub free_blocks_count : u64 , pub block_size : u32 , pub block_group_count : u32 , pub blocks_per_group : u32 , pub inodes_per_group : u32 , pub volume_name : [:: core :: ffi :: c_char ; 16usize] , } extern \"C\" { # [doc = \"@brief   Get file mount point stats.\\n\\n @param   mount_point Mount point.\\n @param   stats Filesystem stats.\\n\\n @return Standard error code.\"] pub fn ext4_mount_point_stats (mount_point : * const :: core :: ffi :: c_char , stats : * mut ext4_mount_stats) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Setup OS lock routines.\\n\\n @param   mount_point Mount point.\\n @param   locks  Lock and unlock functions\\n\\n @return Standard error code.\"] pub fn ext4_mount_setup_locks (mount_point : * const :: core :: ffi :: c_char , locks : * const ext4_lock) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Acquire the filesystem superblock pointer of a mp.\\n\\n @param   mount_point Mount point.\\n @param   sb Superblock handle\\n\\n @return Standard error code.\"] pub fn ext4_get_sblock (mount_point : * const :: core :: ffi :: c_char , sb : * mut * mut ext4_sblock) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Enable/disable write back cache mode.\\n @warning Default model of cache is write trough. It means that when You do:\\n\\n          ext4_fopen(...);\\n          ext4_fwrite(...);\\n                           < --- data is flushed to physical drive\\n\\n          When you do:\\n          ext4_cache_write_back(..., 1);\\n          ext4_fopen(...);\\n          ext4_fwrite(...);\\n                           < --- data is NOT flushed to physical drive\\n          ext4_cache_write_back(..., 0);\\n                           < --- when write back mode is disabled all\\n                                 cache data will be flushed\\n To enable write back mode permanently just call this function\\n once after ext4_mount (and disable before ext4_umount).\\n\\n Some of the function use write back cache mode internally.\\n If you enable write back mode twice you have to disable it twice\\n to flush all data:\\n\\n      ext4_cache_write_back(..., 1);\\n      ext4_cache_write_back(..., 1);\\n\\n      ext4_cache_write_back(..., 0);\\n      ext4_cache_write_back(..., 0);\\n\\n Write back mode is useful when you want to create a lot of empty\\n files/directories.\\n\\n @param   path Mount point.\\n @param   on Enable/disable cache writeback mode.\\n\\n @return Standard error code.\"] pub fn ext4_cache_write_back (path : * const :: core :: ffi :: c_char , on : bool) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Force cache flush.\\n\\n @param   path Mount point.\\n\\n @return  Standard error code.\"] pub fn ext4_cache_flush (path : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Remove file by path.\\n\\n @param   path Path to file.\\n\\n @return  Standard error code.\"] pub fn ext4_fremove (path : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Create a hardlink for a file.\\n\\n @param   path Path to file.\\n @param   hardlink_path Path of hardlink.\\n\\n @return  Standard error code.\"] pub fn ext4_flink (path : * const :: core :: ffi :: c_char , hardlink_path : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Rename file.\\n @param path Source.\\n @param new_path Destination.\\n @return  Standard error code.\"] pub fn ext4_frename (path : * const :: core :: ffi :: c_char , new_path : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   File open function.\\n\\n @param   file  File handle.\\n @param   path  File path, has to start from mount point:/my_partition/file.\\n @param   flags File open flags.\\n  |---------------------------------------------------------------|\\n  |   r or rb                 O_RDONLY                            |\\n  |---------------------------------------------------------------|\\n  |   w or wb                 O_WRONLY|O_CREAT|O_TRUNC            |\\n  |---------------------------------------------------------------|\\n  |   a or ab                 O_WRONLY|O_CREAT|O_APPEND           |\\n  |---------------------------------------------------------------|\\n  |   r+ or rb+ or r+b        O_RDWR                              |\\n  |---------------------------------------------------------------|\\n  |   w+ or wb+ or w+b        O_RDWR|O_CREAT|O_TRUNC              |\\n  |---------------------------------------------------------------|\\n  |   a+ or ab+ or a+b        O_RDWR|O_CREAT|O_APPEND             |\\n  |---------------------------------------------------------------|\\n\\n @return  Standard error code.\"] pub fn ext4_fopen (file : * mut ext4_file , path : * const :: core :: ffi :: c_char , flags : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Alternate file open function.\\n\\n @param   file  File handle.\\n @param   path  File path, has to start from mount point:/my_partition/file.\\n @param   flags File open flags.\\n\\n @return  Standard error code.\"] pub fn ext4_fopen2 (file : * mut ext4_file , path : * const :: core :: ffi :: c_char , flags : :: core :: ffi :: c_int) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   File close function.\\n\\n @param   file File handle.\\n\\n @return  Standard error code.\"] pub fn ext4_fclose (file : * mut ext4_file) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   File truncate function.\\n\\n @param   file File handle.\\n @param   size New file size.\\n\\n @return  Standard error code.\"] pub fn ext4_ftruncate (file : * mut ext4_file , size : u64) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Read data from file.\\n\\n @param   file File handle.\\n @param   buf  Output buffer.\\n @param   size Bytes to read.\\n @param   rcnt Bytes read (NULL allowed).\\n\\n @return  Standard error code.\"] pub fn ext4_fread (file : * mut ext4_file , buf : * mut :: core :: ffi :: c_void , size : usize , rcnt : * mut usize) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Write data to file.\\n\\n @param   file File handle.\\n @param   buf  Data to write\\n @param   size Write length..\\n @param   wcnt Bytes written (NULL allowed).\\n\\n @return  Standard error code.\"] pub fn ext4_fwrite (file : * mut ext4_file , buf : * const :: core :: ffi :: c_void , size : usize , wcnt : * mut usize) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   File seek operation.\\n\\n @param   file File handle.\\n @param   offset Offset to seek.\\n @param   origin Seek type:\\n              @ref SEEK_SET\\n              @ref SEEK_CUR\\n              @ref SEEK_END\\n\\n @return  Standard error code.\"] pub fn ext4_fseek (file : * mut ext4_file , offset : i64 , origin : u32) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Get file position.\\n\\n @param   file File handle.\\n\\n @return  Actual file position\"] pub fn ext4_ftell (file : * mut ext4_file) -> u64 ; } extern \"C\" { # [doc = \"@brief   Get file size.\\n\\n @param   file File handle.\\n\\n @return  File size.\"] pub fn ext4_fsize (file : * mut ext4_file) -> u64 ; } extern \"C\" { # [doc = \"@brief Get inode of file/directory/link.\\n\\n @param path    Parh to file/dir/link.\\n @param ret_ino Inode number.\\n @param inode   Inode internals.\\n\\n @return  Standard error code.\"] pub fn ext4_raw_inode_fill (path : * const :: core :: ffi :: c_char , ret_ino : * mut u32 , inode : * mut ext4_inode) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Check if inode exists.\\n\\n @param path    Parh to file/dir/link.\\n @param type    Inode type.\\n                @ref EXT4_DIRENTRY_UNKNOWN\\n                @ref EXT4_DE_REG_FILE\\n                @ref EXT4_DE_DIR\\n                @ref EXT4_DE_CHRDEV\\n                @ref EXT4_DE_BLKDEV\\n                @ref EXT4_DE_FIFO\\n                @ref EXT4_DE_SOCK\\n                @ref EXT4_DE_SYMLINK\\n\\n @return  Standard error code.\"] pub fn ext4_inode_exist (path : * const :: core :: ffi :: c_char , type_ : :: core :: ffi :: c_int) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Change file/directory/link mode bits.\\n\\n @param path Path to file/dir/link.\\n @param mode New mode bits (for example 0777).\\n\\n @return  Standard error code.\"] pub fn ext4_mode_set (path : * const :: core :: ffi :: c_char , mode : u32) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Get file/directory/link mode bits.\\n\\n @param path Path to file/dir/link.\\n @param mode New mode bits (for example 0777).\\n\\n @return  Standard error code.\"] pub fn ext4_mode_get (path : * const :: core :: ffi :: c_char , mode : * mut u32) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Change file owner and group.\\n\\n @param path Path to file/dir/link.\\n @param uid  User id.\\n @param gid  Group id.\\n\\n @return  Standard error code.\"] pub fn ext4_owner_set (path : * const :: core :: ffi :: c_char , uid : u32 , gid : u32) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Get file/directory/link owner and group.\\n\\n @param path Path to file/dir/link.\\n @param uid  User id.\\n @param gid  Group id.\\n\\n @return  Standard error code.\"] pub fn ext4_owner_get (path : * const :: core :: ffi :: c_char , uid : * mut u32 , gid : * mut u32) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Set file/directory/link access time.\\n\\n @param path  Path to file/dir/link.\\n @param atime Access timestamp.\\n\\n @return  Standard error code.\"] pub fn ext4_atime_set (path : * const :: core :: ffi :: c_char , atime : u32) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Set file/directory/link modify time.\\n\\n @param path  Path to file/dir/link.\\n @param mtime Modify timestamp.\\n\\n @return  Standard error code.\"] pub fn ext4_mtime_set (path : * const :: core :: ffi :: c_char , mtime : u32) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Set file/directory/link change time.\\n\\n @param path  Path to file/dir/link.\\n @param ctime Change timestamp.\\n\\n @return  Standard error code.\"] pub fn ext4_ctime_set (path : * const :: core :: ffi :: c_char , ctime : u32) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Get file/directory/link access time.\\n\\n @param path  Path to file/dir/link.\\n @param atime Access timestamp.\\n\\n @return  Standard error code.\"] pub fn ext4_atime_get (path : * const :: core :: ffi :: c_char , atime : * mut u32) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Get file/directory/link modify time.\\n\\n @param path  Path to file/dir/link.\\n @param mtime Modify timestamp.\\n\\n @return  Standard error code.\"] pub fn ext4_mtime_get (path : * const :: core :: ffi :: c_char , mtime : * mut u32) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Get file/directory/link change time.\\n\\n @param path  Pathto file/dir/link.\\n @param ctime Change timestamp.\\n\\n @return  standard error code\"] pub fn ext4_ctime_get (path : * const :: core :: ffi :: c_char , ctime : * mut u32) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Create symbolic link.\\n\\n @param target Destination entry path.\\n @param path   Source entry path.\\n\\n @return  Standard error code.\"] pub fn ext4_fsymlink (target : * const :: core :: ffi :: c_char , path : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Create special file.\\n @param path     Path to new special file.\\n @param filetype Filetype of the new special file.\\n \\t           (that must not be regular file, directory, or unknown type)\\n @param dev      If filetype is char device or block device,\\n \\t           the device number will become the payload in the inode.\\n @return  Standard error code.\"] pub fn ext4_mknod (path : * const :: core :: ffi :: c_char , filetype : :: core :: ffi :: c_int , dev : u32) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Read symbolic link payload.\\n\\n @param path    Path to symlink.\\n @param buf     Output buffer.\\n @param bufsize Output buffer max size.\\n @param rcnt    Bytes read.\\n\\n @return  Standard error code.\"] pub fn ext4_readlink (path : * const :: core :: ffi :: c_char , buf : * mut :: core :: ffi :: c_char , bufsize : usize , rcnt : * mut usize) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Set extended attribute.\\n\\n @param path      Path to file/directory\\n @param name      Name of the entry to add.\\n @param name_len  Length of @name in bytes.\\n @param data      Data of the entry to add.\\n @param data_size Size of data to add.\\n\\n @return  Standard error code.\"] pub fn ext4_setxattr (path : * const :: core :: ffi :: c_char , name : * const :: core :: ffi :: c_char , name_len : usize , data : * const :: core :: ffi :: c_void , data_size : usize) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Get extended attribute.\\n\\n @param path      Path to file/directory.\\n @param name      Name of the entry to get.\\n @param name_len  Length of @name in bytes.\\n @param buf      Data of the entry to get.\\n @param buf_size Size of data to get.\\n\\n @return  Standard error code.\"] pub fn ext4_getxattr (path : * const :: core :: ffi :: c_char , name : * const :: core :: ffi :: c_char , name_len : usize , buf : * mut :: core :: ffi :: c_void , buf_size : usize , data_size : * mut usize) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief List extended attributes.\\n\\n @param path     Path to file/directory.\\n @param list     List to hold the name of entries.\\n @param size     Size of @list in bytes.\\n @param ret_size Used bytes of @list.\\n\\n @return  Standard error code.\"] pub fn ext4_listxattr (path : * const :: core :: ffi :: c_char , list : * mut :: core :: ffi :: c_char , size : usize , ret_size : * mut usize) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Remove extended attribute.\\n\\n @param path     Path to file/directory.\\n @param name     Name of the entry to remove.\\n @param name_len Length of @name in bytes.\\n\\n @return  Standard error code.\"] pub fn ext4_removexattr (path : * const :: core :: ffi :: c_char , name : * const :: core :: ffi :: c_char , name_len : usize) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Recursive directory remove.\\n\\n @param   path Directory path to remove\\n\\n @return  Standard error code.\"] pub fn ext4_dir_rm (path : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Rename/move directory.\\n\\n @param path     Source path.\\n @param new_path Destination path.\\n\\n @return  Standard error code.\"] pub fn ext4_dir_mv (path : * const :: core :: ffi :: c_char , new_path : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Create new directory.\\n\\n @param   path Directory name.\\n\\n @return  Standard error code.\"] pub fn ext4_dir_mk (path : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Directory open.\\n\\n @param   dir  Directory handle.\\n @param   path Directory path.\\n\\n @return  Standard error code.\"] pub fn ext4_dir_open (dir : * mut ext4_dir , path : * const :: core :: ffi :: c_char) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Directory close.\\n\\n @param   dir directory handle.\\n\\n @return  Standard error code.\"] pub fn ext4_dir_close (dir : * mut ext4_dir) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Return next directory entry.\\n\\n @param   dir Directory handle.\\n\\n @return  Directory entry id (NULL if no entry)\"] pub fn ext4_dir_entry_next (dir : * mut ext4_dir) -> * const ext4_direntry ; } extern \"C\" { # [doc = \"@brief   Rewine directory entry offset.\\n\\n @param   dir Directory handle.\"] pub fn ext4_dir_entry_rewind (dir : * mut ext4_dir) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_fs { pub read_only : bool , pub bdev : * mut ext4_blockdev , pub sb : ext4_sblock , pub inode_block_limits : [u64 ; 4usize] , pub inode_blocks_per_level : [u64 ; 4usize] , pub last_inode_bg_id : u32 , pub jbd_fs : * mut jbd_fs , pub jbd_journal : * mut jbd_journal , pub curr_trans : * mut jbd_trans , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_block_group_ref { pub block : ext4_block , pub block_group : * mut ext4_bgroup , pub fs : * mut ext4_fs , pub index : u32 , pub dirty : bool , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_inode_ref { pub block : ext4_block , pub inode : * mut ext4_inode , pub fs : * mut ext4_fs , pub index : u32 , pub dirty : bool , } extern \"C\" { # [doc = \"@brief Initialize filesystem and read all needed data.\\n @param fs Filesystem instance to be initialized\\n @param bdev Identifier if device with the filesystem\\n @param read_only Mark the filesystem as read-only.\\n @return Error code\"] pub fn ext4_fs_init (fs : * mut ext4_fs , bdev : * mut ext4_blockdev , read_only : bool) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Destroy filesystem instance (used by unmount operation).\\n @param fs Filesystem to be destroyed\\n @return Error code\"] pub fn ext4_fs_fini (fs : * mut ext4_fs) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Check filesystem's features, if supported by this driver\\n Function can return EOK and set read_only flag. It mean's that\\n there are some not-supported features, that can cause problems\\n during some write operations.\\n @param fs        Filesystem to be checked\\n @param read_only Flag if filesystem should be mounted only for reading\\n @return Error code\"] pub fn ext4_fs_check_features (fs : * mut ext4_fs , read_only : * mut bool) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Get reference to block group specified by index.\\n @param fs   Filesystem to find block group on\\n @param bgid Index of block group to load\\n @param ref  Output pointer for reference\\n @return Error code\"] pub fn ext4_fs_get_block_group_ref (fs : * mut ext4_fs , bgid : u32 , ref_ : * mut ext4_block_group_ref) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Put reference to block group.\\n @param ref Pointer for reference to be put back\\n @return Error code\"] pub fn ext4_fs_put_block_group_ref (ref_ : * mut ext4_block_group_ref) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Get reference to i-node specified by index.\\n @param fs    Filesystem to find i-node on\\n @param index Index of i-node to load\\n @param ref   Output pointer for reference\\n @return Error code\"] pub fn ext4_fs_get_inode_ref (fs : * mut ext4_fs , index : u32 , ref_ : * mut ext4_inode_ref) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Reset blocks field of i-node.\\n @param fs        Filesystem to reset blocks field of i-inode on\\n @param inode_ref ref Pointer for inode to be operated on\"] pub fn ext4_fs_inode_blocks_init (fs : * mut ext4_fs , inode_ref : * mut ext4_inode_ref) ; } extern \"C\" { # [doc = \"@brief Put reference to i-node.\\n @param ref Pointer for reference to be put back\\n @return Error code\"] pub fn ext4_fs_put_inode_ref (ref_ : * mut ext4_inode_ref) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Convert filetype to inode mode.\\n @param filetype File type\\n @return inode mode\"] pub fn ext4_fs_correspond_inode_mode (filetype : :: core :: ffi :: c_int) -> u32 ; } extern \"C\" { # [doc = \"@brief Allocate new i-node in the filesystem.\\n @param fs        Filesystem to allocated i-node on\\n @param inode_ref Output pointer to return reference to allocated i-node\\n @param filetype  File type of newly created i-node\\n @return Error code\"] pub fn ext4_fs_alloc_inode (fs : * mut ext4_fs , inode_ref : * mut ext4_inode_ref , filetype : :: core :: ffi :: c_int) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Release i-node and mark it as free.\\n @param inode_ref I-node to be released\\n @return Error code\"] pub fn ext4_fs_free_inode (inode_ref : * mut ext4_inode_ref) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Truncate i-node data blocks.\\n @param inode_ref I-node to be truncated\\n @param new_size  New size of inode (must be < current size)\\n @return Error code\"] pub fn ext4_fs_truncate_inode (inode_ref : * mut ext4_inode_ref , new_size : u64) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Compute 'goal' for inode index\\n @param inode_ref Reference to inode, to allocate block for\\n @return goal\"] pub fn ext4_fs_inode_to_goal_block (inode_ref : * mut ext4_inode_ref) -> ext4_fsblk_t ; } extern \"C\" { # [doc = \"@brief Compute 'goal' for allocation algorithm (For blockmap).\\n @param inode_ref Reference to inode, to allocate block for\\n @return error code\"] pub fn ext4_fs_indirect_find_goal (inode_ref : * mut ext4_inode_ref , goal : * mut ext4_fsblk_t) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Get physical block address by logical index of the block.\\n @param inode_ref I-node to read block address from\\n @param iblock            Logical index of block\\n @param fblock            Output pointer for return physical\\n                          block address\\n @param support_unwritten Indicate whether unwritten block range\\n                          is supported under the current context\\n @return Error code\"] pub fn ext4_fs_get_inode_dblk_idx (inode_ref : * mut ext4_inode_ref , iblock : ext4_lblk_t , fblock : * mut ext4_fsblk_t , support_unwritten : bool) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Initialize a part of unwritten range of the inode.\\n @param inode_ref I-node to proceed on.\\n @param iblock    Logical index of block\\n @param fblock    Output pointer for return physical block address\\n @return Error code\"] pub fn ext4_fs_init_inode_dblk_idx (inode_ref : * mut ext4_inode_ref , iblock : ext4_lblk_t , fblock : * mut ext4_fsblk_t) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief Append following logical block to the i-node.\\n @param inode_ref I-node to append block to\\n @param fblock    Output physical block address of newly allocated block\\n @param iblock    Output logical number of newly allocated block\\n @return Error code\"] pub fn ext4_fs_append_inode_dblk (inode_ref : * mut ext4_inode_ref , fblock : * mut ext4_fsblk_t , iblock : * mut ext4_lblk_t) -> :: core :: ffi :: c_int ; } extern \"C\" { # [doc = \"@brief   Increment inode link count.\\n @param   inode_ref none handle\"] pub fn ext4_fs_inode_links_count_inc (inode_ref : * mut ext4_inode_ref) ; } extern \"C\" { # [doc = \"@brief   Decrement inode link count.\\n @param   inode_ref none handle\"] pub fn ext4_fs_inode_links_count_dec (inode_ref : * mut ext4_inode_ref) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_mkfs_info { pub len : u64 , pub block_size : u32 , pub blocks_per_group : u32 , pub inodes_per_group : u32 , pub inode_size : u32 , pub inodes : u32 , pub journal_blocks : u32 , pub feat_ro_compat : u32 , pub feat_compat : u32 , pub feat_incompat : u32 , pub bg_desc_reserve_blocks : u32 , pub dsc_size : u16 , pub uuid : [u8 ; 16usize] , pub journal : bool , pub label : * const :: core :: ffi :: c_char , } extern \"C\" { pub fn ext4_mkfs_read_info (bd : * mut ext4_blockdev , info : * mut ext4_mkfs_info) -> :: core :: ffi :: c_int ; } extern \"C\" { pub fn ext4_mkfs (fs : * mut ext4_fs , bd : * mut ext4_blockdev , info : * mut ext4_mkfs_info , fs_type : :: core :: ffi :: c_int) -> :: core :: ffi :: c_int ; } # [doc = \"@brief   Mount point descriptor.\"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct ext4_mountpoint { # [doc = \"@brief   Mount done flag.\"] pub mounted : bool , # [doc = \"@brief   Mount point name (@ref ext4_mount)\"] pub name : [:: core :: ffi :: c_char ; 33usize] , # [doc = \"@brief   OS dependent lock/unlock functions.\"] pub os_locks : * const ext4_lock , # [doc = \"@brief   Ext4 filesystem internals.\"] pub fs : ext4_fs , } pub type __builtin_va_list = [__va_list_tag ; 1usize] ; # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __va_list_tag { pub gp_offset : :: core :: ffi :: c_uint , pub fp_offset : :: core :: ffi :: c_uint , pub overflow_arg_area : * mut :: core :: ffi :: c_void , pub reg_save_area : * mut :: core :: ffi :: c_void , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct jbd_fs { pub _address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct jbd_journal { pub _address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct jbd_trans { pub _address : u8 , }\n+#[repr(C)]\n+#[derive(Default)]\n+pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);\n+impl<T> __IncompleteArrayField<T> {\n+    #[inline]\n+    pub const fn new() -> Self {\n+        __IncompleteArrayField(::core::marker::PhantomData, [])\n+    }\n+    #[inline]\n+    pub fn as_ptr(&self) -> *const T {\n+        self as *const _ as *const T\n+    }\n+    #[inline]\n+    pub fn as_mut_ptr(&mut self) -> *mut T {\n+        self as *mut _ as *mut T\n+    }\n+    #[inline]\n+    pub unsafe fn as_slice(&self, len: usize) -> &[T] {\n+        ::core::slice::from_raw_parts(self.as_ptr(), len)\n+    }\n+    #[inline]\n+    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {\n+        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)\n+    }\n+}\n+impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {\n+    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {\n+        fmt.write_str(\"__IncompleteArrayField\")\n+    }\n+}\n+pub const _STDINT_H: u32 = 1;\n+pub const _FEATURES_H: u32 = 1;\n+pub const _DEFAULT_SOURCE: u32 = 1;\n+pub const __GLIBC_USE_ISOC2X: u32 = 0;\n+pub const __USE_ISOC11: u32 = 1;\n+pub const __USE_ISOC99: u32 = 1;\n+pub const __USE_ISOC95: u32 = 1;\n+pub const __USE_POSIX_IMPLICITLY: u32 = 1;\n+pub const _POSIX_SOURCE: u32 = 1;\n+pub const _POSIX_C_SOURCE: u32 = 200809;\n+pub const __USE_POSIX: u32 = 1;\n+pub const __USE_POSIX2: u32 = 1;\n+pub const __USE_POSIX199309: u32 = 1;\n+pub const __USE_POSIX199506: u32 = 1;\n+pub const __USE_XOPEN2K: u32 = 1;\n+pub const __USE_XOPEN2K8: u32 = 1;\n+pub const _ATFILE_SOURCE: u32 = 1;\n+pub const __WORDSIZE: u32 = 64;\n+pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;\n+pub const __SYSCALL_WORDSIZE: u32 = 64;\n+pub const __TIMESIZE: u32 = 64;\n+pub const __USE_MISC: u32 = 1;\n+pub const __USE_ATFILE: u32 = 1;\n+pub const __USE_FORTIFY_LEVEL: u32 = 0;\n+pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;\n+pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;\n+pub const _STDC_PREDEF_H: u32 = 1;\n+pub const __STDC_IEC_559__: u32 = 1;\n+pub const __STDC_IEC_60559_BFP__: u32 = 201404;\n+pub const __STDC_IEC_559_COMPLEX__: u32 = 1;\n+pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;\n+pub const __STDC_ISO_10646__: u32 = 201706;\n+pub const __GNU_LIBRARY__: u32 = 6;\n+pub const __GLIBC__: u32 = 2;\n+pub const __GLIBC_MINOR__: u32 = 35;\n+pub const _SYS_CDEFS_H: u32 = 1;\n+pub const __glibc_c99_flexarr_available: u32 = 1;\n+pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;\n+pub const __HAVE_GENERIC_SELECTION: u32 = 1;\n+pub const __GLIBC_USE_LIB_EXT2: u32 = 0;\n+pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;\n+pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;\n+pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;\n+pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;\n+pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;\n+pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;\n+pub const _BITS_TYPES_H: u32 = 1;\n+pub const _BITS_TYPESIZES_H: u32 = 1;\n+pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;\n+pub const __INO_T_MATCHES_INO64_T: u32 = 1;\n+pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;\n+pub const __STATFS_MATCHES_STATFS64: u32 = 1;\n+pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;\n+pub const __FD_SETSIZE: u32 = 1024;\n+pub const _BITS_TIME64_H: u32 = 1;\n+pub const _BITS_WCHAR_H: u32 = 1;\n+pub const _BITS_STDINT_INTN_H: u32 = 1;\n+pub const _BITS_STDINT_UINTN_H: u32 = 1;\n+pub const INT8_MIN: i32 = -128;\n+pub const INT16_MIN: i32 = -32768;\n+pub const INT32_MIN: i32 = -2147483648;\n+pub const INT8_MAX: u32 = 127;\n+pub const INT16_MAX: u32 = 32767;\n+pub const INT32_MAX: u32 = 2147483647;\n+pub const UINT8_MAX: u32 = 255;\n+pub const UINT16_MAX: u32 = 65535;\n+pub const UINT32_MAX: u32 = 4294967295;\n+pub const INT_LEAST8_MIN: i32 = -128;\n+pub const INT_LEAST16_MIN: i32 = -32768;\n+pub const INT_LEAST32_MIN: i32 = -2147483648;\n+pub const INT_LEAST8_MAX: u32 = 127;\n+pub const INT_LEAST16_MAX: u32 = 32767;\n+pub const INT_LEAST32_MAX: u32 = 2147483647;\n+pub const UINT_LEAST8_MAX: u32 = 255;\n+pub const UINT_LEAST16_MAX: u32 = 65535;\n+pub const UINT_LEAST32_MAX: u32 = 4294967295;\n+pub const INT_FAST8_MIN: i32 = -128;\n+pub const INT_FAST16_MIN: i64 = -9223372036854775808;\n+pub const INT_FAST32_MIN: i64 = -9223372036854775808;\n+pub const INT_FAST8_MAX: u32 = 127;\n+pub const INT_FAST16_MAX: u64 = 9223372036854775807;\n+pub const INT_FAST32_MAX: u64 = 9223372036854775807;\n+pub const UINT_FAST8_MAX: u32 = 255;\n+pub const UINT_FAST16_MAX: i32 = -1;\n+pub const UINT_FAST32_MAX: i32 = -1;\n+pub const INTPTR_MIN: i64 = -9223372036854775808;\n+pub const INTPTR_MAX: u64 = 9223372036854775807;\n+pub const UINTPTR_MAX: i32 = -1;\n+pub const PTRDIFF_MIN: i64 = -9223372036854775808;\n+pub const PTRDIFF_MAX: u64 = 9223372036854775807;\n+pub const SIG_ATOMIC_MIN: i32 = -2147483648;\n+pub const SIG_ATOMIC_MAX: u32 = 2147483647;\n+pub const SIZE_MAX: i32 = -1;\n+pub const WINT_MIN: u32 = 0;\n+pub const WINT_MAX: u32 = 4294967295;\n+pub const CONFIG_USE_DEFAULT_CONFIG: u32 = 0;\n+pub const CONFIG_DEBUG_PRINTF: u32 = 1;\n+pub const CONFIG_HAVE_OWN_OFLAGS: u32 = 1;\n+pub const CONFIG_HAVE_OWN_ERRNO: u32 = 1;\n+pub const CONFIG_HAVE_OWN_ASSERT: u32 = 1;\n+pub const CONFIG_BLOCK_DEV_CACHE_SIZE: u32 = 16;\n+pub const F_SET_EXT2: u32 = 2;\n+pub const F_SET_EXT3: u32 = 3;\n+pub const F_SET_EXT4: u32 = 4;\n+pub const CONFIG_EXT_FEATURE_SET_LVL: u32 = 4;\n+pub const CONFIG_JOURNALING_ENABLE: u32 = 1;\n+pub const CONFIG_XATTR_ENABLE: u32 = 1;\n+pub const CONFIG_EXTENTS_ENABLE: u32 = 1;\n+pub const CONFIG_DEBUG_ASSERT: u32 = 1;\n+pub const CONFIG_BLOCK_DEV_ENABLE_STATS: u32 = 1;\n+pub const CONFIG_EXT4_MAX_BLOCKDEV_NAME: u32 = 32;\n+pub const CONFIG_EXT4_BLOCKDEVS_COUNT: u32 = 2;\n+pub const CONFIG_EXT4_MAX_MP_NAME: u32 = 32;\n+pub const CONFIG_EXT4_MOUNTPOINTS_COUNT: u32 = 2;\n+pub const CONFIG_MAX_TRUNCATE_SIZE: u32 = 16777216;\n+pub const CONFIG_UNALIGNED_ACCESS: u32 = 0;\n+pub const CONFIG_USE_USER_MALLOC: u32 = 0;\n+pub const true_: u32 = 1;\n+pub const false_: u32 = 0;\n+pub const __bool_true_false_are_defined: u32 = 1;\n+pub const SPLAY_NEGINF: i32 = -1;\n+pub const SPLAY_INF: u32 = 1;\n+pub const RB_BLACK: u32 = 0;\n+pub const RB_RED: u32 = 1;\n+pub const RB_NEGINF: i32 = -1;\n+pub const RB_INF: u32 = 1;\n+pub const EXT4_CHECKSUM_CRC32C: u32 = 1;\n+pub const UUID_SIZE: u32 = 16;\n+pub const EXT4_SUPERBLOCK_MAGIC: u32 = 61267;\n+pub const EXT4_SUPERBLOCK_SIZE: u32 = 1024;\n+pub const EXT4_SUPERBLOCK_OFFSET: u32 = 1024;\n+pub const EXT4_SUPERBLOCK_OS_LINUX: u32 = 0;\n+pub const EXT4_SUPERBLOCK_OS_HURD: u32 = 1;\n+pub const EXT4_SUPERBLOCK_FLAGS_SIGNED_HASH: u32 = 1;\n+pub const EXT4_SUPERBLOCK_FLAGS_UNSIGNED_HASH: u32 = 2;\n+pub const EXT4_SUPERBLOCK_FLAGS_TEST_FILESYS: u32 = 4;\n+pub const EXT4_SUPERBLOCK_STATE_VALID_FS: u32 = 1;\n+pub const EXT4_SUPERBLOCK_STATE_ERROR_FS: u32 = 2;\n+pub const EXT4_SUPERBLOCK_STATE_ORPHAN_FS: u32 = 4;\n+pub const EXT4_SUPERBLOCK_ERRORS_CONTINUE: u32 = 1;\n+pub const EXT4_SUPERBLOCK_ERRORS_RO: u32 = 2;\n+pub const EXT4_SUPERBLOCK_ERRORS_PANIC: u32 = 3;\n+pub const EXT4_FCOM_DIR_PREALLOC: u32 = 1;\n+pub const EXT4_FCOM_IMAGIC_INODES: u32 = 2;\n+pub const EXT4_FCOM_HAS_JOURNAL: u32 = 4;\n+pub const EXT4_FCOM_EXT_ATTR: u32 = 8;\n+pub const EXT4_FCOM_RESIZE_INODE: u32 = 16;\n+pub const EXT4_FCOM_DIR_INDEX: u32 = 32;\n+pub const EXT4_FRO_COM_SPARSE_SUPER: u32 = 1;\n+pub const EXT4_FRO_COM_LARGE_FILE: u32 = 2;\n+pub const EXT4_FRO_COM_BTREE_DIR: u32 = 4;\n+pub const EXT4_FRO_COM_HUGE_FILE: u32 = 8;\n+pub const EXT4_FRO_COM_GDT_CSUM: u32 = 16;\n+pub const EXT4_FRO_COM_DIR_NLINK: u32 = 32;\n+pub const EXT4_FRO_COM_EXTRA_ISIZE: u32 = 64;\n+pub const EXT4_FRO_COM_QUOTA: u32 = 256;\n+pub const EXT4_FRO_COM_BIGALLOC: u32 = 512;\n+pub const EXT4_FRO_COM_METADATA_CSUM: u32 = 1024;\n+pub const EXT4_FINCOM_COMPRESSION: u32 = 1;\n+pub const EXT4_FINCOM_FILETYPE: u32 = 2;\n+pub const EXT4_FINCOM_RECOVER: u32 = 4;\n+pub const EXT4_FINCOM_JOURNAL_DEV: u32 = 8;\n+pub const EXT4_FINCOM_META_BG: u32 = 16;\n+pub const EXT4_FINCOM_EXTENTS: u32 = 64;\n+pub const EXT4_FINCOM_64BIT: u32 = 128;\n+pub const EXT4_FINCOM_MMP: u32 = 256;\n+pub const EXT4_FINCOM_FLEX_BG: u32 = 512;\n+pub const EXT4_FINCOM_EA_INODE: u32 = 1024;\n+pub const EXT4_FINCOM_DIRDATA: u32 = 4096;\n+pub const EXT4_FINCOM_BG_USE_META_CSUM: u32 = 8192;\n+pub const EXT4_FINCOM_LARGEDIR: u32 = 16384;\n+pub const EXT4_FINCOM_INLINE_DATA: u32 = 32768;\n+pub const EXT2_SUPPORTED_FCOM: u32 = 0;\n+pub const EXT2_SUPPORTED_FINCOM: u32 = 18;\n+pub const EXT2_SUPPORTED_FRO_COM: u32 = 3;\n+pub const EXT3_SUPPORTED_FCOM: u32 = 32;\n+pub const EXT3_SUPPORTED_FINCOM: u32 = 18;\n+pub const EXT3_SUPPORTED_FRO_COM: u32 = 3;\n+pub const EXT4_SUPPORTED_FCOM: u32 = 32;\n+pub const EXT4_SUPPORTED_FINCOM: u32 = 722;\n+pub const EXT4_SUPPORTED_FRO_COM: u32 = 1147;\n+pub const EXT_FINCOM_IGNORED: u32 = 260;\n+pub const EXT4_BLOCK_GROUP_INODE_UNINIT: u32 = 1;\n+pub const EXT4_BLOCK_GROUP_BLOCK_UNINIT: u32 = 2;\n+pub const EXT4_BLOCK_GROUP_ITABLE_ZEROED: u32 = 4;\n+pub const EXT4_MIN_BLOCK_GROUP_DESCRIPTOR_SIZE: u32 = 32;\n+pub const EXT4_MAX_BLOCK_GROUP_DESCRIPTOR_SIZE: u32 = 64;\n+pub const EXT4_MIN_BLOCK_SIZE: u32 = 1024;\n+pub const EXT4_MAX_BLOCK_SIZE: u32 = 65536;\n+pub const EXT4_REV0_INODE_SIZE: u32 = 128;\n+pub const EXT4_INODE_BLOCK_SIZE: u32 = 512;\n+pub const EXT4_INODE_DIRECT_BLOCK_COUNT: u32 = 12;\n+pub const EXT4_INODE_INDIRECT_BLOCK: u32 = 12;\n+pub const EXT4_INODE_DOUBLE_INDIRECT_BLOCK: u32 = 13;\n+pub const EXT4_INODE_TRIPPLE_INDIRECT_BLOCK: u32 = 14;\n+pub const EXT4_INODE_BLOCKS: u32 = 15;\n+pub const EXT4_INODE_INDIRECT_BLOCK_COUNT: u32 = 3;\n+pub const EXT4_INODE_MODE_FIFO: u32 = 4096;\n+pub const EXT4_INODE_MODE_CHARDEV: u32 = 8192;\n+pub const EXT4_INODE_MODE_DIRECTORY: u32 = 16384;\n+pub const EXT4_INODE_MODE_BLOCKDEV: u32 = 24576;\n+pub const EXT4_INODE_MODE_FILE: u32 = 32768;\n+pub const EXT4_INODE_MODE_SOFTLINK: u32 = 40960;\n+pub const EXT4_INODE_MODE_SOCKET: u32 = 49152;\n+pub const EXT4_INODE_MODE_TYPE_MASK: u32 = 61440;\n+pub const EXT4_INODE_FLAG_SECRM: u32 = 1;\n+pub const EXT4_INODE_FLAG_UNRM: u32 = 2;\n+pub const EXT4_INODE_FLAG_COMPR: u32 = 4;\n+pub const EXT4_INODE_FLAG_SYNC: u32 = 8;\n+pub const EXT4_INODE_FLAG_IMMUTABLE: u32 = 16;\n+pub const EXT4_INODE_FLAG_APPEND: u32 = 32;\n+pub const EXT4_INODE_FLAG_NODUMP: u32 = 64;\n+pub const EXT4_INODE_FLAG_NOATIME: u32 = 128;\n+pub const EXT4_INODE_FLAG_DIRTY: u32 = 256;\n+pub const EXT4_INODE_FLAG_COMPRBLK: u32 = 512;\n+pub const EXT4_INODE_FLAG_NOCOMPR: u32 = 1024;\n+pub const EXT4_INODE_FLAG_ECOMPR: u32 = 2048;\n+pub const EXT4_INODE_FLAG_INDEX: u32 = 4096;\n+pub const EXT4_INODE_FLAG_IMAGIC: u32 = 8192;\n+pub const EXT4_INODE_FLAG_JOURNAL_DATA: u32 = 16384;\n+pub const EXT4_INODE_FLAG_NOTAIL: u32 = 32768;\n+pub const EXT4_INODE_FLAG_DIRSYNC: u32 = 65536;\n+pub const EXT4_INODE_FLAG_TOPDIR: u32 = 131072;\n+pub const EXT4_INODE_FLAG_HUGE_FILE: u32 = 262144;\n+pub const EXT4_INODE_FLAG_EXTENTS: u32 = 524288;\n+pub const EXT4_INODE_FLAG_EA_INODE: u32 = 2097152;\n+pub const EXT4_INODE_FLAG_EOFBLOCKS: u32 = 4194304;\n+pub const EXT4_INODE_FLAG_RESERVED: u32 = 2147483648;\n+pub const EXT4_INODE_ROOT_INDEX: u32 = 2;\n+pub const EXT4_DIRECTORY_FILENAME_LEN: u32 = 255;\n+pub const EXT4_DIRENTRY_DIR_CSUM: u32 = 222;\n+pub const EXT4_ERR_BAD_DX_DIR: i32 = -25000;\n+pub const EXT4_LINK_MAX: u32 = 65000;\n+pub const EXT4_BAD_INO: u32 = 1;\n+pub const EXT4_ROOT_INO: u32 = 2;\n+pub const EXT4_BOOT_LOADER_INO: u32 = 5;\n+pub const EXT4_UNDEL_DIR_INO: u32 = 6;\n+pub const EXT4_RESIZE_INO: u32 = 7;\n+pub const EXT4_JOURNAL_INO: u32 = 8;\n+pub const EXT4_GOOD_OLD_FIRST_INO: u32 = 11;\n+pub const EXT2_HTREE_LEGACY: u32 = 0;\n+pub const EXT2_HTREE_HALF_MD4: u32 = 1;\n+pub const EXT2_HTREE_TEA: u32 = 2;\n+pub const EXT2_HTREE_LEGACY_UNSIGNED: u32 = 3;\n+pub const EXT2_HTREE_HALF_MD4_UNSIGNED: u32 = 4;\n+pub const EXT2_HTREE_TEA_UNSIGNED: u32 = 5;\n+pub const EXT2_HTREE_EOF: u32 = 2147483647;\n+pub const EXT4_GOOD_OLD_INODE_SIZE: u32 = 128;\n+pub const JBD_MAGIC_NUMBER: u32 = 3225106840;\n+pub const JBD_DESCRIPTOR_BLOCK: u32 = 1;\n+pub const JBD_COMMIT_BLOCK: u32 = 2;\n+pub const JBD_SUPERBLOCK: u32 = 3;\n+pub const JBD_SUPERBLOCK_V2: u32 = 4;\n+pub const JBD_REVOKE_BLOCK: u32 = 5;\n+pub const JBD_CRC32_CHKSUM: u32 = 1;\n+pub const JBD_MD5_CHKSUM: u32 = 2;\n+pub const JBD_SHA1_CHKSUM: u32 = 3;\n+pub const JBD_CRC32C_CHKSUM: u32 = 4;\n+pub const JBD_CRC32_CHKSUM_SIZE: u32 = 4;\n+pub const JBD_FLAG_ESCAPE: u32 = 1;\n+pub const JBD_FLAG_SAME_UUID: u32 = 2;\n+pub const JBD_FLAG_DELETED: u32 = 4;\n+pub const JBD_FLAG_LAST_TAG: u32 = 8;\n+pub const JBD_USERS_MAX: u32 = 48;\n+pub const JBD_USERS_SIZE: u32 = 768;\n+pub const JBD_FEATURE_COMPAT_CHECKSUM: u32 = 1;\n+pub const JBD_FEATURE_INCOMPAT_REVOKE: u32 = 1;\n+pub const JBD_FEATURE_INCOMPAT_64BIT: u32 = 2;\n+pub const JBD_FEATURE_INCOMPAT_ASYNC_COMMIT: u32 = 4;\n+pub const JBD_FEATURE_INCOMPAT_CSUM_V2: u32 = 8;\n+pub const JBD_FEATURE_INCOMPAT_CSUM_V3: u32 = 16;\n+pub const JBD_KNOWN_COMPAT_FEATURES: u32 = 0;\n+pub const JBD_KNOWN_ROCOMPAT_FEATURES: u32 = 0;\n+pub const JBD_KNOWN_INCOMPAT_FEATURES: u32 = 31;\n+pub const EXT4_CRC32_INIT: u32 = 4294967295;\n+pub const EPERM: u32 = 1;\n+pub const ENOENT: u32 = 2;\n+pub const EIO: u32 = 5;\n+pub const ENXIO: u32 = 6;\n+pub const E2BIG: u32 = 7;\n+pub const ENOMEM: u32 = 12;\n+pub const EACCES: u32 = 13;\n+pub const EFAULT: u32 = 14;\n+pub const EEXIST: u32 = 17;\n+pub const ENODEV: u32 = 19;\n+pub const ENOTDIR: u32 = 20;\n+pub const EISDIR: u32 = 21;\n+pub const EINVAL: u32 = 22;\n+pub const EFBIG: u32 = 27;\n+pub const ENOSPC: u32 = 28;\n+pub const EROFS: u32 = 30;\n+pub const EMLINK: u32 = 31;\n+pub const ERANGE: u32 = 34;\n+pub const ENOTEMPTY: u32 = 39;\n+pub const ENODATA: u32 = 61;\n+pub const ENOTSUP: u32 = 95;\n+pub const EOK: u32 = 0;\n+pub const O_RDONLY: u32 = 0;\n+pub const O_WRONLY: u32 = 1;\n+pub const O_RDWR: u32 = 2;\n+pub const O_CREAT: u32 = 64;\n+pub const O_EXCL: u32 = 128;\n+pub const O_TRUNC: u32 = 512;\n+pub const O_APPEND: u32 = 1024;\n+pub const SEEK_SET: u32 = 0;\n+pub const SEEK_CUR: u32 = 1;\n+pub const SEEK_END: u32 = 2;\n+pub const _INTTYPES_H: u32 = 1;\n+pub const ____gwchar_t_defined: u32 = 1;\n+pub const __PRI64_PREFIX: &[u8; 2usize] = b\"l\\0\";\n+pub const __PRIPTR_PREFIX: &[u8; 2usize] = b\"l\\0\";\n+pub const PRId8: &[u8; 2usize] = b\"d\\0\";\n+pub const PRId16: &[u8; 2usize] = b\"d\\0\";\n+pub const PRId32: &[u8; 2usize] = b\"d\\0\";\n+pub const PRId64: &[u8; 3usize] = b\"ld\\0\";\n+pub const PRIdLEAST8: &[u8; 2usize] = b\"d\\0\";\n+pub const PRIdLEAST16: &[u8; 2usize] = b\"d\\0\";\n+pub const PRIdLEAST32: &[u8; 2usize] = b\"d\\0\";\n+pub const PRIdLEAST64: &[u8; 3usize] = b\"ld\\0\";\n+pub const PRIdFAST8: &[u8; 2usize] = b\"d\\0\";\n+pub const PRIdFAST16: &[u8; 3usize] = b\"ld\\0\";\n+pub const PRIdFAST32: &[u8; 3usize] = b\"ld\\0\";\n+pub const PRIdFAST64: &[u8; 3usize] = b\"ld\\0\";\n+pub const PRIi8: &[u8; 2usize] = b\"i\\0\";\n+pub const PRIi16: &[u8; 2usize] = b\"i\\0\";\n+pub const PRIi32: &[u8; 2usize] = b\"i\\0\";\n+pub const PRIi64: &[u8; 3usize] = b\"li\\0\";\n+pub const PRIiLEAST8: &[u8; 2usize] = b\"i\\0\";\n+pub const PRIiLEAST16: &[u8; 2usize] = b\"i\\0\";\n+pub const PRIiLEAST32: &[u8; 2usize] = b\"i\\0\";\n+pub const PRIiLEAST64: &[u8; 3usize] = b\"li\\0\";\n+pub const PRIiFAST8: &[u8; 2usize] = b\"i\\0\";\n+pub const PRIiFAST16: &[u8; 3usize] = b\"li\\0\";\n+pub const PRIiFAST32: &[u8; 3usize] = b\"li\\0\";\n+pub const PRIiFAST64: &[u8; 3usize] = b\"li\\0\";\n+pub const PRIo8: &[u8; 2usize] = b\"o\\0\";\n+pub const PRIo16: &[u8; 2usize] = b\"o\\0\";\n+pub const PRIo32: &[u8; 2usize] = b\"o\\0\";\n+pub const PRIo64: &[u8; 3usize] = b\"lo\\0\";\n+pub const PRIoLEAST8: &[u8; 2usize] = b\"o\\0\";\n+pub const PRIoLEAST16: &[u8; 2usize] = b\"o\\0\";\n+pub const PRIoLEAST32: &[u8; 2usize] = b\"o\\0\";\n+pub const PRIoLEAST64: &[u8; 3usize] = b\"lo\\0\";\n+pub const PRIoFAST8: &[u8; 2usize] = b\"o\\0\";\n+pub const PRIoFAST16: &[u8; 3usize] = b\"lo\\0\";\n+pub const PRIoFAST32: &[u8; 3usize] = b\"lo\\0\";\n+pub const PRIoFAST64: &[u8; 3usize] = b\"lo\\0\";\n+pub const PRIu8: &[u8; 2usize] = b\"u\\0\";\n+pub const PRIu16: &[u8; 2usize] = b\"u\\0\";\n+pub const PRIu32: &[u8; 2usize] = b\"u\\0\";\n+pub const PRIu64: &[u8; 3usize] = b\"lu\\0\";\n+pub const PRIuLEAST8: &[u8; 2usize] = b\"u\\0\";\n+pub const PRIuLEAST16: &[u8; 2usize] = b\"u\\0\";\n+pub const PRIuLEAST32: &[u8; 2usize] = b\"u\\0\";\n+pub const PRIuLEAST64: &[u8; 3usize] = b\"lu\\0\";\n+pub const PRIuFAST8: &[u8; 2usize] = b\"u\\0\";\n+pub const PRIuFAST16: &[u8; 3usize] = b\"lu\\0\";\n+pub const PRIuFAST32: &[u8; 3usize] = b\"lu\\0\";\n+pub const PRIuFAST64: &[u8; 3usize] = b\"lu\\0\";\n+pub const PRIx8: &[u8; 2usize] = b\"x\\0\";\n+pub const PRIx16: &[u8; 2usize] = b\"x\\0\";\n+pub const PRIx32: &[u8; 2usize] = b\"x\\0\";\n+pub const PRIx64: &[u8; 3usize] = b\"lx\\0\";\n+pub const PRIxLEAST8: &[u8; 2usize] = b\"x\\0\";\n+pub const PRIxLEAST16: &[u8; 2usize] = b\"x\\0\";\n+pub const PRIxLEAST32: &[u8; 2usize] = b\"x\\0\";\n+pub const PRIxLEAST64: &[u8; 3usize] = b\"lx\\0\";\n+pub const PRIxFAST8: &[u8; 2usize] = b\"x\\0\";\n+pub const PRIxFAST16: &[u8; 3usize] = b\"lx\\0\";\n+pub const PRIxFAST32: &[u8; 3usize] = b\"lx\\0\";\n+pub const PRIxFAST64: &[u8; 3usize] = b\"lx\\0\";\n+pub const PRIX8: &[u8; 2usize] = b\"X\\0\";\n+pub const PRIX16: &[u8; 2usize] = b\"X\\0\";\n+pub const PRIX32: &[u8; 2usize] = b\"X\\0\";\n+pub const PRIX64: &[u8; 3usize] = b\"lX\\0\";\n+pub const PRIXLEAST8: &[u8; 2usize] = b\"X\\0\";\n+pub const PRIXLEAST16: &[u8; 2usize] = b\"X\\0\";\n+pub const PRIXLEAST32: &[u8; 2usize] = b\"X\\0\";\n+pub const PRIXLEAST64: &[u8; 3usize] = b\"lX\\0\";\n+pub const PRIXFAST8: &[u8; 2usize] = b\"X\\0\";\n+pub const PRIXFAST16: &[u8; 3usize] = b\"lX\\0\";\n+pub const PRIXFAST32: &[u8; 3usize] = b\"lX\\0\";\n+pub const PRIXFAST64: &[u8; 3usize] = b\"lX\\0\";\n+pub const PRIdMAX: &[u8; 3usize] = b\"ld\\0\";\n+pub const PRIiMAX: &[u8; 3usize] = b\"li\\0\";\n+pub const PRIoMAX: &[u8; 3usize] = b\"lo\\0\";\n+pub const PRIuMAX: &[u8; 3usize] = b\"lu\\0\";\n+pub const PRIxMAX: &[u8; 3usize] = b\"lx\\0\";\n+pub const PRIXMAX: &[u8; 3usize] = b\"lX\\0\";\n+pub const PRIdPTR: &[u8; 3usize] = b\"ld\\0\";\n+pub const PRIiPTR: &[u8; 3usize] = b\"li\\0\";\n+pub const PRIoPTR: &[u8; 3usize] = b\"lo\\0\";\n+pub const PRIuPTR: &[u8; 3usize] = b\"lu\\0\";\n+pub const PRIxPTR: &[u8; 3usize] = b\"lx\\0\";\n+pub const PRIXPTR: &[u8; 3usize] = b\"lX\\0\";\n+pub const SCNd8: &[u8; 4usize] = b\"hhd\\0\";\n+pub const SCNd16: &[u8; 3usize] = b\"hd\\0\";\n+pub const SCNd32: &[u8; 2usize] = b\"d\\0\";\n+pub const SCNd64: &[u8; 3usize] = b\"ld\\0\";\n+pub const SCNdLEAST8: &[u8; 4usize] = b\"hhd\\0\";\n+pub const SCNdLEAST16: &[u8; 3usize] = b\"hd\\0\";\n+pub const SCNdLEAST32: &[u8; 2usize] = b\"d\\0\";\n+pub const SCNdLEAST64: &[u8; 3usize] = b\"ld\\0\";\n+pub const SCNdFAST8: &[u8; 4usize] = b\"hhd\\0\";\n+pub const SCNdFAST16: &[u8; 3usize] = b\"ld\\0\";\n+pub const SCNdFAST32: &[u8; 3usize] = b\"ld\\0\";\n+pub const SCNdFAST64: &[u8; 3usize] = b\"ld\\0\";\n+pub const SCNi8: &[u8; 4usize] = b\"hhi\\0\";\n+pub const SCNi16: &[u8; 3usize] = b\"hi\\0\";\n+pub const SCNi32: &[u8; 2usize] = b\"i\\0\";\n+pub const SCNi64: &[u8; 3usize] = b\"li\\0\";\n+pub const SCNiLEAST8: &[u8; 4usize] = b\"hhi\\0\";\n+pub const SCNiLEAST16: &[u8; 3usize] = b\"hi\\0\";\n+pub const SCNiLEAST32: &[u8; 2usize] = b\"i\\0\";\n+pub const SCNiLEAST64: &[u8; 3usize] = b\"li\\0\";\n+pub const SCNiFAST8: &[u8; 4usize] = b\"hhi\\0\";\n+pub const SCNiFAST16: &[u8; 3usize] = b\"li\\0\";\n+pub const SCNiFAST32: &[u8; 3usize] = b\"li\\0\";\n+pub const SCNiFAST64: &[u8; 3usize] = b\"li\\0\";\n+pub const SCNu8: &[u8; 4usize] = b\"hhu\\0\";\n+pub const SCNu16: &[u8; 3usize] = b\"hu\\0\";\n+pub const SCNu32: &[u8; 2usize] = b\"u\\0\";\n+pub const SCNu64: &[u8; 3usize] = b\"lu\\0\";\n+pub const SCNuLEAST8: &[u8; 4usize] = b\"hhu\\0\";\n+pub const SCNuLEAST16: &[u8; 3usize] = b\"hu\\0\";\n+pub const SCNuLEAST32: &[u8; 2usize] = b\"u\\0\";\n+pub const SCNuLEAST64: &[u8; 3usize] = b\"lu\\0\";\n+pub const SCNuFAST8: &[u8; 4usize] = b\"hhu\\0\";\n+pub const SCNuFAST16: &[u8; 3usize] = b\"lu\\0\";\n+pub const SCNuFAST32: &[u8; 3usize] = b\"lu\\0\";\n+pub const SCNuFAST64: &[u8; 3usize] = b\"lu\\0\";\n+pub const SCNo8: &[u8; 4usize] = b\"hho\\0\";\n+pub const SCNo16: &[u8; 3usize] = b\"ho\\0\";\n+pub const SCNo32: &[u8; 2usize] = b\"o\\0\";\n+pub const SCNo64: &[u8; 3usize] = b\"lo\\0\";\n+pub const SCNoLEAST8: &[u8; 4usize] = b\"hho\\0\";\n+pub const SCNoLEAST16: &[u8; 3usize] = b\"ho\\0\";\n+pub const SCNoLEAST32: &[u8; 2usize] = b\"o\\0\";\n+pub const SCNoLEAST64: &[u8; 3usize] = b\"lo\\0\";\n+pub const SCNoFAST8: &[u8; 4usize] = b\"hho\\0\";\n+pub const SCNoFAST16: &[u8; 3usize] = b\"lo\\0\";\n+pub const SCNoFAST32: &[u8; 3usize] = b\"lo\\0\";\n+pub const SCNoFAST64: &[u8; 3usize] = b\"lo\\0\";\n+pub const SCNx8: &[u8; 4usize] = b\"hhx\\0\";\n+pub const SCNx16: &[u8; 3usize] = b\"hx\\0\";\n+pub const SCNx32: &[u8; 2usize] = b\"x\\0\";\n+pub const SCNx64: &[u8; 3usize] = b\"lx\\0\";\n+pub const SCNxLEAST8: &[u8; 4usize] = b\"hhx\\0\";\n+pub const SCNxLEAST16: &[u8; 3usize] = b\"hx\\0\";\n+pub const SCNxLEAST32: &[u8; 2usize] = b\"x\\0\";\n+pub const SCNxLEAST64: &[u8; 3usize] = b\"lx\\0\";\n+pub const SCNxFAST8: &[u8; 4usize] = b\"hhx\\0\";\n+pub const SCNxFAST16: &[u8; 3usize] = b\"lx\\0\";\n+pub const SCNxFAST32: &[u8; 3usize] = b\"lx\\0\";\n+pub const SCNxFAST64: &[u8; 3usize] = b\"lx\\0\";\n+pub const SCNdMAX: &[u8; 3usize] = b\"ld\\0\";\n+pub const SCNiMAX: &[u8; 3usize] = b\"li\\0\";\n+pub const SCNoMAX: &[u8; 3usize] = b\"lo\\0\";\n+pub const SCNuMAX: &[u8; 3usize] = b\"lu\\0\";\n+pub const SCNxMAX: &[u8; 3usize] = b\"lx\\0\";\n+pub const SCNdPTR: &[u8; 3usize] = b\"ld\\0\";\n+pub const SCNiPTR: &[u8; 3usize] = b\"li\\0\";\n+pub const SCNoPTR: &[u8; 3usize] = b\"lo\\0\";\n+pub const SCNuPTR: &[u8; 3usize] = b\"lu\\0\";\n+pub const SCNxPTR: &[u8; 3usize] = b\"lx\\0\";\n+pub const DEBUG_BALLOC: u32 = 1;\n+pub const DEBUG_BCACHE: u32 = 2;\n+pub const DEBUG_BITMAP: u32 = 4;\n+pub const DEBUG_BLOCK_GROUP: u32 = 8;\n+pub const DEBUG_BLOCKDEV: u32 = 16;\n+pub const DEBUG_DIR_IDX: u32 = 32;\n+pub const DEBUG_DIR: u32 = 64;\n+pub const DEBUG_EXTENT: u32 = 128;\n+pub const DEBUG_FS: u32 = 256;\n+pub const DEBUG_HASH: u32 = 512;\n+pub const DEBUG_IALLOC: u32 = 1024;\n+pub const DEBUG_INODE: u32 = 2048;\n+pub const DEBUG_SUPER: u32 = 4096;\n+pub const DEBUG_XATTR: u32 = 8192;\n+pub const DEBUG_MKFS: u32 = 16384;\n+pub const DEBUG_EXT4: u32 = 32768;\n+pub const DEBUG_JBD: u32 = 65536;\n+pub const DEBUG_MBR: u32 = 131072;\n+pub const DEBUG_NOPREFIX: u32 = 2147483648;\n+pub const DEBUG_ALL: u32 = 4294967295;\n+pub const DBG_NONE: &[u8; 1usize] = b\"\\0\";\n+pub const DBG_INFO: &[u8; 9usize] = b\"[info]  \\0\";\n+pub const DBG_WARN: &[u8; 9usize] = b\"[warn]  \\0\";\n+pub const DBG_ERROR: &[u8; 9usize] = b\"[error] \\0\";\n+pub const _STDIO_H: u32 = 1;\n+pub const __GNUC_VA_LIST: u32 = 1;\n+pub const _____fpos_t_defined: u32 = 1;\n+pub const ____mbstate_t_defined: u32 = 1;\n+pub const _____fpos64_t_defined: u32 = 1;\n+pub const ____FILE_defined: u32 = 1;\n+pub const __FILE_defined: u32 = 1;\n+pub const __struct_FILE_defined: u32 = 1;\n+pub const _IO_EOF_SEEN: u32 = 16;\n+pub const _IO_ERR_SEEN: u32 = 32;\n+pub const _IO_USER_LOCK: u32 = 32768;\n+pub const _IOFBF: u32 = 0;\n+pub const _IOLBF: u32 = 1;\n+pub const _IONBF: u32 = 2;\n+pub const BUFSIZ: u32 = 8192;\n+pub const EOF: i32 = -1;\n+pub const P_tmpdir: &[u8; 5usize] = b\"/tmp\\0\";\n+pub const _BITS_STDIO_LIM_H: u32 = 1;\n+pub const L_tmpnam: u32 = 20;\n+pub const TMP_MAX: u32 = 238328;\n+pub const FILENAME_MAX: u32 = 4096;\n+pub const L_ctermid: u32 = 9;\n+pub const FOPEN_MAX: u32 = 16;\n+pub const __HAVE_FLOAT128: u32 = 0;\n+pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;\n+pub const __HAVE_FLOAT64X: u32 = 1;\n+pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;\n+pub const __HAVE_FLOAT16: u32 = 0;\n+pub const __HAVE_FLOAT32: u32 = 1;\n+pub const __HAVE_FLOAT64: u32 = 1;\n+pub const __HAVE_FLOAT32X: u32 = 1;\n+pub const __HAVE_FLOAT128X: u32 = 0;\n+pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;\n+pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;\n+pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;\n+pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;\n+pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;\n+pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;\n+pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;\n+pub type __u_char = ::core::ffi::c_uchar;\n+pub type __u_short = ::core::ffi::c_ushort;\n+pub type __u_int = ::core::ffi::c_uint;\n+pub type __u_long = ::core::ffi::c_ulong;\n+pub type __int8_t = ::core::ffi::c_schar;\n+pub type __uint8_t = ::core::ffi::c_uchar;\n+pub type __int16_t = ::core::ffi::c_short;\n+pub type __uint16_t = ::core::ffi::c_ushort;\n+pub type __int32_t = ::core::ffi::c_int;\n+pub type __uint32_t = ::core::ffi::c_uint;\n+pub type __int64_t = ::core::ffi::c_long;\n+pub type __uint64_t = ::core::ffi::c_ulong;\n+pub type __int_least8_t = __int8_t;\n+pub type __uint_least8_t = __uint8_t;\n+pub type __int_least16_t = __int16_t;\n+pub type __uint_least16_t = __uint16_t;\n+pub type __int_least32_t = __int32_t;\n+pub type __uint_least32_t = __uint32_t;\n+pub type __int_least64_t = __int64_t;\n+pub type __uint_least64_t = __uint64_t;\n+pub type __quad_t = ::core::ffi::c_long;\n+pub type __u_quad_t = ::core::ffi::c_ulong;\n+pub type __intmax_t = ::core::ffi::c_long;\n+pub type __uintmax_t = ::core::ffi::c_ulong;\n+pub type __dev_t = ::core::ffi::c_ulong;\n+pub type __uid_t = ::core::ffi::c_uint;\n+pub type __gid_t = ::core::ffi::c_uint;\n+pub type __ino_t = ::core::ffi::c_ulong;\n+pub type __ino64_t = ::core::ffi::c_ulong;\n+pub type __mode_t = ::core::ffi::c_uint;\n+pub type __nlink_t = ::core::ffi::c_ulong;\n+pub type __off_t = ::core::ffi::c_long;\n+pub type __off64_t = ::core::ffi::c_long;\n+pub type __pid_t = ::core::ffi::c_int;\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct __fsid_t {\n+    pub __val: [::core::ffi::c_int; 2usize],\n+}\n+pub type __clock_t = ::core::ffi::c_long;\n+pub type __rlim_t = ::core::ffi::c_ulong;\n+pub type __rlim64_t = ::core::ffi::c_ulong;\n+pub type __id_t = ::core::ffi::c_uint;\n+pub type __time_t = ::core::ffi::c_long;\n+pub type __useconds_t = ::core::ffi::c_uint;\n+pub type __suseconds_t = ::core::ffi::c_long;\n+pub type __suseconds64_t = ::core::ffi::c_long;\n+pub type __daddr_t = ::core::ffi::c_int;\n+pub type __key_t = ::core::ffi::c_int;\n+pub type __clockid_t = ::core::ffi::c_int;\n+pub type __timer_t = *mut ::core::ffi::c_void;\n+pub type __blksize_t = ::core::ffi::c_long;\n+pub type __blkcnt_t = ::core::ffi::c_long;\n+pub type __blkcnt64_t = ::core::ffi::c_long;\n+pub type __fsblkcnt_t = ::core::ffi::c_ulong;\n+pub type __fsblkcnt64_t = ::core::ffi::c_ulong;\n+pub type __fsfilcnt_t = ::core::ffi::c_ulong;\n+pub type __fsfilcnt64_t = ::core::ffi::c_ulong;\n+pub type __fsword_t = ::core::ffi::c_long;\n+pub type __ssize_t = ::core::ffi::c_long;\n+pub type __syscall_slong_t = ::core::ffi::c_long;\n+pub type __syscall_ulong_t = ::core::ffi::c_ulong;\n+pub type __loff_t = __off64_t;\n+pub type __caddr_t = *mut ::core::ffi::c_char;\n+pub type __intptr_t = ::core::ffi::c_long;\n+pub type __socklen_t = ::core::ffi::c_uint;\n+pub type __sig_atomic_t = ::core::ffi::c_int;\n+pub type int_least8_t = __int_least8_t;\n+pub type int_least16_t = __int_least16_t;\n+pub type int_least32_t = __int_least32_t;\n+pub type int_least64_t = __int_least64_t;\n+pub type uint_least8_t = __uint_least8_t;\n+pub type uint_least16_t = __uint_least16_t;\n+pub type uint_least32_t = __uint_least32_t;\n+pub type uint_least64_t = __uint_least64_t;\n+pub type int_fast8_t = ::core::ffi::c_schar;\n+pub type int_fast16_t = ::core::ffi::c_long;\n+pub type int_fast32_t = ::core::ffi::c_long;\n+pub type int_fast64_t = ::core::ffi::c_long;\n+pub type uint_fast8_t = ::core::ffi::c_uchar;\n+pub type uint_fast16_t = ::core::ffi::c_ulong;\n+pub type uint_fast32_t = ::core::ffi::c_ulong;\n+pub type uint_fast64_t = ::core::ffi::c_ulong;\n+pub type intmax_t = __intmax_t;\n+pub type uintmax_t = __uintmax_t;\n+pub type wchar_t = ::core::ffi::c_int;\n+#[repr(C)]\n+#[repr(align(16))]\n+#[derive(Debug, Copy, Clone)]\n+pub struct max_align_t {\n+    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,\n+    pub __bindgen_padding_0: u64,\n+    pub __clang_max_align_nonce2: u128,\n+}\n+#[doc = \"@brief   Single block descriptor\"]\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_block {\n+    #[doc = \"@brief   Logical block ID\"]\n+    pub lb_id: u64,\n+    #[doc = \"@brief   Buffer\"]\n+    pub buf: *mut ext4_buf,\n+    #[doc = \"@brief   Data buffer.\"]\n+    pub data: *mut u8,\n+}\n+#[doc = \"@brief   Single block descriptor\"]\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_buf {\n+    #[doc = \"@brief   Flags\"]\n+    pub flags: ::core::ffi::c_int,\n+    #[doc = \"@brief   Logical block address\"]\n+    pub lba: u64,\n+    #[doc = \"@brief   Data buffer.\"]\n+    pub data: *mut u8,\n+    #[doc = \"@brief   LRU priority. (unused)\"]\n+    pub lru_prio: u32,\n+    #[doc = \"@brief   LRU id.\"]\n+    pub lru_id: u32,\n+    #[doc = \"@brief   Reference count table\"]\n+    pub refctr: u32,\n+    #[doc = \"@brief   The block cache this buffer belongs to.\"]\n+    pub bc: *mut ext4_bcache,\n+    #[doc = \"@brief   Whether or not buffer is on dirty list.\"]\n+    pub on_dirty_list: bool,\n+    #[doc = \"@brief   LBA tree node\"]\n+    pub lba_node: ext4_buf__bindgen_ty_1,\n+    #[doc = \"@brief   LRU tree node\"]\n+    pub lru_node: ext4_buf__bindgen_ty_2,\n+    #[doc = \"@brief   Dirty list node\"]\n+    pub dirty_node: ext4_buf__bindgen_ty_3,\n+    #[doc = \"@brief   Callback routine after a disk-write operation.\\n @param   bc block cache descriptor\\n @param   buf buffer descriptor\\n @param   standard error code returned by bdev->bwrite()\\n @param   arg argument passed to this routine\"]\n+    pub end_write: ::core::option::Option<\n+        unsafe extern \"C\" fn(\n+            bc: *mut ext4_bcache,\n+            buf: *mut ext4_buf,\n+            res: ::core::ffi::c_int,\n+            arg: *mut ::core::ffi::c_void,\n+        ),\n+    >,\n+    #[doc = \"@brief   argument passed to end_write() callback.\"]\n+    pub end_write_arg: *mut ::core::ffi::c_void,\n+}\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_buf__bindgen_ty_1 {\n+    pub rbe_left: *mut ext4_buf,\n+    pub rbe_right: *mut ext4_buf,\n+    pub rbe_parent: *mut ext4_buf,\n+    pub rbe_color: ::core::ffi::c_int,\n+}\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_buf__bindgen_ty_2 {\n+    pub rbe_left: *mut ext4_buf,\n+    pub rbe_right: *mut ext4_buf,\n+    pub rbe_parent: *mut ext4_buf,\n+    pub rbe_color: ::core::ffi::c_int,\n+}\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_buf__bindgen_ty_3 {\n+    pub sle_next: *mut ext4_buf,\n+}\n+#[doc = \"@brief   Block cache descriptor\"]\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_bcache {\n+    #[doc = \"@brief   Item count in block cache\"]\n+    pub cnt: u32,\n+    #[doc = \"@brief   Item size in block cache\"]\n+    pub itemsize: u32,\n+    #[doc = \"@brief   Last recently used counter\"]\n+    pub lru_ctr: u32,\n+    #[doc = \"@brief   Currently referenced datablocks\"]\n+    pub ref_blocks: u32,\n+    #[doc = \"@brief   Maximum referenced datablocks\"]\n+    pub max_ref_blocks: u32,\n+    #[doc = \"@brief   The blockdev binded to this block cache\"]\n+    pub bdev: *mut ext4_blockdev,\n+    #[doc = \"@brief   The cache should not be shaked\"]\n+    pub dont_shake: bool,\n+    #[doc = \"@brief   A tree holding all bufs\"]\n+    pub lba_root: ext4_bcache_ext4_buf_lba,\n+    #[doc = \"@brief   A tree holding unreferenced bufs\"]\n+    pub lru_root: ext4_bcache_ext4_buf_lru,\n+    #[doc = \"@brief   A singly-linked list holding dirty buffers\"]\n+    pub dirty_list: ext4_bcache_ext4_buf_dirty,\n+}\n+#[doc = \"@brief   A tree holding all bufs\"]\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_bcache_ext4_buf_lba {\n+    pub rbh_root: *mut ext4_buf,\n+}\n+#[doc = \"@brief   A tree holding unreferenced bufs\"]\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_bcache_ext4_buf_lru {\n+    pub rbh_root: *mut ext4_buf,\n+}\n+#[doc = \"@brief   A singly-linked list holding dirty buffers\"]\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_bcache_ext4_buf_dirty {\n+    pub slh_first: *mut ext4_buf,\n+}\n+pub const bcache_state_bits_BC_UPTODATE: bcache_state_bits = 0;\n+pub const bcache_state_bits_BC_DIRTY: bcache_state_bits = 1;\n+pub const bcache_state_bits_BC_FLUSH: bcache_state_bits = 2;\n+pub const bcache_state_bits_BC_TMP: bcache_state_bits = 3;\n+#[doc = \"@brief buffer state bits\\n\\n  - BC♡UPTODATE: Buffer contains valid data.\\n  - BC_DIRTY: Buffer is dirty.\\n  - BC_FLUSH: Buffer will be immediately flushed,\\n              when no one references it.\\n  - BC_TMP: Buffer will be dropped once its refctr\\n            reaches zero.\"]\n+pub type bcache_state_bits = ::core::ffi::c_uint;\n+extern \"C\" {\n+    #[doc = \"@brief   Dynamic initialization of block cache.\\n @param   bc block cache descriptor\\n @param   cnt items count in block cache\\n @param   itemsize single item size (in bytes)\\n @return  standard error code\"]\n+    pub fn ext4_bcache_init_dynamic(\n+        bc: *mut ext4_bcache,\n+        cnt: u32,\n+        itemsize: u32,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Do cleanup works on block cache.\\n @param   bc block cache descriptor.\"]\n+    pub fn ext4_bcache_cleanup(bc: *mut ext4_bcache);\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Dynamic de-initialization of block cache.\\n @param   bc block cache descriptor\\n @return  standard error code\"]\n+    pub fn ext4_bcache_fini_dynamic(bc: *mut ext4_bcache) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Get a buffer with the lowest LRU counter in bcache.\\n @param   bc block cache descriptor\\n @return  buffer with the lowest LRU counter\"]\n+    pub fn ext4_buf_lowest_lru(bc: *mut ext4_bcache) -> *mut ext4_buf;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Drop unreferenced buffer from bcache.\\n @param   bc block cache descriptor\\n @param   buf buffer\"]\n+    pub fn ext4_bcache_drop_buf(bc: *mut ext4_bcache, buf: *mut ext4_buf);\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Invalidate a buffer.\\n @param   bc block cache descriptor\\n @param   buf buffer\"]\n+    pub fn ext4_bcache_invalidate_buf(bc: *mut ext4_bcache, buf: *mut ext4_buf);\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Invalidate a range of buffers.\\n @param   bc block cache descriptor\\n @param   from starting lba\\n @param   cnt block counts\"]\n+    pub fn ext4_bcache_invalidate_lba(bc: *mut ext4_bcache, from: u64, cnt: u32);\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Find existing buffer from block cache memory.\\n          Unreferenced block allocation is based on LRU\\n          (Last Recently Used) algorithm.\\n @param   bc block cache descriptor\\n @param   b block to alloc\\n @param   lba logical block address\\n @return  block cache buffer\"]\n+    pub fn ext4_bcache_find_get(\n+        bc: *mut ext4_bcache,\n+        b: *mut ext4_block,\n+        lba: u64,\n+    ) -> *mut ext4_buf;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Allocate block from block cache memory.\\n          Unreferenced block allocation is based on LRU\\n          (Last Recently Used) algorithm.\\n @param   bc block cache descriptor\\n @param   b block to alloc\\n @param   is_new block is new (needs to be read)\\n @return  standard error code\"]\n+    pub fn ext4_bcache_alloc(\n+        bc: *mut ext4_bcache,\n+        b: *mut ext4_block,\n+        is_new: *mut bool,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Free block from cache memory (decrement reference counter).\\n @param   bc block cache descriptor\\n @param   b block to free\\n @return  standard error code\"]\n+    pub fn ext4_bcache_free(bc: *mut ext4_bcache, b: *mut ext4_block) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Return a full status of block cache.\\n @param   bc block cache descriptor\\n @return  full status\"]\n+    pub fn ext4_bcache_is_full(bc: *mut ext4_bcache) -> bool;\n+}\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_blockdev_iface {\n+    #[doc = \"@brief   Open device function\\n @param   bdev block device.\"]\n+    pub open: ::core::option::Option<\n+        unsafe extern \"C\" fn(bdev: *mut ext4_blockdev) -> ::core::ffi::c_int,\n+    >,\n+    #[doc = \"@brief   Block read function.\\n @param   bdev block device\\n @param   buf output buffer\\n @param   blk_id block id\\n @param   blk_cnt block count\"]\n+    pub bread: ::core::option::Option<\n+        unsafe extern \"C\" fn(\n+            bdev: *mut ext4_blockdev,\n+            buf: *mut ::core::ffi::c_void,\n+            blk_id: u64,\n+            blk_cnt: u32,\n+        ) -> ::core::ffi::c_int,\n+    >,\n+    #[doc = \"@brief   Block write function.\\n @param   buf input buffer\\n @param   blk_id block id\\n @param   blk_cnt block count\"]\n+    pub bwrite: ::core::option::Option<\n+        unsafe extern \"C\" fn(\n+            bdev: *mut ext4_blockdev,\n+            buf: *const ::core::ffi::c_void,\n+            blk_id: u64,\n+            blk_cnt: u32,\n+        ) -> ::core::ffi::c_int,\n+    >,\n+    #[doc = \"@brief   Close device function.\\n @param   bdev block device.\"]\n+    pub close: ::core::option::Option<\n+        unsafe extern \"C\" fn(bdev: *mut ext4_blockdev) -> ::core::ffi::c_int,\n+    >,\n+    #[doc = \"@brief   Lock block device. Required in multi partition mode\\n          operations. Not mandatory field.\\n @param   bdev block device.\"]\n+    pub lock: ::core::option::Option<\n+        unsafe extern \"C\" fn(bdev: *mut ext4_blockdev) -> ::core::ffi::c_int,\n+    >,\n+    #[doc = \"@brief   Unlock block device. Required in multi partition mode\\n          operations. Not mandatory field.\\n @param   bdev block device.\"]\n+    pub unlock: ::core::option::Option<\n+        unsafe extern \"C\" fn(bdev: *mut ext4_blockdev) -> ::core::ffi::c_int,\n+    >,\n+    #[doc = \"@brief   Block size (bytes): physical\"]\n+    pub ph_bsize: u32,\n+    #[doc = \"@brief   Block count: physical\"]\n+    pub ph_bcnt: u64,\n+    #[doc = \"@brief   Block size buffer: physical\"]\n+    pub ph_bbuf: *mut u8,\n+    #[doc = \"@brief   Reference counter to block device interface\"]\n+    pub ph_refctr: u32,\n+    #[doc = \"@brief   Physical read counter\"]\n+    pub bread_ctr: u32,\n+    #[doc = \"@brief   Physical write counter\"]\n+    pub bwrite_ctr: u32,\n+    #[doc = \"@brief   User data pointer\"]\n+    pub p_user: *mut ::core::ffi::c_void,\n+}\n+#[doc = \"@brief   Definition of the simple block device.\"]\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_blockdev {\n+    #[doc = \"@brief Block device interface\"]\n+    pub bdif: *mut ext4_blockdev_iface,\n+    #[doc = \"@brief Offset in bdif. For multi partition mode.\"]\n+    pub part_offset: u64,\n+    #[doc = \"@brief Part size in bdif. For multi partition mode.\"]\n+    pub part_size: u64,\n+    #[doc = \"@brief   Block cache.\"]\n+    pub bc: *mut ext4_bcache,\n+    #[doc = \"@brief   Block size (bytes) logical\"]\n+    pub lg_bsize: u32,\n+    #[doc = \"@brief   Block count: logical\"]\n+    pub lg_bcnt: u64,\n+    #[doc = \"@brief   Cache write back mode reference counter\"]\n+    pub cache_write_back: u32,\n+    #[doc = \"@brief   The filesystem this block device belongs to.\"]\n+    pub fs: *mut ext4_fs,\n+    pub journal: *mut ::core::ffi::c_void,\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Block device initialization.\\n @param   bdev block device descriptor\\n @return  standard error code\"]\n+    pub fn ext4_block_init(bdev: *mut ext4_blockdev) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Binds a bcache to block device.\\n @param   bdev block device descriptor\\n @param   bc block cache descriptor\\n @return  standard error code\"]\n+    pub fn ext4_block_bind_bcache(\n+        bdev: *mut ext4_blockdev,\n+        bc: *mut ext4_bcache,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Close block device\\n @param   bdev block device descriptor\\n @return  standard error code\"]\n+    pub fn ext4_block_fini(bdev: *mut ext4_blockdev) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Flush data in given buffer to disk.\\n @param   bdev block device descriptor\\n @param   buf buffer\\n @return  standard error code\"]\n+    pub fn ext4_block_flush_buf(bdev: *mut ext4_blockdev, buf: *mut ext4_buf)\n+        -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Flush data in buffer of given lba to disk,\\n          if that buffer exists in block cache.\\n @param   bdev block device descriptor\\n @param   lba logical block address\\n @return  standard error code\"]\n+    pub fn ext4_block_flush_lba(bdev: *mut ext4_blockdev, lba: u64) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Set logical block size in block device.\\n @param   bdev block device descriptor\\n @param   lb_bsize logical block size (in bytes)\"]\n+    pub fn ext4_block_set_lb_size(bdev: *mut ext4_blockdev, lb_bsize: u32);\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Block get function (through cache, don't read).\\n @param   bdev block device descriptor\\n @param   b block descriptor\\n @param   lba logical block address\\n @return  standard error code\"]\n+    pub fn ext4_block_get_noread(\n+        bdev: *mut ext4_blockdev,\n+        b: *mut ext4_block,\n+        lba: u64,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Block get function (through cache).\\n @param   bdev block device descriptor\\n @param   b block descriptor\\n @param   lba logical block address\\n @return  standard error code\"]\n+    pub fn ext4_block_get(\n+        bdev: *mut ext4_blockdev,\n+        b: *mut ext4_block,\n+        lba: u64,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Block set procedure (through cache).\\n @param   bdev block device descriptor\\n @param   b block descriptor\\n @return  standard error code\"]\n+    pub fn ext4_block_set(bdev: *mut ext4_blockdev, b: *mut ext4_block) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Block read procedure (without cache)\\n @param   bdev block device descriptor\\n @param   buf output buffer\\n @param   lba logical block address\\n @return  standard error code\"]\n+    pub fn ext4_blocks_get_direct(\n+        bdev: *mut ext4_blockdev,\n+        buf: *mut ::core::ffi::c_void,\n+        lba: u64,\n+        cnt: u32,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Block write procedure (without cache)\\n @param   bdev block device descriptor\\n @param   buf output buffer\\n @param   lba logical block address\\n @return  standard error code\"]\n+    pub fn ext4_blocks_set_direct(\n+        bdev: *mut ext4_blockdev,\n+        buf: *const ::core::ffi::c_void,\n+        lba: u64,\n+        cnt: u32,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Write to block device (by direct address).\\n @param   bdev block device descriptor\\n @param   off byte offset in block device\\n @param   buf input buffer\\n @param   len length of the write buffer\\n @return  standard error code\"]\n+    pub fn ext4_block_writebytes(\n+        bdev: *mut ext4_blockdev,\n+        off: u64,\n+        buf: *const ::core::ffi::c_void,\n+        len: u32,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Read freom block device (by direct address).\\n @param   bdev block device descriptor\\n @param   off byte offset in block device\\n @param   buf input buffer\\n @param   len length of the write buffer\\n @return  standard error code\"]\n+    pub fn ext4_block_readbytes(\n+        bdev: *mut ext4_blockdev,\n+        off: u64,\n+        buf: *mut ::core::ffi::c_void,\n+        len: u32,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Flush all dirty buffers to disk\\n @param   bdev block device descriptor\\n @return  standard error code\"]\n+    pub fn ext4_block_cache_flush(bdev: *mut ext4_blockdev) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Enable/disable write back cache mode\\n @param   bdev block device descriptor\\n @param   on_off\\n              !0 - ENABLE\\n               0 - DISABLE (all delayed cache buffers will be flushed)\\n @return  standard error code\"]\n+    pub fn ext4_block_cache_write_back(bdev: *mut ext4_blockdev, on_off: u8) -> ::core::ffi::c_int;\n+}\n+pub type ext4_lblk_t = u32;\n+pub type ext4_fsblk_t = u64;\n+#[repr(C, packed)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_sblock {\n+    pub inodes_count: u32,\n+    pub blocks_count_lo: u32,\n+    pub reserved_blocks_count_lo: u32,\n+    pub free_blocks_count_lo: u32,\n+    pub free_inodes_count: u32,\n+    pub first_data_block: u32,\n+    pub log_block_size: u32,\n+    pub log_cluster_size: u32,\n+    pub blocks_per_group: u32,\n+    pub frags_per_group: u32,\n+    pub inodes_per_group: u32,\n+    pub mount_time: u32,\n+    pub write_time: u32,\n+    pub mount_count: u16,\n+    pub max_mount_count: u16,\n+    pub magic: u16,\n+    pub state: u16,\n+    pub errors: u16,\n+    pub minor_rev_level: u16,\n+    pub last_check_time: u32,\n+    pub check_interval: u32,\n+    pub creator_os: u32,\n+    pub rev_level: u32,\n+    pub def_resuid: u16,\n+    pub def_resgid: u16,\n+    pub first_inode: u32,\n+    pub inode_size: u16,\n+    pub block_group_index: u16,\n+    pub features_compatible: u32,\n+    pub features_incompatible: u32,\n+    pub features_read_only: u32,\n+    pub uuid: [u8; 16usize],\n+    pub volume_name: [::core::ffi::c_char; 16usize],\n+    pub last_mounted: [::core::ffi::c_char; 64usize],\n+    pub algorithm_usage_bitmap: u32,\n+    pub s_prealloc_blocks: u8,\n+    pub s_prealloc_dir_blocks: u8,\n+    pub s_reserved_gdt_blocks: u16,\n+    pub journal_uuid: [u8; 16usize],\n+    pub journal_inode_number: u32,\n+    pub journal_dev: u32,\n+    pub last_orphan: u32,\n+    pub hash_seed: [u32; 4usize],\n+    pub default_hash_version: u8,\n+    pub journal_backup_type: u8,\n+    pub desc_size: u16,\n+    pub default_mount_opts: u32,\n+    pub first_meta_bg: u32,\n+    pub mkfs_time: u32,\n+    pub journal_blocks: [u32; 17usize],\n+    pub blocks_count_hi: u32,\n+    pub reserved_blocks_count_hi: u32,\n+    pub free_blocks_count_hi: u32,\n+    pub min_extra_isize: u16,\n+    pub want_extra_isize: u16,\n+    pub flags: u32,\n+    pub raid_stride: u16,\n+    pub mmp_interval: u16,\n+    pub mmp_block: u64,\n+    pub raid_stripe_width: u32,\n+    pub log_groups_per_flex: u8,\n+    pub checksum_type: u8,\n+    pub reserved_pad: u16,\n+    pub kbytes_written: u64,\n+    pub snapshot_inum: u32,\n+    pub snapshot_id: u32,\n+    pub snapshot_r_blocks_count: u64,\n+    pub snapshot_list: u32,\n+    pub error_count: u32,\n+    pub first_error_time: u32,\n+    pub first_error_ino: u32,\n+    pub first_error_block: u64,\n+    pub first_error_func: [u8; 32usize],\n+    pub first_error_line: u32,\n+    pub last_error_time: u32,\n+    pub last_error_ino: u32,\n+    pub last_error_line: u32,\n+    pub last_error_block: u64,\n+    pub last_error_func: [u8; 32usize],\n+    pub mount_opts: [u8; 64usize],\n+    pub usr_quota_inum: u32,\n+    pub grp_quota_inum: u32,\n+    pub overhead_clusters: u32,\n+    pub backup_bgs: [u32; 2usize],\n+    pub encrypt_algos: [u8; 4usize],\n+    pub encrypt_pw_salt: [u8; 16usize],\n+    pub lpf_ino: u32,\n+    pub padding: [u32; 100usize],\n+    pub checksum: u32,\n+}\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_bgroup {\n+    pub block_bitmap_lo: u32,\n+    pub inode_bitmap_lo: u32,\n+    pub inode_table_first_block_lo: u32,\n+    pub free_blocks_count_lo: u16,\n+    pub free_inodes_count_lo: u16,\n+    pub used_dirs_count_lo: u16,\n+    pub flags: u16,\n+    pub exclude_bitmap_lo: u32,\n+    pub block_bitmap_csum_lo: u16,\n+    pub inode_bitmap_csum_lo: u16,\n+    pub itable_unused_lo: u16,\n+    pub checksum: u16,\n+    pub block_bitmap_hi: u32,\n+    pub inode_bitmap_hi: u32,\n+    pub inode_table_first_block_hi: u32,\n+    pub free_blocks_count_hi: u16,\n+    pub free_inodes_count_hi: u16,\n+    pub used_dirs_count_hi: u16,\n+    pub itable_unused_hi: u16,\n+    pub exclude_bitmap_hi: u32,\n+    pub block_bitmap_csum_hi: u16,\n+    pub inode_bitmap_csum_hi: u16,\n+    pub reserved: u32,\n+}\n+#[repr(C, packed)]\n+#[derive(Copy, Clone)]\n+pub struct ext4_inode {\n+    pub mode: u16,\n+    pub uid: u16,\n+    pub size_lo: u32,\n+    pub access_time: u32,\n+    pub change_inode_time: u32,\n+    pub modification_time: u32,\n+    pub deletion_time: u32,\n+    pub gid: u16,\n+    pub links_count: u16,\n+    pub blocks_count_lo: u32,\n+    pub flags: u32,\n+    pub unused_osd1: u32,\n+    pub blocks: [u32; 15usize],\n+    pub generation: u32,\n+    pub file_acl_lo: u32,\n+    pub size_hi: u32,\n+    pub obso_faddr: u32,\n+    pub osd2: ext4_inode__bindgen_ty_1,\n+    pub extra_isize: u16,\n+    pub checksum_hi: u16,\n+    pub ctime_extra: u32,\n+    pub mtime_extra: u32,\n+    pub atime_extra: u32,\n+    pub crtime: u32,\n+    pub crtime_extra: u32,\n+    pub version_hi: u32,\n+}\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub union ext4_inode__bindgen_ty_1 {\n+    pub linux2: ext4_inode__bindgen_ty_1__bindgen_ty_1,\n+    pub hurd2: ext4_inode__bindgen_ty_1__bindgen_ty_2,\n+}\n+#[repr(C, packed)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_inode__bindgen_ty_1__bindgen_ty_1 {\n+    pub blocks_high: u16,\n+    pub file_acl_high: u16,\n+    pub uid_high: u16,\n+    pub gid_high: u16,\n+    pub checksum_lo: u16,\n+    pub reserved2: u16,\n+}\n+#[repr(C, packed)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_inode__bindgen_ty_1__bindgen_ty_2 {\n+    pub reserved1: u16,\n+    pub mode_high: u16,\n+    pub uid_high: u16,\n+    pub gid_high: u16,\n+    pub author: u32,\n+}\n+pub const EXT4_DE_UNKNOWN: _bindgen_ty_1 = 0;\n+pub const EXT4_DE_REG_FILE: _bindgen_ty_1 = 1;\n+pub const EXT4_DE_DIR: _bindgen_ty_1 = 2;\n+pub const EXT4_DE_CHRDEV: _bindgen_ty_1 = 3;\n+pub const EXT4_DE_BLKDEV: _bindgen_ty_1 = 4;\n+pub const EXT4_DE_FIFO: _bindgen_ty_1 = 5;\n+pub const EXT4_DE_SOCK: _bindgen_ty_1 = 6;\n+pub const EXT4_DE_SYMLINK: _bindgen_ty_1 = 7;\n+#[doc = \"@brief   Directory entry types.\"]\n+pub type _bindgen_ty_1 = ::core::ffi::c_uint;\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub union ext4_dir_en_internal {\n+    pub name_length_high: u8,\n+    pub inode_type: u8,\n+}\n+#[doc = \" Linked list directory entry structure\"]\n+#[repr(C, packed)]\n+pub struct ext4_dir_en {\n+    pub inode: u32,\n+    pub entry_len: u16,\n+    pub name_len: u8,\n+    pub in_: ext4_dir_en_internal,\n+    pub name: __IncompleteArrayField<u8>,\n+}\n+#[repr(C, packed)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_dir_idx_climit {\n+    pub limit: u16,\n+    pub count: u16,\n+}\n+#[repr(C, packed)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_dir_idx_dot_en {\n+    pub inode: u32,\n+    pub entry_length: u16,\n+    pub name_length: u8,\n+    pub inode_type: u8,\n+    pub name: [u8; 4usize],\n+}\n+#[repr(C, packed)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_dir_idx_rinfo {\n+    pub reserved_zero: u32,\n+    pub hash_version: u8,\n+    pub info_length: u8,\n+    pub indirect_levels: u8,\n+    pub unused_flags: u8,\n+}\n+#[repr(C, packed)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_dir_idx_entry {\n+    pub hash: u32,\n+    pub block: u32,\n+}\n+#[repr(C)]\n+#[derive(Debug)]\n+pub struct ext4_dir_idx_root {\n+    pub dots: [ext4_dir_idx_dot_en; 2usize],\n+    pub info: ext4_dir_idx_rinfo,\n+    pub en: __IncompleteArrayField<ext4_dir_idx_entry>,\n+}\n+#[repr(C, packed)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_fake_dir_entry {\n+    pub inode: u32,\n+    pub entry_length: u16,\n+    pub name_length: u8,\n+    pub inode_type: u8,\n+}\n+#[repr(C)]\n+#[derive(Debug)]\n+pub struct ext4_dir_idx_node {\n+    pub fake: ext4_fake_dir_entry,\n+    pub entries: __IncompleteArrayField<ext4_dir_idx_entry>,\n+}\n+#[repr(C, packed)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_dir_idx_tail {\n+    pub reserved: u32,\n+    pub checksum: u32,\n+}\n+#[repr(C, packed)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_dir_entry_tail {\n+    pub reserved_zero1: u32,\n+    pub rec_len: u16,\n+    pub reserved_zero2: u8,\n+    pub reserved_ft: u8,\n+    pub checksum: u32,\n+}\n+#[repr(C, packed)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct jbd_bhdr {\n+    pub magic: u32,\n+    pub blocktype: u32,\n+    pub sequence: u32,\n+}\n+#[repr(C, packed)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct jbd_commit_header {\n+    pub header: jbd_bhdr,\n+    pub chksum_type: u8,\n+    pub chksum_size: u8,\n+    pub padding: [u8; 2usize],\n+    pub chksum: [u32; 8usize],\n+    pub commit_sec: u64,\n+    pub commit_nsec: u32,\n+}\n+#[repr(C, packed)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct jbd_block_tag3 {\n+    pub blocknr: u32,\n+    pub flags: u32,\n+    pub blocknr_high: u32,\n+    pub checksum: u32,\n+}\n+#[repr(C, packed)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct jbd_block_tag {\n+    pub blocknr: u32,\n+    pub checksum: u16,\n+    pub flags: u16,\n+    pub blocknr_high: u32,\n+}\n+#[repr(C, packed)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct jbd_block_tail {\n+    pub checksum: u32,\n+}\n+#[repr(C, packed)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct jbd_revoke_header {\n+    pub header: jbd_bhdr,\n+    pub count: u32,\n+}\n+#[repr(C, packed)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct jbd_revoke_tail {\n+    pub checksum: u32,\n+}\n+#[repr(C, packed)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct jbd_sb {\n+    pub header: jbd_bhdr,\n+    pub blocksize: u32,\n+    pub maxlen: u32,\n+    pub first: u32,\n+    pub sequence: u32,\n+    pub start: u32,\n+    pub error_val: i32,\n+    pub feature_compat: u32,\n+    pub feature_incompat: u32,\n+    pub feature_ro_compat: u32,\n+    pub uuid: [u8; 16usize],\n+    pub nr_users: u32,\n+    pub dynsuper: u32,\n+    pub max_transaction: u32,\n+    pub max_trandata: u32,\n+    pub checksum_type: u8,\n+    pub padding2: [u8; 3usize],\n+    pub padding: [u32; 42usize],\n+    pub checksum: u32,\n+    pub users: [u8; 768usize],\n+}\n+pub type __gwchar_t = ::core::ffi::c_int;\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct imaxdiv_t {\n+    pub quot: ::core::ffi::c_long,\n+    pub rem: ::core::ffi::c_long,\n+}\n+extern \"C\" {\n+    pub fn imaxabs(__n: intmax_t) -> intmax_t;\n+}\n+extern \"C\" {\n+    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;\n+}\n+extern \"C\" {\n+    pub fn strtoimax(\n+        __nptr: *const ::core::ffi::c_char,\n+        __endptr: *mut *mut ::core::ffi::c_char,\n+        __base: ::core::ffi::c_int,\n+    ) -> intmax_t;\n+}\n+extern \"C\" {\n+    pub fn strtoumax(\n+        __nptr: *const ::core::ffi::c_char,\n+        __endptr: *mut *mut ::core::ffi::c_char,\n+        __base: ::core::ffi::c_int,\n+    ) -> uintmax_t;\n+}\n+extern \"C\" {\n+    pub fn wcstoimax(\n+        __nptr: *const __gwchar_t,\n+        __endptr: *mut *mut __gwchar_t,\n+        __base: ::core::ffi::c_int,\n+    ) -> intmax_t;\n+}\n+extern \"C\" {\n+    pub fn wcstoumax(\n+        __nptr: *const __gwchar_t,\n+        __endptr: *mut *mut __gwchar_t,\n+        __base: ::core::ffi::c_int,\n+    ) -> uintmax_t;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Global mask debug set.\\n @param   m new debug mask.\"]\n+    pub fn ext4_dmask_set(m: u32);\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Global mask debug clear.\\n @param   m new debug mask.\"]\n+    pub fn ext4_dmask_clr(m: u32);\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Global debug mask get.\\n @return  debug mask\"]\n+    pub fn ext4_dmask_get() -> u32;\n+}\n+pub type va_list = __builtin_va_list;\n+pub type __gnuc_va_list = __builtin_va_list;\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct __mbstate_t {\n+    pub __count: ::core::ffi::c_int,\n+    pub __value: __mbstate_t__bindgen_ty_1,\n+}\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub union __mbstate_t__bindgen_ty_1 {\n+    pub __wch: ::core::ffi::c_uint,\n+    pub __wchb: [::core::ffi::c_char; 4usize],\n+}\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct _G_fpos_t {\n+    pub __pos: __off_t,\n+    pub __state: __mbstate_t,\n+}\n+pub type __fpos_t = _G_fpos_t;\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct _G_fpos64_t {\n+    pub __pos: __off64_t,\n+    pub __state: __mbstate_t,\n+}\n+pub type __fpos64_t = _G_fpos64_t;\n+pub type __FILE = _IO_FILE;\n+pub type FILE = _IO_FILE;\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct _IO_marker {\n+    _unused: [u8; 0],\n+}\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct _IO_codecvt {\n+    _unused: [u8; 0],\n+}\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct _IO_wide_data {\n+    _unused: [u8; 0],\n+}\n+pub type _IO_lock_t = ::core::ffi::c_void;\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct _IO_FILE {\n+    pub _flags: ::core::ffi::c_int,\n+    pub _IO_read_ptr: *mut ::core::ffi::c_char,\n+    pub _IO_read_end: *mut ::core::ffi::c_char,\n+    pub _IO_read_base: *mut ::core::ffi::c_char,\n+    pub _IO_write_base: *mut ::core::ffi::c_char,\n+    pub _IO_write_ptr: *mut ::core::ffi::c_char,\n+    pub _IO_write_end: *mut ::core::ffi::c_char,\n+    pub _IO_buf_base: *mut ::core::ffi::c_char,\n+    pub _IO_buf_end: *mut ::core::ffi::c_char,\n+    pub _IO_save_base: *mut ::core::ffi::c_char,\n+    pub _IO_backup_base: *mut ::core::ffi::c_char,\n+    pub _IO_save_end: *mut ::core::ffi::c_char,\n+    pub _markers: *mut _IO_marker,\n+    pub _chain: *mut _IO_FILE,\n+    pub _fileno: ::core::ffi::c_int,\n+    pub _flags2: ::core::ffi::c_int,\n+    pub _old_offset: __off_t,\n+    pub _cur_column: ::core::ffi::c_ushort,\n+    pub _vtable_offset: ::core::ffi::c_schar,\n+    pub _shortbuf: [::core::ffi::c_char; 1usize],\n+    pub _lock: *mut _IO_lock_t,\n+    pub _offset: __off64_t,\n+    pub _codecvt: *mut _IO_codecvt,\n+    pub _wide_data: *mut _IO_wide_data,\n+    pub _freeres_list: *mut _IO_FILE,\n+    pub _freeres_buf: *mut ::core::ffi::c_void,\n+    pub __pad5: usize,\n+    pub _mode: ::core::ffi::c_int,\n+    pub _unused2: [::core::ffi::c_char; 20usize],\n+}\n+pub type off_t = __off_t;\n+pub type fpos_t = __fpos_t;\n+extern \"C\" {\n+    pub static mut stdin: *mut FILE;\n+}\n+extern \"C\" {\n+    pub static mut stdout: *mut FILE;\n+}\n+extern \"C\" {\n+    pub static mut stderr: *mut FILE;\n+}\n+extern \"C\" {\n+    pub fn remove(__filename: *const ::core::ffi::c_char) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn rename(\n+        __old: *const ::core::ffi::c_char,\n+        __new: *const ::core::ffi::c_char,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn renameat(\n+        __oldfd: ::core::ffi::c_int,\n+        __old: *const ::core::ffi::c_char,\n+        __newfd: ::core::ffi::c_int,\n+        __new: *const ::core::ffi::c_char,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn fclose(__stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn tmpfile() -> *mut FILE;\n+}\n+extern \"C\" {\n+    pub fn tmpnam(arg1: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;\n+}\n+extern \"C\" {\n+    pub fn tmpnam_r(__s: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;\n+}\n+extern \"C\" {\n+    pub fn tempnam(\n+        __dir: *const ::core::ffi::c_char,\n+        __pfx: *const ::core::ffi::c_char,\n+    ) -> *mut ::core::ffi::c_char;\n+}\n+extern \"C\" {\n+    pub fn fflush(__stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn fflush_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn fopen(\n+        __filename: *const ::core::ffi::c_char,\n+        __modes: *const ::core::ffi::c_char,\n+    ) -> *mut FILE;\n+}\n+extern \"C\" {\n+    pub fn freopen(\n+        __filename: *const ::core::ffi::c_char,\n+        __modes: *const ::core::ffi::c_char,\n+        __stream: *mut FILE,\n+    ) -> *mut FILE;\n+}\n+extern \"C\" {\n+    pub fn fdopen(__fd: ::core::ffi::c_int, __modes: *const ::core::ffi::c_char) -> *mut FILE;\n+}\n+extern \"C\" {\n+    pub fn fmemopen(\n+        __s: *mut ::core::ffi::c_void,\n+        __len: usize,\n+        __modes: *const ::core::ffi::c_char,\n+    ) -> *mut FILE;\n+}\n+extern \"C\" {\n+    pub fn open_memstream(\n+        __bufloc: *mut *mut ::core::ffi::c_char,\n+        __sizeloc: *mut usize,\n+    ) -> *mut FILE;\n+}\n+extern \"C\" {\n+    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::core::ffi::c_char);\n+}\n+extern \"C\" {\n+    pub fn setvbuf(\n+        __stream: *mut FILE,\n+        __buf: *mut ::core::ffi::c_char,\n+        __modes: ::core::ffi::c_int,\n+        __n: usize,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::core::ffi::c_char, __size: usize);\n+}\n+extern \"C\" {\n+    pub fn setlinebuf(__stream: *mut FILE);\n+}\n+extern \"C\" {\n+    pub fn fprintf(\n+        __stream: *mut FILE,\n+        __format: *const ::core::ffi::c_char,\n+        ...\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn printf(__format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn sprintf(\n+        __s: *mut ::core::ffi::c_char,\n+        __format: *const ::core::ffi::c_char,\n+        ...\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn vfprintf(\n+        __s: *mut FILE,\n+        __format: *const ::core::ffi::c_char,\n+        __arg: *mut __va_list_tag,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn vprintf(\n+        __format: *const ::core::ffi::c_char,\n+        __arg: *mut __va_list_tag,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn vsprintf(\n+        __s: *mut ::core::ffi::c_char,\n+        __format: *const ::core::ffi::c_char,\n+        __arg: *mut __va_list_tag,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn snprintf(\n+        __s: *mut ::core::ffi::c_char,\n+        __maxlen: ::core::ffi::c_ulong,\n+        __format: *const ::core::ffi::c_char,\n+        ...\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn vsnprintf(\n+        __s: *mut ::core::ffi::c_char,\n+        __maxlen: ::core::ffi::c_ulong,\n+        __format: *const ::core::ffi::c_char,\n+        __arg: *mut __va_list_tag,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn vdprintf(\n+        __fd: ::core::ffi::c_int,\n+        __fmt: *const ::core::ffi::c_char,\n+        __arg: *mut __va_list_tag,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn dprintf(\n+        __fd: ::core::ffi::c_int,\n+        __fmt: *const ::core::ffi::c_char,\n+        ...\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn fscanf(\n+        __stream: *mut FILE,\n+        __format: *const ::core::ffi::c_char,\n+        ...\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn scanf(__format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn sscanf(\n+        __s: *const ::core::ffi::c_char,\n+        __format: *const ::core::ffi::c_char,\n+        ...\n+    ) -> ::core::ffi::c_int;\n+}\n+pub type _Float32 = f32;\n+pub type _Float64 = f64;\n+pub type _Float32x = f64;\n+pub type _Float64x = u128;\n+extern \"C\" {\n+    #[link_name = \"\\u{1}__isoc99_fscanf\"]\n+    pub fn fscanf1(\n+        __stream: *mut FILE,\n+        __format: *const ::core::ffi::c_char,\n+        ...\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[link_name = \"\\u{1}__isoc99_scanf\"]\n+    pub fn scanf1(__format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[link_name = \"\\u{1}__isoc99_sscanf\"]\n+    pub fn sscanf1(\n+        __s: *const ::core::ffi::c_char,\n+        __format: *const ::core::ffi::c_char,\n+        ...\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn vfscanf(\n+        __s: *mut FILE,\n+        __format: *const ::core::ffi::c_char,\n+        __arg: *mut __va_list_tag,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn vscanf(\n+        __format: *const ::core::ffi::c_char,\n+        __arg: *mut __va_list_tag,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn vsscanf(\n+        __s: *const ::core::ffi::c_char,\n+        __format: *const ::core::ffi::c_char,\n+        __arg: *mut __va_list_tag,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[link_name = \"\\u{1}__isoc99_vfscanf\"]\n+    pub fn vfscanf1(\n+        __s: *mut FILE,\n+        __format: *const ::core::ffi::c_char,\n+        __arg: *mut __va_list_tag,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[link_name = \"\\u{1}__isoc99_vscanf\"]\n+    pub fn vscanf1(\n+        __format: *const ::core::ffi::c_char,\n+        __arg: *mut __va_list_tag,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[link_name = \"\\u{1}__isoc99_vsscanf\"]\n+    pub fn vsscanf1(\n+        __s: *const ::core::ffi::c_char,\n+        __format: *const ::core::ffi::c_char,\n+        __arg: *mut __va_list_tag,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn fgetc(__stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn getc(__stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn getchar() -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn getc_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn getchar_unlocked() -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn fputc(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn putc(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn putchar(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn fputc_unlocked(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn putc_unlocked(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn putchar_unlocked(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn getw(__stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn putw(__w: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn fgets(\n+        __s: *mut ::core::ffi::c_char,\n+        __n: ::core::ffi::c_int,\n+        __stream: *mut FILE,\n+    ) -> *mut ::core::ffi::c_char;\n+}\n+extern \"C\" {\n+    pub fn __getdelim(\n+        __lineptr: *mut *mut ::core::ffi::c_char,\n+        __n: *mut usize,\n+        __delimiter: ::core::ffi::c_int,\n+        __stream: *mut FILE,\n+    ) -> __ssize_t;\n+}\n+extern \"C\" {\n+    pub fn getdelim(\n+        __lineptr: *mut *mut ::core::ffi::c_char,\n+        __n: *mut usize,\n+        __delimiter: ::core::ffi::c_int,\n+        __stream: *mut FILE,\n+    ) -> __ssize_t;\n+}\n+extern \"C\" {\n+    pub fn getline(\n+        __lineptr: *mut *mut ::core::ffi::c_char,\n+        __n: *mut usize,\n+        __stream: *mut FILE,\n+    ) -> __ssize_t;\n+}\n+extern \"C\" {\n+    pub fn fputs(__s: *const ::core::ffi::c_char, __stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn puts(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn ungetc(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn fread(\n+        __ptr: *mut ::core::ffi::c_void,\n+        __size: ::core::ffi::c_ulong,\n+        __n: ::core::ffi::c_ulong,\n+        __stream: *mut FILE,\n+    ) -> ::core::ffi::c_ulong;\n+}\n+extern \"C\" {\n+    pub fn fwrite(\n+        __ptr: *const ::core::ffi::c_void,\n+        __size: ::core::ffi::c_ulong,\n+        __n: ::core::ffi::c_ulong,\n+        __s: *mut FILE,\n+    ) -> ::core::ffi::c_ulong;\n+}\n+extern \"C\" {\n+    pub fn fread_unlocked(\n+        __ptr: *mut ::core::ffi::c_void,\n+        __size: usize,\n+        __n: usize,\n+        __stream: *mut FILE,\n+    ) -> usize;\n+}\n+extern \"C\" {\n+    pub fn fwrite_unlocked(\n+        __ptr: *const ::core::ffi::c_void,\n+        __size: usize,\n+        __n: usize,\n+        __stream: *mut FILE,\n+    ) -> usize;\n+}\n+extern \"C\" {\n+    pub fn fseek(\n+        __stream: *mut FILE,\n+        __off: ::core::ffi::c_long,\n+        __whence: ::core::ffi::c_int,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn ftell(__stream: *mut FILE) -> ::core::ffi::c_long;\n+}\n+extern \"C\" {\n+    pub fn rewind(__stream: *mut FILE);\n+}\n+extern \"C\" {\n+    pub fn fseeko(\n+        __stream: *mut FILE,\n+        __off: __off_t,\n+        __whence: ::core::ffi::c_int,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn ftello(__stream: *mut FILE) -> __off_t;\n+}\n+extern \"C\" {\n+    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn clearerr(__stream: *mut FILE);\n+}\n+extern \"C\" {\n+    pub fn feof(__stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn ferror(__stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn clearerr_unlocked(__stream: *mut FILE);\n+}\n+extern \"C\" {\n+    pub fn feof_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn ferror_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn perror(__s: *const ::core::ffi::c_char);\n+}\n+extern \"C\" {\n+    pub fn fileno(__stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn fileno_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn pclose(__stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn popen(\n+        __command: *const ::core::ffi::c_char,\n+        __modes: *const ::core::ffi::c_char,\n+    ) -> *mut FILE;\n+}\n+extern \"C\" {\n+    pub fn ctermid(__s: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;\n+}\n+extern \"C\" {\n+    pub fn flockfile(__stream: *mut FILE);\n+}\n+extern \"C\" {\n+    pub fn ftrylockfile(__stream: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn funlockfile(__stream: *mut FILE);\n+}\n+extern \"C\" {\n+    pub fn __uflow(arg1: *mut FILE) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn __overflow(arg1: *mut FILE, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;\n+}\n+#[doc = \"@brief   OS dependent lock interface.\"]\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_lock {\n+    #[doc = \"@brief   Lock access to mount point.\"]\n+    pub lock: ::core::option::Option<unsafe extern \"C\" fn()>,\n+    #[doc = \"@brief   Unlock access to mount point.\"]\n+    pub unlock: ::core::option::Option<unsafe extern \"C\" fn()>,\n+}\n+#[doc = \"@brief   File descriptor.\"]\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_file {\n+    #[doc = \"@brief   Mount point handle.\"]\n+    pub mp: *mut ext4_mountpoint,\n+    #[doc = \"@brief   File inode id.\"]\n+    pub inode: u32,\n+    #[doc = \"@brief   Open flags.\"]\n+    pub flags: u32,\n+    #[doc = \"@brief   File size.\"]\n+    pub fsize: u64,\n+    #[doc = \"@brief   Actual file position.\"]\n+    pub fpos: u64,\n+}\n+#[doc = \"@brief   Directory entry descriptor.\"]\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_direntry {\n+    pub inode: u32,\n+    pub entry_length: u16,\n+    pub name_length: u8,\n+    pub inode_type: u8,\n+    pub name: [u8; 255usize],\n+}\n+#[doc = \"@brief   Directory descriptor.\"]\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_dir {\n+    #[doc = \"@brief   File descriptor.\"]\n+    pub f: ext4_file,\n+    #[doc = \"@brief   Current directory entry.\"]\n+    pub de: ext4_direntry,\n+    #[doc = \"@brief   Next entry offset.\"]\n+    pub next_off: u64,\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Register block device.\\n\\n @param   bd Block device.\\n @param   dev_name Block device name.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_device_register(\n+        bd: *mut ext4_blockdev,\n+        dev_name: *const ::core::ffi::c_char,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Un-register block device.\\n\\n @param   dev_name Block device name.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_device_unregister(dev_name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Un-register all block devices.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_device_unregister_all() -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Mount a block device with EXT4 partition to the mount point.\\n\\n @param   dev_name Block device name (@ref ext4_device_register).\\n @param   mount_point Mount point, for example:\\n          -   /\\n          -   /my_partition/\\n          -   /my_second_partition/\\n @param   read_only mount as read-only mode.\\n\\n @return Standard error code\"]\n+    pub fn ext4_mount(\n+        dev_name: *const ::core::ffi::c_char,\n+        mount_point: *const ::core::ffi::c_char,\n+        read_only: bool,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Umount operation.\\n\\n @param   mount_point Mount point.\\n\\n @return  Standard error code\"]\n+    pub fn ext4_umount(mount_point: *const ::core::ffi::c_char) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Starts journaling. Journaling start/stop functions are transparent\\n          and might be used on filesystems without journaling support.\\n @warning Usage:\\n              ext4_mount(\\\"sda1\\\", \\\"/\\\");\\n              ext4_journal_start(\\\"/\\\");\\n\\n              //File operations here...\\n\\n              ext4_journal_stop(\\\"/\\\");\\n              ext4_umount(\\\"/\\\");\\n @param   mount_point Mount point.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_journal_start(mount_point: *const ::core::ffi::c_char) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Stops journaling. Journaling start/stop functions are transparent\\n          and might be used on filesystems without journaling support.\\n\\n @param   mount_point Mount point name.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_journal_stop(mount_point: *const ::core::ffi::c_char) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Journal recovery.\\n @warning Must be called after @ref ext4_mount.\\n\\n @param   mount_point Mount point.\\n\\n @return Standard error code.\"]\n+    pub fn ext4_recover(mount_point: *const ::core::ffi::c_char) -> ::core::ffi::c_int;\n+}\n+#[doc = \"@brief   Some of the filesystem stats.\"]\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_mount_stats {\n+    pub inodes_count: u32,\n+    pub free_inodes_count: u32,\n+    pub blocks_count: u64,\n+    pub free_blocks_count: u64,\n+    pub block_size: u32,\n+    pub block_group_count: u32,\n+    pub blocks_per_group: u32,\n+    pub inodes_per_group: u32,\n+    pub volume_name: [::core::ffi::c_char; 16usize],\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Get file mount point stats.\\n\\n @param   mount_point Mount point.\\n @param   stats Filesystem stats.\\n\\n @return Standard error code.\"]\n+    pub fn ext4_mount_point_stats(\n+        mount_point: *const ::core::ffi::c_char,\n+        stats: *mut ext4_mount_stats,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Setup OS lock routines.\\n\\n @param   mount_point Mount point.\\n @param   locks  Lock and unlock functions\\n\\n @return Standard error code.\"]\n+    pub fn ext4_mount_setup_locks(\n+        mount_point: *const ::core::ffi::c_char,\n+        locks: *const ext4_lock,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Acquire the filesystem superblock pointer of a mp.\\n\\n @param   mount_point Mount point.\\n @param   sb Superblock handle\\n\\n @return Standard error code.\"]\n+    pub fn ext4_get_sblock(\n+        mount_point: *const ::core::ffi::c_char,\n+        sb: *mut *mut ext4_sblock,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Enable/disable write back cache mode.\\n @warning Default model of cache is write trough. It means that when You do:\\n\\n          ext4_fopen(...);\\n          ext4_fwrite(...);\\n                           < --- data is flushed to physical drive\\n\\n          When you do:\\n          ext4_cache_write_back(..., 1);\\n          ext4_fopen(...);\\n          ext4_fwrite(...);\\n                           < --- data is NOT flushed to physical drive\\n          ext4_cache_write_back(..., 0);\\n                           < --- when write back mode is disabled all\\n                                 cache data will be flushed\\n To enable write back mode permanently just call this function\\n once after ext4_mount (and disable before ext4_umount).\\n\\n Some of the function use write back cache mode internally.\\n If you enable write back mode twice you have to disable it twice\\n to flush all data:\\n\\n      ext4_cache_write_back(..., 1);\\n      ext4_cache_write_back(..., 1);\\n\\n      ext4_cache_write_back(..., 0);\\n      ext4_cache_write_back(..., 0);\\n\\n Write back mode is useful when you want to create a lot of empty\\n files/directories.\\n\\n @param   path Mount point.\\n @param   on Enable/disable cache writeback mode.\\n\\n @return Standard error code.\"]\n+    pub fn ext4_cache_write_back(path: *const ::core::ffi::c_char, on: bool) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Force cache flush.\\n\\n @param   path Mount point.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_cache_flush(path: *const ::core::ffi::c_char) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Remove file by path.\\n\\n @param   path Path to file.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_fremove(path: *const ::core::ffi::c_char) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Create a hardlink for a file.\\n\\n @param   path Path to file.\\n @param   hardlink_path Path of hardlink.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_flink(\n+        path: *const ::core::ffi::c_char,\n+        hardlink_path: *const ::core::ffi::c_char,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Rename file.\\n @param path Source.\\n @param new_path Destination.\\n @return  Standard error code.\"]\n+    pub fn ext4_frename(\n+        path: *const ::core::ffi::c_char,\n+        new_path: *const ::core::ffi::c_char,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   File open function.\\n\\n @param   file  File handle.\\n @param   path  File path, has to start from mount point:/my_partition/file.\\n @param   flags File open flags.\\n  |---------------------------------------------------------------|\\n  |   r or rb                 O_RDONLY                            |\\n  |---------------------------------------------------------------|\\n  |   w or wb                 O_WRONLY|O_CREAT|O_TRUNC            |\\n  |---------------------------------------------------------------|\\n  |   a or ab                 O_WRONLY|O_CREAT|O_APPEND           |\\n  |---------------------------------------------------------------|\\n  |   r+ or rb+ or r+b        O_RDWR                              |\\n  |---------------------------------------------------------------|\\n  |   w+ or wb+ or w+b        O_RDWR|O_CREAT|O_TRUNC              |\\n  |---------------------------------------------------------------|\\n  |   a+ or ab+ or a+b        O_RDWR|O_CREAT|O_APPEND             |\\n  |---------------------------------------------------------------|\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_fopen(\n+        file: *mut ext4_file,\n+        path: *const ::core::ffi::c_char,\n+        flags: *const ::core::ffi::c_char,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Alternate file open function.\\n\\n @param   file  File handle.\\n @param   path  File path, has to start from mount point:/my_partition/file.\\n @param   flags File open flags.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_fopen2(\n+        file: *mut ext4_file,\n+        path: *const ::core::ffi::c_char,\n+        flags: ::core::ffi::c_int,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   File close function.\\n\\n @param   file File handle.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_fclose(file: *mut ext4_file) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   File truncate function.\\n\\n @param   file File handle.\\n @param   size New file size.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_ftruncate(file: *mut ext4_file, size: u64) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Read data from file.\\n\\n @param   file File handle.\\n @param   buf  Output buffer.\\n @param   size Bytes to read.\\n @param   rcnt Bytes read (NULL allowed).\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_fread(\n+        file: *mut ext4_file,\n+        buf: *mut ::core::ffi::c_void,\n+        size: usize,\n+        rcnt: *mut usize,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Write data to file.\\n\\n @param   file File handle.\\n @param   buf  Data to write\\n @param   size Write length..\\n @param   wcnt Bytes written (NULL allowed).\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_fwrite(\n+        file: *mut ext4_file,\n+        buf: *const ::core::ffi::c_void,\n+        size: usize,\n+        wcnt: *mut usize,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   File seek operation.\\n\\n @param   file File handle.\\n @param   offset Offset to seek.\\n @param   origin Seek type:\\n              @ref SEEK_SET\\n              @ref SEEK_CUR\\n              @ref SEEK_END\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_fseek(file: *mut ext4_file, offset: i64, origin: u32) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Get file position.\\n\\n @param   file File handle.\\n\\n @return  Actual file position\"]\n+    pub fn ext4_ftell(file: *mut ext4_file) -> u64;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Get file size.\\n\\n @param   file File handle.\\n\\n @return  File size.\"]\n+    pub fn ext4_fsize(file: *mut ext4_file) -> u64;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Get inode of file/directory/link.\\n\\n @param path    Parh to file/dir/link.\\n @param ret_ino Inode number.\\n @param inode   Inode internals.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_raw_inode_fill(\n+        path: *const ::core::ffi::c_char,\n+        ret_ino: *mut u32,\n+        inode: *mut ext4_inode,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Check if inode exists.\\n\\n @param path    Parh to file/dir/link.\\n @param type    Inode type.\\n                @ref EXT4_DIRENTRY_UNKNOWN\\n                @ref EXT4_DE_REG_FILE\\n                @ref EXT4_DE_DIR\\n                @ref EXT4_DE_CHRDEV\\n                @ref EXT4_DE_BLKDEV\\n                @ref EXT4_DE_FIFO\\n                @ref EXT4_DE_SOCK\\n                @ref EXT4_DE_SYMLINK\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_inode_exist(\n+        path: *const ::core::ffi::c_char,\n+        type_: ::core::ffi::c_int,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Change file/directory/link mode bits.\\n\\n @param path Path to file/dir/link.\\n @param mode New mode bits (for example 0777).\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_mode_set(path: *const ::core::ffi::c_char, mode: u32) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Get file/directory/link mode bits.\\n\\n @param path Path to file/dir/link.\\n @param mode New mode bits (for example 0777).\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_mode_get(path: *const ::core::ffi::c_char, mode: *mut u32) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Change file owner and group.\\n\\n @param path Path to file/dir/link.\\n @param uid  User id.\\n @param gid  Group id.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_owner_set(\n+        path: *const ::core::ffi::c_char,\n+        uid: u32,\n+        gid: u32,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Get file/directory/link owner and group.\\n\\n @param path Path to file/dir/link.\\n @param uid  User id.\\n @param gid  Group id.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_owner_get(\n+        path: *const ::core::ffi::c_char,\n+        uid: *mut u32,\n+        gid: *mut u32,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Set file/directory/link access time.\\n\\n @param path  Path to file/dir/link.\\n @param atime Access timestamp.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_atime_set(path: *const ::core::ffi::c_char, atime: u32) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Set file/directory/link modify time.\\n\\n @param path  Path to file/dir/link.\\n @param mtime Modify timestamp.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_mtime_set(path: *const ::core::ffi::c_char, mtime: u32) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Set file/directory/link change time.\\n\\n @param path  Path to file/dir/link.\\n @param ctime Change timestamp.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_ctime_set(path: *const ::core::ffi::c_char, ctime: u32) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Get file/directory/link access time.\\n\\n @param path  Path to file/dir/link.\\n @param atime Access timestamp.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_atime_get(path: *const ::core::ffi::c_char, atime: *mut u32) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Get file/directory/link modify time.\\n\\n @param path  Path to file/dir/link.\\n @param mtime Modify timestamp.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_mtime_get(path: *const ::core::ffi::c_char, mtime: *mut u32) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Get file/directory/link change time.\\n\\n @param path  Pathto file/dir/link.\\n @param ctime Change timestamp.\\n\\n @return  standard error code\"]\n+    pub fn ext4_ctime_get(path: *const ::core::ffi::c_char, ctime: *mut u32) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Create symbolic link.\\n\\n @param target Destination entry path.\\n @param path   Source entry path.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_fsymlink(\n+        target: *const ::core::ffi::c_char,\n+        path: *const ::core::ffi::c_char,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Create special file.\\n @param path     Path to new special file.\\n @param filetype Filetype of the new special file.\\n \\t           (that must not be regular file, directory, or unknown type)\\n @param dev      If filetype is char device or block device,\\n \\t           the device number will become the payload in the inode.\\n @return  Standard error code.\"]\n+    pub fn ext4_mknod(\n+        path: *const ::core::ffi::c_char,\n+        filetype: ::core::ffi::c_int,\n+        dev: u32,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Read symbolic link payload.\\n\\n @param path    Path to symlink.\\n @param buf     Output buffer.\\n @param bufsize Output buffer max size.\\n @param rcnt    Bytes read.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_readlink(\n+        path: *const ::core::ffi::c_char,\n+        buf: *mut ::core::ffi::c_char,\n+        bufsize: usize,\n+        rcnt: *mut usize,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Set extended attribute.\\n\\n @param path      Path to file/directory\\n @param name      Name of the entry to add.\\n @param name_len  Length of @name in bytes.\\n @param data      Data of the entry to add.\\n @param data_size Size of data to add.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_setxattr(\n+        path: *const ::core::ffi::c_char,\n+        name: *const ::core::ffi::c_char,\n+        name_len: usize,\n+        data: *const ::core::ffi::c_void,\n+        data_size: usize,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Get extended attribute.\\n\\n @param path      Path to file/directory.\\n @param name      Name of the entry to get.\\n @param name_len  Length of @name in bytes.\\n @param buf      Data of the entry to get.\\n @param buf_size Size of data to get.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_getxattr(\n+        path: *const ::core::ffi::c_char,\n+        name: *const ::core::ffi::c_char,\n+        name_len: usize,\n+        buf: *mut ::core::ffi::c_void,\n+        buf_size: usize,\n+        data_size: *mut usize,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief List extended attributes.\\n\\n @param path     Path to file/directory.\\n @param list     List to hold the name of entries.\\n @param size     Size of @list in bytes.\\n @param ret_size Used bytes of @list.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_listxattr(\n+        path: *const ::core::ffi::c_char,\n+        list: *mut ::core::ffi::c_char,\n+        size: usize,\n+        ret_size: *mut usize,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Remove extended attribute.\\n\\n @param path     Path to file/directory.\\n @param name     Name of the entry to remove.\\n @param name_len Length of @name in bytes.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_removexattr(\n+        path: *const ::core::ffi::c_char,\n+        name: *const ::core::ffi::c_char,\n+        name_len: usize,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Recursive directory remove.\\n\\n @param   path Directory path to remove\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_dir_rm(path: *const ::core::ffi::c_char) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Rename/move directory.\\n\\n @param path     Source path.\\n @param new_path Destination path.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_dir_mv(\n+        path: *const ::core::ffi::c_char,\n+        new_path: *const ::core::ffi::c_char,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Create new directory.\\n\\n @param   path Directory name.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_dir_mk(path: *const ::core::ffi::c_char) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Directory open.\\n\\n @param   dir  Directory handle.\\n @param   path Directory path.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_dir_open(\n+        dir: *mut ext4_dir,\n+        path: *const ::core::ffi::c_char,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Directory close.\\n\\n @param   dir directory handle.\\n\\n @return  Standard error code.\"]\n+    pub fn ext4_dir_close(dir: *mut ext4_dir) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Return next directory entry.\\n\\n @param   dir Directory handle.\\n\\n @return  Directory entry id (NULL if no entry)\"]\n+    pub fn ext4_dir_entry_next(dir: *mut ext4_dir) -> *const ext4_direntry;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Rewine directory entry offset.\\n\\n @param   dir Directory handle.\"]\n+    pub fn ext4_dir_entry_rewind(dir: *mut ext4_dir);\n+}\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_fs {\n+    pub read_only: bool,\n+    pub bdev: *mut ext4_blockdev,\n+    pub sb: ext4_sblock,\n+    pub inode_block_limits: [u64; 4usize],\n+    pub inode_blocks_per_level: [u64; 4usize],\n+    pub last_inode_bg_id: u32,\n+    pub jbd_fs: *mut jbd_fs,\n+    pub jbd_journal: *mut jbd_journal,\n+    pub curr_trans: *mut jbd_trans,\n+}\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_block_group_ref {\n+    pub block: ext4_block,\n+    pub block_group: *mut ext4_bgroup,\n+    pub fs: *mut ext4_fs,\n+    pub index: u32,\n+    pub dirty: bool,\n+}\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_inode_ref {\n+    pub block: ext4_block,\n+    pub inode: *mut ext4_inode,\n+    pub fs: *mut ext4_fs,\n+    pub index: u32,\n+    pub dirty: bool,\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Initialize filesystem and read all needed data.\\n @param fs Filesystem instance to be initialized\\n @param bdev Identifier if device with the filesystem\\n @param read_only Mark the filesystem as read-only.\\n @return Error code\"]\n+    pub fn ext4_fs_init(\n+        fs: *mut ext4_fs,\n+        bdev: *mut ext4_blockdev,\n+        read_only: bool,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Destroy filesystem instance (used by unmount operation).\\n @param fs Filesystem to be destroyed\\n @return Error code\"]\n+    pub fn ext4_fs_fini(fs: *mut ext4_fs) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Check filesystem's features, if supported by this driver\\n Function can return EOK and set read_only flag. It mean's that\\n there are some not-supported features, that can cause problems\\n during some write operations.\\n @param fs        Filesystem to be checked\\n @param read_only Flag if filesystem should be mounted only for reading\\n @return Error code\"]\n+    pub fn ext4_fs_check_features(fs: *mut ext4_fs, read_only: *mut bool) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Get reference to block group specified by index.\\n @param fs   Filesystem to find block group on\\n @param bgid Index of block group to load\\n @param ref  Output pointer for reference\\n @return Error code\"]\n+    pub fn ext4_fs_get_block_group_ref(\n+        fs: *mut ext4_fs,\n+        bgid: u32,\n+        ref_: *mut ext4_block_group_ref,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Put reference to block group.\\n @param ref Pointer for reference to be put back\\n @return Error code\"]\n+    pub fn ext4_fs_put_block_group_ref(ref_: *mut ext4_block_group_ref) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Get reference to i-node specified by index.\\n @param fs    Filesystem to find i-node on\\n @param index Index of i-node to load\\n @param ref   Output pointer for reference\\n @return Error code\"]\n+    pub fn ext4_fs_get_inode_ref(\n+        fs: *mut ext4_fs,\n+        index: u32,\n+        ref_: *mut ext4_inode_ref,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Reset blocks field of i-node.\\n @param fs        Filesystem to reset blocks field of i-inode on\\n @param inode_ref ref Pointer for inode to be operated on\"]\n+    pub fn ext4_fs_inode_blocks_init(fs: *mut ext4_fs, inode_ref: *mut ext4_inode_ref);\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Put reference to i-node.\\n @param ref Pointer for reference to be put back\\n @return Error code\"]\n+    pub fn ext4_fs_put_inode_ref(ref_: *mut ext4_inode_ref) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Convert filetype to inode mode.\\n @param filetype File type\\n @return inode mode\"]\n+    pub fn ext4_fs_correspond_inode_mode(filetype: ::core::ffi::c_int) -> u32;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Allocate new i-node in the filesystem.\\n @param fs        Filesystem to allocated i-node on\\n @param inode_ref Output pointer to return reference to allocated i-node\\n @param filetype  File type of newly created i-node\\n @return Error code\"]\n+    pub fn ext4_fs_alloc_inode(\n+        fs: *mut ext4_fs,\n+        inode_ref: *mut ext4_inode_ref,\n+        filetype: ::core::ffi::c_int,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Release i-node and mark it as free.\\n @param inode_ref I-node to be released\\n @return Error code\"]\n+    pub fn ext4_fs_free_inode(inode_ref: *mut ext4_inode_ref) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Truncate i-node data blocks.\\n @param inode_ref I-node to be truncated\\n @param new_size  New size of inode (must be < current size)\\n @return Error code\"]\n+    pub fn ext4_fs_truncate_inode(\n+        inode_ref: *mut ext4_inode_ref,\n+        new_size: u64,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Compute 'goal' for inode index\\n @param inode_ref Reference to inode, to allocate block for\\n @return goal\"]\n+    pub fn ext4_fs_inode_to_goal_block(inode_ref: *mut ext4_inode_ref) -> ext4_fsblk_t;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Compute 'goal' for allocation algorithm (For blockmap).\\n @param inode_ref Reference to inode, to allocate block for\\n @return error code\"]\n+    pub fn ext4_fs_indirect_find_goal(\n+        inode_ref: *mut ext4_inode_ref,\n+        goal: *mut ext4_fsblk_t,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Get physical block address by logical index of the block.\\n @param inode_ref I-node to read block address from\\n @param iblock            Logical index of block\\n @param fblock            Output pointer for return physical\\n                          block address\\n @param support_unwritten Indicate whether unwritten block range\\n                          is supported under the current context\\n @return Error code\"]\n+    pub fn ext4_fs_get_inode_dblk_idx(\n+        inode_ref: *mut ext4_inode_ref,\n+        iblock: ext4_lblk_t,\n+        fblock: *mut ext4_fsblk_t,\n+        support_unwritten: bool,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Initialize a part of unwritten range of the inode.\\n @param inode_ref I-node to proceed on.\\n @param iblock    Logical index of block\\n @param fblock    Output pointer for return physical block address\\n @return Error code\"]\n+    pub fn ext4_fs_init_inode_dblk_idx(\n+        inode_ref: *mut ext4_inode_ref,\n+        iblock: ext4_lblk_t,\n+        fblock: *mut ext4_fsblk_t,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief Append following logical block to the i-node.\\n @param inode_ref I-node to append block to\\n @param fblock    Output physical block address of newly allocated block\\n @param iblock    Output logical number of newly allocated block\\n @return Error code\"]\n+    pub fn ext4_fs_append_inode_dblk(\n+        inode_ref: *mut ext4_inode_ref,\n+        fblock: *mut ext4_fsblk_t,\n+        iblock: *mut ext4_lblk_t,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Increment inode link count.\\n @param   inode_ref none handle\"]\n+    pub fn ext4_fs_inode_links_count_inc(inode_ref: *mut ext4_inode_ref);\n+}\n+extern \"C\" {\n+    #[doc = \"@brief   Decrement inode link count.\\n @param   inode_ref none handle\"]\n+    pub fn ext4_fs_inode_links_count_dec(inode_ref: *mut ext4_inode_ref);\n+}\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_mkfs_info {\n+    pub len: u64,\n+    pub block_size: u32,\n+    pub blocks_per_group: u32,\n+    pub inodes_per_group: u32,\n+    pub inode_size: u32,\n+    pub inodes: u32,\n+    pub journal_blocks: u32,\n+    pub feat_ro_compat: u32,\n+    pub feat_compat: u32,\n+    pub feat_incompat: u32,\n+    pub bg_desc_reserve_blocks: u32,\n+    pub dsc_size: u16,\n+    pub uuid: [u8; 16usize],\n+    pub journal: bool,\n+    pub label: *const ::core::ffi::c_char,\n+}\n+extern \"C\" {\n+    pub fn ext4_mkfs_read_info(\n+        bd: *mut ext4_blockdev,\n+        info: *mut ext4_mkfs_info,\n+    ) -> ::core::ffi::c_int;\n+}\n+extern \"C\" {\n+    pub fn ext4_mkfs(\n+        fs: *mut ext4_fs,\n+        bd: *mut ext4_blockdev,\n+        info: *mut ext4_mkfs_info,\n+        fs_type: ::core::ffi::c_int,\n+    ) -> ::core::ffi::c_int;\n+}\n+#[doc = \"@brief   Mount point descriptor.\"]\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct ext4_mountpoint {\n+    #[doc = \"@brief   Mount done flag.\"]\n+    pub mounted: bool,\n+    #[doc = \"@brief   Mount point name (@ref ext4_mount)\"]\n+    pub name: [::core::ffi::c_char; 33usize],\n+    #[doc = \"@brief   OS dependent lock/unlock functions.\"]\n+    pub os_locks: *const ext4_lock,\n+    #[doc = \"@brief   Ext4 filesystem internals.\"]\n+    pub fs: ext4_fs,\n+}\n+pub type __builtin_va_list = [__va_list_tag; 1usize];\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct __va_list_tag {\n+    pub gp_offset: ::core::ffi::c_uint,\n+    pub fp_offset: ::core::ffi::c_uint,\n+    pub overflow_arg_area: *mut ::core::ffi::c_void,\n+    pub reg_save_area: *mut ::core::ffi::c_void,\n+}\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct jbd_fs {\n+    pub _address: u8,\n+}\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct jbd_journal {\n+    pub _address: u8,\n+}\n+#[repr(C)]\n+#[derive(Debug, Copy, Clone)]\n+pub struct jbd_trans {\n+    pub _address: u8,\n+}\n+\n"
    },
    {
      "cmd_idx": 16,
      "file": "lwext4-sys/build.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: used `assert_eq!` with a literal bool\n  --> lwext4-sys/build.rs:17:9\n   |\n17 |         assert_eq!(cp.success(), true);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#bool_assert_comparison\n   = note: `#[warn(clippy::bool_assert_comparison)]` on by default\nhelp: replace it with `assert!(..)`\n   |\n17 -         assert_eq!(cp.success(), true);\n17 +         assert!(cp.success());\n   |\n\n"
    },
    {
      "cmd_idx": 16,
      "file": "lwext4-sys/build.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: the borrowed expression implements the required traits\n  --> lwext4-sys/build.rs:34:22\n   |\n34 |         .current_dir(&lwext4)\n   |                      ^^^^^^^ help: change this to: `lwext4`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrows_for_generic_args\n   = note: `#[warn(clippy::needless_borrows_for_generic_args)]` on by default\n\n"
    },
    {
      "cmd_idx": 16,
      "file": "lwext4-sys/build.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this expression creates a reference which is immediately dereferenced by the compiler\n  --> lwext4-sys/build.rs:52:28\n   |\n52 |         generates_bindings(&lwext4, \"build_generic\");\n   |                            ^^^^^^^ help: change this to: `lwext4`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrow\n   = note: `#[warn(clippy::needless_borrow)]` on by default\n\n"
    },
    {
      "cmd_idx": 16,
      "file": "lwext4-sys/build.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this expression creates a reference which is immediately dereferenced by the compiler\n  --> lwext4-sys/build.rs:76:28\n   |\n76 |         generates_bindings(&lwext4, \"build_musl-generic\");\n   |                            ^^^^^^^ help: change this to: `lwext4`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrow\n\n"
    },
    {
      "cmd_idx": 16,
      "file": "lwext4-sys/build.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: writing `&PathBuf` instead of `&Path` involves a new object where a slice will do\n  --> lwext4-sys/build.rs:85:31\n   |\n85 | fn generates_bindings(lwext4: &PathBuf, build_dir: &str) {\n   |                               ^^^^^^^^ help: change this to: `&Path`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#ptr_arg\n   = note: `#[warn(clippy::ptr_arg)]` on by default\n\n"
    },
    {
      "cmd_idx": 16,
      "file": "lwext4-sys/src/ext4.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: unsafe function's docs are missing a `# Safety` section\n --> lwext4-sys/src/ext4.rs:3:453\n  |\n3 | ...self as * mut _ as * mut T } # [inline] pub unsafe fn as_slice (& self , len : usize) -> & [T] { :: core :: slice :: from_raw_parts (s...\n  |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#missing_safety_doc\n  = note: `#[warn(clippy::missing_safety_doc)]` on by default\n\n"
    },
    {
      "cmd_idx": 16,
      "file": "lwext4-sys/src/ext4.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: unsafe function's docs are missing a `# Safety` section\n --> lwext4-sys/src/ext4.rs:3:583\n  |\n3 | ...f . as_ptr () , len) } # [inline] pub unsafe fn as_mut_slice (& mut self , len : usize) -> & mut [T] { :: core :: slice :: from_raw_pa...\n  |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#missing_safety_doc\n\n"
    },
    {
      "cmd_idx": 18,
      "file": "Not supported to display yet.",
      "kind": "Lockbud(Possibly)",
      "raw": "[2024-10-05T04:20:19Z WARN  lockbud::callbacks] [\n      {\n        \"AtomicityViolation\": {\n          \"bug_kind\": \"AtomicityViolation\",\n          \"possibility\": \"Possibly\",\n          \"diagnosis\": {\n            \"fn_name\": \"set_logger_racy\",\n            \"atomic_reader\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/lib.rs:1447:11: 1447:40 (#0)\",\n            \"atomic_writer\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/lib.rs:1450:13: 1450:56 (#0)\",\n            \"dep_kind\": \"Control\"\n          },\n          \"explanation\": \"atomic::store is data/control dependent on atomic::load\"\n        }\n      }\n    ]\n[2024-10-05T04:20:19Z WARN  lockbud::callbacks] crate log contains bugs: { probably: 0, possibly: 0 }, conflictlock: { probably: 0, possibly: 0 }, condvar_deadlock: { probably: 0, possibly: 0 }, atomicity_violation: { possibly: 1 }, invalid_free: { possibly: 0 }, use_after_free: { possibly: 0 }\n[2024-10-05T04:20:23Z WARN  lockbud::callbacks] [\n      {\n        \"AtomicityViolation\": {\n          \"bug_kind\": \"AtomicityViolation\",\n          \"possibility\": \"Possibly\",\n          \"diagnosis\": {\n            \"fn_name\": \"regex_automata::util::pool::inner::Pool::<T, F>::get\",\n            \"atomic_reader\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.8/src/util/pool.rs:525:25: 525:59 (#0)\",\n            \"atomic_writer\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/regex-automata-0.4.8/src/util/pool.rs:530:17: 530:69 (#0)\",\n            \"dep_kind\": \"Control\"\n          },\n          \"explanation\": \"atomic::store is data/control dependent on atomic::load\"\n        }\n      }\n    ]\n[2024-10-05T04:20:23Z WARN  lockbud::callbacks] crate bindgen contains bugs: { probably: 0, possibly: 0 }, conflictlock: { probably: 0, possibly: 0 }, condvar_deadlock: { probably: 0, possibly: 0 }, atomicity_violation: { possibly: 1 }, invalid_free: { possibly: 0 }, use_after_free: { possibly: 0 }"
    },
    {
      "cmd_idx": 20,
      "file": "src/lib.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: the feature `const_mut_refs` has been stable since 1.83.0-nightly and no longer requires an attribute to enable\n --> src/lib.rs:2:12\n  |\n2 | #![feature(const_mut_refs)]\n  |            ^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(stable_features)]` on by default\n\n"
    },
    {
      "cmd_idx": 30,
      "file": "Not supported to display yet.",
      "kind": "Lockbud(Possibly)",
      "raw": "[2024-10-05T04:20:41Z WARN  lockbud::callbacks] [\n      {\n        \"AtomicityViolation\": {\n          \"bug_kind\": \"AtomicityViolation\",\n          \"possibility\": \"Possibly\",\n          \"diagnosis\": {\n            \"fn_name\": \"set_logger_racy\",\n            \"atomic_reader\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/lib.rs:1447:11: 1447:40 (#0)\",\n            \"atomic_writer\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/lib.rs:1450:13: 1450:56 (#0)\",\n            \"dep_kind\": \"Control\"\n          },\n          \"explanation\": \"atomic::store is data/control dependent on atomic::load\"\n        }\n      }\n    ]\n[2024-10-05T04:20:41Z WARN  lockbud::callbacks] crate log contains bugs: { probably: 0, possibly: 0 }, conflictlock: { probably: 0, possibly: 0 }, condvar_deadlock: { probably: 0, possibly: 0 }, atomicity_violation: { possibly: 1 }, invalid_free: { possibly: 0 }, use_after_free: { possibly: 0 }"
    },
    {
      "cmd_idx": 35,
      "file": "src/bitmap.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_8/kern-crates/pager/src/bitmap.rs (original lines from 213 to 213)\n-        }else {\n+        } else {\n"
    },
    {
      "cmd_idx": 36,
      "file": "src/bitmap.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: doc list item without indentation\n  --> src/bitmap.rs:21:5\n   |\n21 | /// If the number of physical pages is less than 4096*8, space may be wasted\n   |     ^\n   |\n   = help: if this is supposed to be its own paragraph, add a blank line\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#doc_lazy_continuation\n   = note: `#[warn(clippy::doc_lazy_continuation)]` on by default\nhelp: indent this line\n   |\n21 | ///    If the number of physical pages is less than 4096*8, space may be wasted\n   |     +++\n\n"
    },
    {
      "cmd_idx": 36,
      "file": "src/bitmap.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: manually reimplementing `div_ceil`\n   --> src/bitmap.rs:197:32\n    |\n197 |             let bitmap_pages = (self.max + 4096 * 8 - 1) / (4096 * 8);\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.div_ceil()`: `self.max.div_ceil((4096 * 8))`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_div_ceil\n    = note: `#[warn(clippy::manual_div_ceil)]` on by default\n\n"
    },
    {
      "cmd_idx": 36,
      "file": "src/buddy.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: you should consider adding a `Default` implementation for `Zone<MAX_ORDER>`\n  --> src/buddy.rs:78:5\n   |\n78 | /     pub const fn new() -> Self {\n79 | |         Self {\n80 | |             manage_pages: 0,\n81 | |             start_page: 0,\n82 | |             free_areas: [FreeArea::new(); MAX_ORDER],\n83 | |         }\n84 | |     }\n   | |_____^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#new_without_default\n   = note: `#[warn(clippy::new_without_default)]` on by default\nhelp: try adding this\n   |\n76 + impl<const MAX_ORDER: usize> Default for Zone<MAX_ORDER> {\n77 +     fn default() -> Self {\n78 +         Self::new()\n79 +     }\n80 + }\n   |\n\n"
    },
    {
      "cmd_idx": 38,
      "file": "Not supported to display yet.",
      "kind": "Lockbud(Possibly)",
      "raw": "[2024-10-05T04:20:56Z WARN  lockbud::callbacks] [\n      {\n        \"AtomicityViolation\": {\n          \"bug_kind\": \"AtomicityViolation\",\n          \"possibility\": \"Possibly\",\n          \"diagnosis\": {\n            \"fn_name\": \"set_logger_racy\",\n            \"atomic_reader\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/lib.rs:1447:11: 1447:40 (#0)\",\n            \"atomic_writer\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.22/src/lib.rs:1450:13: 1450:56 (#0)\",\n            \"dep_kind\": \"Control\"\n          },\n          \"explanation\": \"atomic::store is data/control dependent on atomic::load\"\n        }\n      }\n    ]\n[2024-10-05T04:20:56Z WARN  lockbud::callbacks] crate log contains bugs: { probably: 0, possibly: 0 }, conflictlock: { probably: 0, possibly: 0 }, condvar_deadlock: { probably: 0, possibly: 0 }, atomicity_violation: { possibly: 1 }, invalid_free: { possibly: 0 }, use_after_free: { possibly: 0 }"
    },
    {
      "cmd_idx": 40,
      "file": "src/io.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this `impl` can be derived\n   --> src/io.rs:93:1\n    |\n93  | / impl Default for FsStat {\n94  | |     fn default() -> Self {\n95  | |         Self {\n96  | |             f_type: 0,\n...   |\n109 | |     }\n110 | | }\n    | |_^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#derivable_impls\n    = note: `#[warn(clippy::derivable_impls)]` on by default\n    = help: remove the manual implementation...\nhelp: ...and instead derive it\n    |\n66  + #[derive(Default)]\n67  | pub struct FsStat {\n    |\n\n"
    },
    {
      "cmd_idx": 40,
      "file": "/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs",
      "kind": "Clippy(Error)",
      "raw": "error: &-masking with zero\n   --> src/io.rs:176:1\n    |\n176 | / bitflags! {\n177 | |     pub struct FaccessatMode: u32 {\n178 | |         const F_OK = 0;\n179 | |         const R_OK = 4;\n...   |\n186 | |     }\n187 | | }\n    | |_^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#bad_bit_mask\n    = note: `#[deny(clippy::bad_bit_mask)]` on by default\n    = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"
    },
    {
      "cmd_idx": 40,
      "file": "/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs",
      "kind": "Clippy(Error)",
      "raw": "error: &-masking with zero\n   --> src/io.rs:345:1\n    |\n345 | / bitflags::bitflags! {\n346 | |     pub struct OpenFlags: usize {\n347 | |         // reserve 3 bits for the access mode\n348 | |         const O_RDONLY      = 0;\n...   |\n371 | |     }\n372 | | }\n    | |_^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#bad_bit_mask\n    = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags::bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"
    },
    {
      "cmd_idx": 40,
      "file": "src/io.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: struct `Dirent64` has a public `len` method, but no `is_empty` method\n   --> src/io.rs:456:5\n    |\n456 |     pub fn len(&self) -> usize {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#len_without_is_empty\n    = note: `#[warn(clippy::len_without_is_empty)]` on by default\n\n"
    },
    {
      "cmd_idx": 40,
      "file": "/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs",
      "kind": "Clippy(Error)",
      "raw": "error: &-masking with zero\n   --> src/io.rs:612:1\n    |\n612 | / bitflags! {\n613 | |      /// renameat flag\n614 | |     pub struct Renameat2Flags: u32 {\n615 | |         /// Go back to renameat\n...   |\n623 | |     }\n624 | | }\n    | |_^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#bad_bit_mask\n    = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"
    },
    {
      "cmd_idx": 40,
      "file": "/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/bitflags-1.3.2/src/lib.rs",
      "kind": "Clippy(Error)",
      "raw": "error: &-masking with zero\n   --> src/io.rs:625:1\n    |\n625 | / bitflags! {\n626 | |     pub struct ProtFlags: u32 {\n627 | |         const PROT_NONE = 0x0;\n628 | |         const PROT_READ = 0x1;\n...   |\n631 | |     }\n632 | | }\n    | |_^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#bad_bit_mask\n    = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"
    },
    {
      "cmd_idx": 40,
      "file": "src/signal/mod.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: you should consider adding a `Default` implementation for `SignalHandlers`\n  --> src/signal/mod.rs:30:5\n   |\n30 | /     pub fn new() -> Self {\n31 | |         Self {\n32 | |             actions: [None; SIGSET_SIZE_IN_BIT],\n33 | |         }\n34 | |     }\n   | |_____^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#new_without_default\n   = note: `#[warn(clippy::new_without_default)]` on by default\nhelp: try adding this\n   |\n28 + impl Default for SignalHandlers {\n29 +     fn default() -> Self {\n30 +         Self::new()\n31 +     }\n32 + }\n   |\n\n"
    },
    {
      "cmd_idx": 40,
      "file": "src/signal/mod.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this lifetime isn't used in the function definition\n  --> src/signal/mod.rs:44:23\n   |\n44 |     pub fn get_action<'a>(&self, signum: usize, action_pos: &mut SigAction) {\n   |                       ^^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#extra_unused_lifetimes\n   = note: `#[warn(clippy::extra_unused_lifetimes)]` on by default\n\n"
    },
    {
      "cmd_idx": 40,
      "file": "src/signal/mod.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: you should consider adding a `Default` implementation for `SignalReceivers`\n  --> src/signal/mod.rs:80:5\n   |\n80 | /     pub fn new() -> Self {\n81 | |         Self {\n82 | |             mask: SimpleBitSet::default(),\n83 | |             sig_received: SimpleBitSet::default(),\n84 | |         }\n85 | |     }\n   | |_____^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#new_without_default\nhelp: try adding this\n   |\n78 + impl Default for SignalReceivers {\n79 +     fn default() -> Self {\n80 +         Self::new()\n81 +     }\n82 + }\n   |\n\n"
    },
    {
      "cmd_idx": 40,
      "file": "src/signal/mod.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n   --> src/signal/mod.rs:165:1\n    |\n165 | impl Into<Vec<SignalNumber>> for SimpleBitSet {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: `impl From<Local> for Foreign` is allowed by the orphan rules, for more information see\n            https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#from_over_into\n    = note: `#[warn(clippy::from_over_into)]` on by default\nhelp: replace the `Into` implementation with `From<signal::SimpleBitSet>`\n    |\n165 ~ impl From<SimpleBitSet> for Vec<SignalNumber> {\n166 ~     fn from(val: SimpleBitSet) -> Self {\n167 |         let mut ans = Vec::new();\n168 |         for i in 0..64 {\n169 ~             if val.0 & (1 << i) != 0 {\n    |\n\n"
    },
    {
      "cmd_idx": 40,
      "file": "src/signal/mod.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: suspicious use of `|` in `Add` impl\n   --> src/signal/mod.rs:201:21\n    |\n201 |         Self(self.0 | rhs.0)\n    |                     ^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_arithmetic_impl\n    = note: `#[warn(clippy::suspicious_arithmetic_impl)]` on by default\n\n"
    },
    {
      "cmd_idx": 40,
      "file": "src/signal/mod.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: suspicious use of `|` in `AddAssign` impl\n   --> src/signal/mod.rs:207:16\n    |\n207 |         self.0 |= rhs.0;\n    |                ^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#suspicious_op_assign_impl\n    = note: `#[warn(clippy::suspicious_op_assign_impl)]` on by default\n\n"
    },
    {
      "cmd_idx": 43,
      "file": "(virtual) clippy",
      "kind": "Cargo",
      "raw": "// pkg_name=pconst, checker=Clippy\n// toolchain=nightly-x86_64-unknown-linux-gnu, target=x86_64-unknown-linux-gnu\n// pkg_dir=/home/runner/check/batch_8/kern-crates/pconst\n// cmd=cargo clippy --target x86_64-unknown-linux-gnu --no-deps --message-format=json\n    Updating crates.io index\n    Updating git repository `https://github.com/asterinas/pod`\n    Updating git repository `https://github.com/os-module/syscall-table.git`\n    Updating git repository `https://github.com/os-module/inventory`\n     Locking 16 packages to latest compatible versions\n      Adding bitflags v1.3.2 (available: v2.6.0)\n Downloading crates ...\n  Downloaded yansi v1.0.1\n  Downloaded int-enum v1.1.2\n  Downloaded proc-macro2-diagnostics v0.10.1\n   Compiling proc-macro2 v1.0.86\n   Compiling unicode-ident v1.0.13\n   Compiling version_check v0.9.5\n   Compiling syn v1.0.109\n   Compiling yansi v1.0.1\n    Checking bitflags v1.3.2\n   Compiling proc-macro2-diagnostics v0.10.1\n   Compiling int-enum v1.1.2\n   Compiling quote v1.0.37\n   Compiling syn v2.0.79\n   Compiling pod-derive v0.1.0 (https://github.com/asterinas/pod?rev=d7dba56#d7dba56c)\n    Checking pod v0.1.0 (https://github.com/asterinas/pod?rev=d7dba56#d7dba56c)\n    Checking pconst v0.1.0 (/home/runner/check/batch_8/kern-crates/pconst)\nerror: could not compile `pconst` (lib) due to 4 previous errors; 8 warnings emitted\n"
    }
  ]
}