{
  "env": {
    "tools": {
      "rust_toolchains": {
        "host": {
          "version": "1.86.0-nightly (f7cc13af8 2025-01-25)",
          "commit_hash": "f7cc13af822fe68c64fec0b05aa9dd1412451f7c",
          "commit_date": "2025-01-25",
          "host": "x86_64-unknown-linux-gnu",
          "release": "1.86.0-nightly",
          "llvm_version": "19.1.7"
        },
        "installed": [
          {
            "channel": "nightly-2025-01-26-x86_64-unknown-linux-gnu",
            "profile": null,
            "targets": [
              "aarch64-unknown-none",
              "riscv64gc-unknown-none-elf",
              "x86_64-unknown-linux-gnu",
              "x86_64-unknown-none"
            ],
            "components": [
              "cargo-x86_64-unknown-linux-gnu",
              "clippy-x86_64-unknown-linux-gnu",
              "rust-std-aarch64-unknown-none",
              "rust-std-riscv64gc-unknown-none-elf",
              "rust-std-x86_64-unknown-linux-gnu",
              "rust-std-x86_64-unknown-none",
              "rustc-x86_64-unknown-linux-gnu",
              "rustfmt-x86_64-unknown-linux-gnu"
            ],
            "toml_path": "/home/runner/check",
            "need_install_clippy": false,
            "peculiar_targets": null
          }
        ]
      },
      "os_checker": {
        "start": 1740601991943,
        "finish": 1740601992722,
        "duration_ms": 779,
        "git_time": "2025-02-16 16:17:11 +0800",
        "git_sha": "379b4c5f3884500f536ea00ffc0672d2af054861"
      }
    },
    "kinds": {
      "order": [
        "Cargo",
        "Clippy(Error)",
        "Clippy(Warn)",
        "Semver Violation",
        "Audit",
        "Mirai",
        "Rapx",
        "Rudra",
        "Lockbud(Probably)",
        "Lockbud(Possibly)",
        "Outdated",
        "Geiger",
        "Unformatted"
      ],
      "mapping": {
        "cargo": [
          "Cargo"
        ],
        "clippy": [
          "Clippy(Error)",
          "Clippy(Warn)"
        ],
        "semver-checks": [
          "Semver Violation"
        ],
        "audit": [
          "Audit"
        ],
        "mirai": [
          "Mirai"
        ],
        "rapx": [
          "Rapx"
        ],
        "rudra": [
          "Rudra"
        ],
        "lockbud": [
          "Lockbud(Probably)",
          "Lockbud(Possibly)"
        ],
        "outdated": [
          "Outdated"
        ],
        "geiger": [
          "Geiger"
        ],
        "fmt": [
          "Unformatted"
        ]
      }
    },
    "repos": [
      {
        "user": "elliott10",
        "repo": "fxmac_rs"
      },
      {
        "user": "elliott10",
        "repo": "lwext4_rust"
      }
    ],
    "packages": [
      {
        "name": "fxmac_rs",
        "repo": {
          "repo_idx": 0,
          "user": "elliott10",
          "repo": "fxmac_rs"
        }
      },
      {
        "name": "lwext4_rust",
        "repo": {
          "repo_idx": 1,
          "user": "elliott10",
          "repo": "lwext4_rust"
        }
      },
      {
        "name": "lwext4_rust_examples",
        "repo": {
          "repo_idx": 1,
          "user": "elliott10",
          "repo": "lwext4_rust"
        }
      }
    ]
  },
  "cmd": [
    {
      "package_idx": 0,
      "tool": "fmt",
      "cmd": "cargo +nightly-2025-01-26-x86_64-unknown-linux-gnu fmt",
      "count": 380,
      "duration_ms": 135,
      "arch": "aarch64",
      "target_triple": "aarch64-unknown-none-softfloat",
      "rust_toolchain": "nightly-2025-01-18",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 0,
      "tool": "clippy",
      "cmd": "cargo clippy --target aarch64-unknown-none-softfloat  --no-deps",
      "count": 107,
      "duration_ms": 3367,
      "arch": "aarch64",
      "target_triple": "aarch64-unknown-none-softfloat",
      "rust_toolchain": "nightly-2025-01-18",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 0,
      "tool": "semver-checks",
      "cmd": "cargo +nightly-2025-01-26-x86_64-unknown-linux-gnu semver-checks --target aarch64-unknown-none-softfloat ",
      "count": 1,
      "duration_ms": 486,
      "arch": "aarch64",
      "target_triple": "aarch64-unknown-none-softfloat",
      "rust_toolchain": "nightly-2025-01-18",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 0,
      "tool": "lockbud",
      "cmd": "cargo +nightly-2024-12-01 lockbud -k all -- --target aarch64-unknown-none-softfloat ",
      "count": 0,
      "duration_ms": 4309,
      "arch": "aarch64",
      "target_triple": "aarch64-unknown-none-softfloat",
      "rust_toolchain": "nightly-2025-01-18",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 0,
      "tool": "rapx",
      "cmd": "cargo +nightly-2024-10-12 rapx -F -M -- --target aarch64-unknown-none-softfloat ",
      "count": 1,
      "duration_ms": 8255,
      "arch": "aarch64",
      "target_triple": "aarch64-unknown-none-softfloat",
      "rust_toolchain": "nightly-2025-01-18",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 0,
      "tool": "outdated",
      "cmd": "cargo +nightly-2025-01-26-x86_64-unknown-linux-gnu outdated -R --exit-code=2",
      "count": 1,
      "duration_ms": 169,
      "arch": "aarch64",
      "target_triple": "aarch64-unknown-none-softfloat",
      "rust_toolchain": "nightly-2025-01-18",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 0,
      "tool": "cargo",
      "cmd": "VRITUAL=semver-checks cargo",
      "count": 1,
      "duration_ms": 486,
      "arch": "aarch64",
      "target_triple": "aarch64-unknown-none-softfloat",
      "rust_toolchain": "nightly-2025-01-18",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 1,
      "tool": "fmt",
      "cmd": "cargo +nightly-2025-01-26-x86_64-unknown-linux-gnu fmt",
      "count": 18,
      "duration_ms": 122,
      "arch": "riscv64gc",
      "target_triple": "riscv64gc-unknown-none-elf",
      "rust_toolchain": "nightly-2025-01-25",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 1,
      "tool": "clippy",
      "cmd": "cargo clippy --target riscv64gc-unknown-none-elf  --no-deps",
      "count": 5,
      "duration_ms": 691,
      "arch": "riscv64gc",
      "target_triple": "riscv64gc-unknown-none-elf",
      "rust_toolchain": "nightly-2025-01-25",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 1,
      "tool": "semver-checks",
      "cmd": "cargo +nightly-2025-01-26-x86_64-unknown-linux-gnu semver-checks --target riscv64gc-unknown-none-elf ",
      "count": 1,
      "duration_ms": 790,
      "arch": "riscv64gc",
      "target_triple": "riscv64gc-unknown-none-elf",
      "rust_toolchain": "nightly-2025-01-25",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 1,
      "tool": "lockbud",
      "cmd": "cargo +nightly-2024-12-01 lockbud -k all -- --target riscv64gc-unknown-none-elf ",
      "count": 0,
      "duration_ms": 721,
      "arch": "riscv64gc",
      "target_triple": "riscv64gc-unknown-none-elf",
      "rust_toolchain": "nightly-2025-01-25",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 1,
      "tool": "rapx",
      "cmd": "cargo +nightly-2024-10-12 rapx -F -M -- --target riscv64gc-unknown-none-elf ",
      "count": 0,
      "duration_ms": 905,
      "arch": "riscv64gc",
      "target_triple": "riscv64gc-unknown-none-elf",
      "rust_toolchain": "nightly-2025-01-25",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 1,
      "tool": "outdated",
      "cmd": "cargo +nightly-2025-01-26-x86_64-unknown-linux-gnu outdated -R --exit-code=2",
      "count": 1,
      "duration_ms": 154,
      "arch": "riscv64gc",
      "target_triple": "riscv64gc-unknown-none-elf",
      "rust_toolchain": "nightly-2025-01-25",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 1,
      "tool": "cargo",
      "cmd": "VRITUAL=clippy cargo",
      "count": 1,
      "duration_ms": 691,
      "arch": "riscv64gc",
      "target_triple": "riscv64gc-unknown-none-elf",
      "rust_toolchain": "nightly-2025-01-25",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 1,
      "tool": "cargo",
      "cmd": "VRITUAL=semver-checks cargo",
      "count": 1,
      "duration_ms": 790,
      "arch": "riscv64gc",
      "target_triple": "riscv64gc-unknown-none-elf",
      "rust_toolchain": "nightly-2025-01-25",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 1,
      "tool": "cargo",
      "cmd": "VRITUAL=lockbud cargo",
      "count": 1,
      "duration_ms": 721,
      "arch": "riscv64gc",
      "target_triple": "riscv64gc-unknown-none-elf",
      "rust_toolchain": "nightly-2025-01-25",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 1,
      "tool": "cargo",
      "cmd": "VRITUAL=rapx cargo",
      "count": 1,
      "duration_ms": 905,
      "arch": "riscv64gc",
      "target_triple": "riscv64gc-unknown-none-elf",
      "rust_toolchain": "nightly-2025-01-25",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 2,
      "tool": "fmt",
      "cmd": "cargo +nightly-2025-01-26-x86_64-unknown-linux-gnu fmt",
      "count": 17,
      "duration_ms": 106,
      "arch": "riscv64gc",
      "target_triple": "riscv64gc-unknown-none-elf",
      "rust_toolchain": "nightly-2024-01-31",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 2,
      "tool": "clippy",
      "cmd": "cargo clippy --target riscv64gc-unknown-none-elf  --no-deps",
      "count": 0,
      "duration_ms": 118,
      "arch": "riscv64gc",
      "target_triple": "riscv64gc-unknown-none-elf",
      "rust_toolchain": "nightly-2024-01-31",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 2,
      "tool": "lockbud",
      "cmd": "cargo +nightly-2024-12-01 lockbud -k all -- --target riscv64gc-unknown-none-elf ",
      "count": 0,
      "duration_ms": 3311,
      "arch": "riscv64gc",
      "target_triple": "riscv64gc-unknown-none-elf",
      "rust_toolchain": "nightly-2024-01-31",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 2,
      "tool": "rapx",
      "cmd": "cargo +nightly-2024-10-12 rapx -F -M -- --target riscv64gc-unknown-none-elf ",
      "count": 0,
      "duration_ms": 3339,
      "arch": "riscv64gc",
      "target_triple": "riscv64gc-unknown-none-elf",
      "rust_toolchain": "nightly-2024-01-31",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 2,
      "tool": "outdated",
      "cmd": "cargo +nightly-2025-01-26-x86_64-unknown-linux-gnu outdated -R --exit-code=2",
      "count": 1,
      "duration_ms": 517,
      "arch": "riscv64gc",
      "target_triple": "riscv64gc-unknown-none-elf",
      "rust_toolchain": "nightly-2024-01-31",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 2,
      "tool": "cargo",
      "cmd": "VRITUAL=lockbud cargo",
      "count": 1,
      "duration_ms": 3311,
      "arch": "riscv64gc",
      "target_triple": "riscv64gc-unknown-none-elf",
      "rust_toolchain": "nightly-2024-01-31",
      "features": [],
      "flags": []
    },
    {
      "package_idx": 2,
      "tool": "cargo",
      "cmd": "VRITUAL=rapx cargo",
      "count": 1,
      "duration_ms": 3339,
      "arch": "riscv64gc",
      "target_triple": "riscv64gc-unknown-none-elf",
      "rust_toolchain": "nightly-2024-01-31",
      "features": [],
      "flags": []
    }
  ],
  "data": [
    {
      "cmd_idx": 0,
      "file": "src/fxmac.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac.rs (original lines from 58 to 58)\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac.rs (original lines from 98 to 98)\n-    unsafe { core::ptr::read_volatile(crate_interface::call_interface!(crate::KernelFunc::phys_to_virt(src as usize)) as *const T) }\n+    unsafe {\n+        core::ptr::read_volatile(\n+            crate_interface::call_interface!(crate::KernelFunc::phys_to_virt(src as usize))\n+                as *const T,\n+        )\n+    }\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac.rs (original lines from 103 to 103)\n-        core::ptr::write_volatile(crate_interface::call_interface!(crate::KernelFunc::phys_to_virt(dst as usize)) as *mut T, value);\n+        core::ptr::write_volatile(\n+            crate_interface::call_interface!(crate::KernelFunc::phys_to_virt(dst as usize))\n+                as *mut T,\n+            value,\n+        );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac.rs (original lines from 107 to 107)\n-pub fn xmac_init(hwaddr: &[u8; 6]) -> &'static mut FXmac { // i32\n+pub fn xmac_init(hwaddr: &[u8; 6]) -> &'static mut FXmac {\n+    // i32\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 4 to 4)\n-pub(crate) const FXMAC_RX_BUF_UNIT:u32 = 64; /* Number of receive buffer bytes as a unit, this is HW setup */\n+pub(crate) const FXMAC_RX_BUF_UNIT: u32 = 64; /* Number of receive buffer bytes as a unit, this is HW setup */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 6 to 7)\n-pub(crate) const FXMAC_MAX_RXBD:u32 = 128;/* Size of RX buffer descriptor queues */\n-pub(crate) const FXMAC_MAX_TXBD:u32 = 128;/* Size of TX buffer descriptor queues */\n+pub(crate) const FXMAC_MAX_RXBD: u32 = 128; /* Size of RX buffer descriptor queues */\n+pub(crate) const FXMAC_MAX_TXBD: u32 = 128; /* Size of TX buffer descriptor queues */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 9 to 9)\n-pub(crate) const FXMAC_MAX_HASH_BITS:u32 = 64;/* Maximum value for hash bits. 2**6 */\n+pub(crate) const FXMAC_MAX_HASH_BITS: u32 = 64; /* Maximum value for hash bits. 2**6 */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 13 to 14)\n-pub(crate) const FXMAC_MAX_MAC_ADDR:u32 = 4;/* Maxmum number of mac address supported */\n-pub(crate) const FXMAC_MAX_TYPE_ID:u32 = 4; /* Maxmum number of type id supported */\n+pub(crate) const FXMAC_MAX_MAC_ADDR: u32 = 4; /* Maxmum number of mac address supported */\n+pub(crate) const FXMAC_MAX_TYPE_ID: u32 = 4; /* Maxmum number of type id supported */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 17 to 17)\n-pub(crate) const FXMAC_BD_ALIGNMENT:u32 = 64;/* Minimum buffer descriptor alignment on the local bus */\n+pub(crate) const FXMAC_BD_ALIGNMENT: u32 = 64; /* Minimum buffer descriptor alignment on the local bus */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 19 to 19)\n+pub(crate) const FXMAC_RX_BUF_ALIGNMENT: u32 = 4; /* Minimum buffer alignment when using options that impose \n+alignment  restrictions on the buffer data on the local bus */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 20 to 21)\n-pub(crate) const FXMAC_RX_BUF_ALIGNMENT:u32 = 4;/* Minimum buffer alignment when using options that impose \n-                                    alignment  restrictions on the buffer data on the local bus */\n+pub(crate) const FXMAC_NWCTRL_OFFSET: u64 = 0x00000000; /* Network Control reg */\n+pub(crate) const FXMAC_NWCFG_OFFSET: u64 = 0x00000004; /* Network Config reg */\n+pub(crate) const FXMAC_NWSR_OFFSET: u64 = 0x00000008; /* Network Status reg */\n+pub(crate) const FXMAC_DMACR_OFFSET: u64 = 0x00000010; /* DMA Control reg */\n+pub(crate) const FXMAC_TXSR_OFFSET: u64 = 0x00000014; /* TX Status reg */\n+pub(crate) const FXMAC_RXQBASE_OFFSET: u64 = 0x00000018; /* RX Q Base address reg */\n+pub(crate) const FXMAC_TXQBASE_OFFSET: u64 = 0x0000001C; /* TX Q Base address reg */\n+pub(crate) const FXMAC_RXSR_OFFSET: u64 = 0x00000020; /* RX Status reg */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 23 to 30)\n-pub(crate) const FXMAC_NWCTRL_OFFSET:u64 = 0x00000000; /* Network Control reg */\n-pub(crate) const FXMAC_NWCFG_OFFSET:u64 = 0x00000004;  /* Network Config reg */\n-pub(crate) const FXMAC_NWSR_OFFSET:u64 = 0x00000008;   /* Network Status reg */\n-pub(crate) const FXMAC_DMACR_OFFSET:u64 = 0x00000010;  /* DMA Control reg */\n-pub(crate) const FXMAC_TXSR_OFFSET:u64 = 0x00000014;   /* TX Status reg */\n-pub(crate) const FXMAC_RXQBASE_OFFSET:u64 = 0x00000018;/* RX Q Base address reg */\n-pub(crate) const FXMAC_TXQBASE_OFFSET:u64 = 0x0000001C;/* TX Q Base address reg */\n-pub(crate) const FXMAC_RXSR_OFFSET:u64 = 0x00000020;   /* RX Status reg */\n+pub(crate) const FXMAC_ISR_OFFSET: u64 = 0x00000024; /* Interrupt Status reg */\n+pub(crate) const FXMAC_IER_OFFSET: u64 = 0x00000028; /* Interrupt Enable reg */\n+pub(crate) const FXMAC_IDR_OFFSET: u64 = 0x0000002C; /* Interrupt Disable reg */\n+pub(crate) const FXMAC_IMR_OFFSET: u64 = 0x00000030; /* Interrupt Mask reg */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 32 to 35)\n-pub(crate) const FXMAC_ISR_OFFSET:u64 = 0x00000024;/* Interrupt Status reg */\n-pub(crate) const FXMAC_IER_OFFSET:u64 = 0x00000028;/* Interrupt Enable reg */\n-pub(crate) const FXMAC_IDR_OFFSET:u64 = 0x0000002C;/* Interrupt Disable reg */\n-pub(crate) const FXMAC_IMR_OFFSET:u64 = 0x00000030;/* Interrupt Mask reg */\n+pub(crate) const FXMAC_PHYMNTNC_OFFSET: u64 = 0x00000034; /* Phy Maintaince reg */\n+pub(crate) const FXMAC_RXPAUSE_OFFSET: u64 = 0x00000038; /* RX Pause Time reg */\n+pub(crate) const FXMAC_TXPAUSE_OFFSET: u64 = 0x0000003C; /* TX Pause Time reg */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 37 to 39)\n-pub(crate) const FXMAC_PHYMNTNC_OFFSET:u64 = 0x00000034;/* Phy Maintaince reg */\n-pub(crate) const FXMAC_RXPAUSE_OFFSET:u64 = 0x00000038; /* RX Pause Time reg */\n-pub(crate) const FXMAC_TXPAUSE_OFFSET:u64 = 0x0000003C; /* TX Pause Time reg */\n+pub(crate) const FXMAC_JUMBOMAXLEN_OFFSET: u64 = 0x00000048; /* Jumbo max length reg */\n+pub(crate) const FXMAC_GEM_HSMAC: u32 = 0x0050; /* Hs mac config register*/\n+pub(crate) const FXMAC_RXWATERMARK_OFFSET: u64 = 0x0000007C; /* RX watermark reg */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 41 to 43)\n-pub(crate) const FXMAC_JUMBOMAXLEN_OFFSET:u64 = 0x00000048;/* Jumbo max length reg */\n-pub(crate) const FXMAC_GEM_HSMAC:u32 = 0x0050;               /* Hs mac config register*/\n-pub(crate) const FXMAC_RXWATERMARK_OFFSET:u64 = 0x0000007C;/* RX watermark reg */\n+pub(crate) const FXMAC_HASHL_OFFSET: u64 = 0x00000080; /* Hash Low address reg */\n+pub(crate) const FXMAC_HASHH_OFFSET: u64 = 0x00000084; /* Hash High address reg */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 45 to 46)\n-pub(crate) const FXMAC_HASHL_OFFSET:u64 = 0x00000080;/* Hash Low address reg */\n-pub(crate) const FXMAC_HASHH_OFFSET:u64 = 0x00000084;/* Hash High address reg */\n+pub(crate) const FXMAC_GEM_SA1B: u32 = 0x0088; /* Specific1 Bottom */\n+pub(crate) const FXMAC_GEM_SA1T: u32 = 0x008C; /* Specific1 Top */\n+pub(crate) const FXMAC_GEM_SA2B: u32 = 0x0090; /* Specific2 Bottom */\n+pub(crate) const FXMAC_GEM_SA2T: u32 = 0x0094; /* Specific2 Top */\n+pub(crate) const FXMAC_GEM_SA3B: u32 = 0x0098; /* Specific3 Bottom */\n+pub(crate) const FXMAC_GEM_SA3T: u32 = 0x009C; /* Specific3 Top */\n+pub(crate) const FXMAC_GEM_SA4B: u32 = 0x00A0; /* Specific4 Bottom */\n+pub(crate) const FXMAC_GEM_SA4T: u32 = 0x00A4; /* Specific4 Top */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 48 to 55)\n-pub(crate) const FXMAC_GEM_SA1B:u32 = 0x0088;          /* Specific1 Bottom */\n-pub(crate) const FXMAC_GEM_SA1T:u32 = 0x008C;          /* Specific1 Top */\n-pub(crate) const FXMAC_GEM_SA2B:u32 = 0x0090;          /* Specific2 Bottom */\n-pub(crate) const FXMAC_GEM_SA2T:u32 = 0x0094;          /* Specific2 Top */\n-pub(crate) const FXMAC_GEM_SA3B:u32 = 0x0098;          /* Specific3 Bottom */\n-pub(crate) const FXMAC_GEM_SA3T:u32 = 0x009C;          /* Specific3 Top */\n-pub(crate) const FXMAC_GEM_SA4B:u32 = 0x00A0;          /* Specific4 Bottom */\n-pub(crate) const FXMAC_GEM_SA4T:u32 = 0x00A4;          /* Specific4 Top */\n+pub(crate) const FXMAC_MATCH1_OFFSET: u64 = 0x000000A8; /* Type ID1 Match reg */\n+pub(crate) const FXMAC_MATCH2_OFFSET: u64 = 0x000000AC; /* Type ID2 Match reg */\n+pub(crate) const FXMAC_MATCH3_OFFSET: u64 = 0x000000B0; /* Type ID3 Match reg */\n+pub(crate) const FXMAC_MATCH4_OFFSET: u64 = 0x000000B4; /* Type ID4 Match reg */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 57 to 60)\n-pub(crate) const FXMAC_MATCH1_OFFSET:u64 = 0x000000A8;/* Type ID1 Match reg */\n-pub(crate) const FXMAC_MATCH2_OFFSET:u64 = 0x000000AC;/* Type ID2 Match reg */\n-pub(crate) const FXMAC_MATCH3_OFFSET:u64 = 0x000000B0;/* Type ID3 Match reg */\n-pub(crate) const FXMAC_MATCH4_OFFSET:u64 = 0x000000B4;/* Type ID4 Match reg */\n+pub(crate) const FXMAC_STRETCH_OFFSET: u64 = 0x000000BC; /* IPG Stretch reg */\n+pub(crate) const FXMAC_REVISION_REG_OFFSET: u64 = 0x000000FC; /*   identification number and module revision */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 62 to 63)\n-pub(crate) const FXMAC_STRETCH_OFFSET:u64 = 0x000000BC;     /* IPG Stretch reg */\n-pub(crate) const FXMAC_REVISION_REG_OFFSET:u64 = 0x000000FC;/*   identification number and module revision */\n+pub(crate) const FXMAC_OCTTXL_OFFSET: u64 = 0x00000100; /* Octects transmitted Low reg */\n+pub(crate) const FXMAC_OCTTXH_OFFSET: u64 = 0x00000104; /* Octects transmitted High reg */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 65 to 66)\n-pub(crate) const FXMAC_OCTTXL_OFFSET:u64 = 0x00000100;/* Octects transmitted Low reg */\n-pub(crate) const FXMAC_OCTTXH_OFFSET:u64 = 0x00000104;/* Octects transmitted High reg */\n+pub(crate) const FXMAC_TXCNT_OFFSET: u64 = 0x00000108; /* Error-free Frmaes transmitted counter */\n+pub(crate) const FXMAC_TXBCCNT_OFFSET: u64 = 0x0000010C; /* Error-free Broadcast Frames counter*/\n+pub(crate) const FXMAC_TXMCCNT_OFFSET: u64 = 0x00000110; /* Error-free Multicast Frame counter */\n+pub(crate) const FXMAC_TXPAUSECNT_OFFSET: u64 = 0x00000114; /* Pause Frames Transmitted Counter */\n+pub(crate) const FXMAC_TX64CNT_OFFSET: u64 = 0x00000118; /* Error-free 64 byte Frames Transmitted counter */\n+pub(crate) const FXMAC_TX65CNT_OFFSET: u64 = 0x0000011C; /* Error-free 65-127 byte Frames Transmitted counter */\n+pub(crate) const FXMAC_TX128CNT_OFFSET: u64 = 0x00000120; /* Error-free 128-255 byte Frames Transmitted counter*/\n+pub(crate) const FXMAC_TX256CNT_OFFSET: u64 = 0x00000124; /* Error-free 256-511 byte Frames transmitted counter */\n+pub(crate) const FXMAC_TX512CNT_OFFSET: u64 = 0x00000128; /* Error-free 512-1023 byte Frames transmitted counter */\n+pub(crate) const FXMAC_TX1024CNT_OFFSET: u64 = 0x0000012C; /* Error-free 1024-1518 byte Frames transmitted counter */\n+pub(crate) const FXMAC_TX1519CNT_OFFSET: u64 = 0x00000130; /* Error-free larger than 1519 byte Frames transmitted counter */\n+pub(crate) const FXMAC_TXURUNCNT_OFFSET: u64 = 0x00000134; /* TX under run error counter */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 68 to 79)\n-pub(crate) const FXMAC_TXCNT_OFFSET:u64 = 0x00000108;     /* Error-free Frmaes transmitted counter */\n-pub(crate) const FXMAC_TXBCCNT_OFFSET:u64 = 0x0000010C;   /* Error-free Broadcast Frames counter*/\n-pub(crate) const FXMAC_TXMCCNT_OFFSET:u64 = 0x00000110;   /* Error-free Multicast Frame counter */\n-pub(crate) const FXMAC_TXPAUSECNT_OFFSET:u64 = 0x00000114;/* Pause Frames Transmitted Counter */\n-pub(crate) const FXMAC_TX64CNT_OFFSET:u64 = 0x00000118;   /* Error-free 64 byte Frames Transmitted counter */\n-pub(crate) const FXMAC_TX65CNT_OFFSET:u64 = 0x0000011C;   /* Error-free 65-127 byte Frames Transmitted counter */\n-pub(crate) const FXMAC_TX128CNT_OFFSET:u64 = 0x00000120;  /* Error-free 128-255 byte Frames Transmitted counter*/\n-pub(crate) const FXMAC_TX256CNT_OFFSET:u64 = 0x00000124;  /* Error-free 256-511 byte Frames transmitted counter */\n-pub(crate) const FXMAC_TX512CNT_OFFSET:u64 = 0x00000128;  /* Error-free 512-1023 byte Frames transmitted counter */\n-pub(crate) const FXMAC_TX1024CNT_OFFSET:u64 = 0x0000012C; /* Error-free 1024-1518 byte Frames transmitted counter */\n-pub(crate) const FXMAC_TX1519CNT_OFFSET:u64 = 0x00000130; /* Error-free larger than 1519 byte Frames transmitted counter */\n-pub(crate) const FXMAC_TXURUNCNT_OFFSET:u64 = 0x00000134; /* TX under run error counter */\n+pub(crate) const FXMAC_SNGLCOLLCNT_OFFSET: u64 = 0x00000138; /* Single Collision Frame Counter */\n+pub(crate) const FXMAC_MULTICOLLCNT_OFFSET: u64 = 0x0000013C; /* Multiple Collision Frame Counter */\n+pub(crate) const FXMAC_EXCESSCOLLCNT_OFFSET: u64 = 0x00000140; /* Excessive Collision Frame Counter */\n+pub(crate) const FXMAC_LATECOLLCNT_OFFSET: u64 = 0x00000144; /* Late Collision Frame Counter */\n+pub(crate) const FXMAC_TXDEFERCNT_OFFSET: u64 = 0x00000148; /* Deferred Transmission Frame Counter */\n+pub(crate) const FXMAC_TXCSENSECNT_OFFSET: u64 = 0x0000014C; /* Transmit Carrier Sense Error Counter */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 81 to 86)\n-pub(crate) const FXMAC_SNGLCOLLCNT_OFFSET:u64 = 0x00000138;  /* Single Collision Frame Counter */\n-pub(crate) const FXMAC_MULTICOLLCNT_OFFSET:u64 = 0x0000013C; /* Multiple Collision Frame Counter */\n-pub(crate) const FXMAC_EXCESSCOLLCNT_OFFSET:u64 = 0x00000140;/* Excessive Collision Frame Counter */\n-pub(crate) const FXMAC_LATECOLLCNT_OFFSET:u64 = 0x00000144;  /* Late Collision Frame Counter */\n-pub(crate) const FXMAC_TXDEFERCNT_OFFSET:u64 = 0x00000148;   /* Deferred Transmission Frame Counter */\n-pub(crate) const FXMAC_TXCSENSECNT_OFFSET:u64 = 0x0000014C;  /* Transmit Carrier Sense Error Counter */\n+pub(crate) const FXMAC_OCTRXL_OFFSET: u64 = 0x00000150; /* Octects Received register Low */\n+pub(crate) const FXMAC_OCTRXH_OFFSET: u64 = 0x00000154; /* Octects Received register High */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 88 to 89)\n-pub(crate) const FXMAC_OCTRXL_OFFSET:u64 = 0x00000150;/* Octects Received register Low */\n-pub(crate) const FXMAC_OCTRXH_OFFSET:u64 = 0x00000154;/* Octects Received register High */\n+pub(crate) const FXMAC_RXCNT_OFFSET: u64 = 0x00000158; /* Error-free Frames Received Counter */\n+pub(crate) const FXMAC_RXBROADCNT_OFFSET: u64 = 0x0000015C; /* Error-free Broadcast Frames Received Counter */\n+pub(crate) const FXMAC_RXMULTICNT_OFFSET: u64 = 0x00000160; /* Error-free Multicast Frames Received Counter */\n+pub(crate) const FXMAC_RXPAUSECNT_OFFSET: u64 = 0x00000164; /* Pause Frames Received Counter */\n+pub(crate) const FXMAC_RX64CNT_OFFSET: u64 = 0x00000168; /* Error-free 64 byte Frames Received Counter */\n+pub(crate) const FXMAC_RX65CNT_OFFSET: u64 = 0x0000016C; /* Error-free 65-127 byte Frames Received Counter */\n+pub(crate) const FXMAC_RX128CNT_OFFSET: u64 = 0x00000170; /* Error-free 128-255 byte Frames Received Counter */\n+pub(crate) const FXMAC_RX256CNT_OFFSET: u64 = 0x00000174; /* Error-free 256-512 byte Frames Received Counter */\n+pub(crate) const FXMAC_RX512CNT_OFFSET: u64 = 0x00000178; /* Error-free 512-1023 byte Frames Received Counter */\n+pub(crate) const FXMAC_RX1024CNT_OFFSET: u64 = 0x0000017C; /* Error-free 1024-1518 byte Frames Received Counter */\n+pub(crate) const FXMAC_RX1519CNT_OFFSET: u64 = 0x00000180; /* Error-free 1519-max byte Frames Received Counter */\n+pub(crate) const FXMAC_RXUNDRCNT_OFFSET: u64 = 0x00000184; /* Undersize Frames Received Counter */\n+pub(crate) const FXMAC_RXOVRCNT_OFFSET: u64 = 0x00000188; /* Oversize Frames Received Counter */\n+pub(crate) const FXMAC_RXJABCNT_OFFSET: u64 = 0x0000018C; /* Jabbers Received Counter */\n+pub(crate) const FXMAC_RXFCSCNT_OFFSET: u64 = 0x00000190; /* Frame Check Sequence Error Counter */\n+pub(crate) const FXMAC_RXLENGTHCNT_OFFSET: u64 = 0x00000194; /* Length Field Error Counter */\n+pub(crate) const FXMAC_RXSYMBCNT_OFFSET: u64 = 0x00000198; /* Symbol Error Counter */\n+pub(crate) const FXMAC_RXALIGNCNT_OFFSET: u64 = 0x0000019C; /* Alignment Error Counter */\n+pub(crate) const FXMAC_RXRESERRCNT_OFFSET: u64 = 0x000001A0; /* Receive Resource Error Counter */\n+pub(crate) const FXMAC_RXORCNT_OFFSET: u64 = 0x000001A4; /* Receive Overrun Counter */\n+pub(crate) const FXMAC_RXIPCCNT_OFFSET: u64 = 0x000001A8; /* IP header Checksum Error Counter */\n+pub(crate) const FXMAC_RXTCPCCNT_OFFSET: u64 = 0x000001AC; /* TCP Checksum Error Counter */\n+pub(crate) const FXMAC_RXUDPCCNT_OFFSET: u64 = 0x000001B0; /* UDP Checksum Error Counter */\n+pub(crate) const FXMAC_LAST_OFFSET: u64 = 0x000001B4; /* Last statistic counter offset, for clearing */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 91 to 114)\n-pub(crate) const FXMAC_RXCNT_OFFSET:u64 = 0x00000158;      /* Error-free Frames Received Counter */\n-pub(crate) const FXMAC_RXBROADCNT_OFFSET:u64 = 0x0000015C; /* Error-free Broadcast Frames Received Counter */\n-pub(crate) const FXMAC_RXMULTICNT_OFFSET:u64 = 0x00000160; /* Error-free Multicast Frames Received Counter */\n-pub(crate) const FXMAC_RXPAUSECNT_OFFSET:u64 = 0x00000164; /* Pause Frames Received Counter */\n-pub(crate) const FXMAC_RX64CNT_OFFSET:u64 = 0x00000168;    /* Error-free 64 byte Frames Received Counter */\n-pub(crate) const FXMAC_RX65CNT_OFFSET:u64 = 0x0000016C;    /* Error-free 65-127 byte Frames Received Counter */\n-pub(crate) const FXMAC_RX128CNT_OFFSET:u64 = 0x00000170;   /* Error-free 128-255 byte Frames Received Counter */\n-pub(crate) const FXMAC_RX256CNT_OFFSET:u64 = 0x00000174;   /* Error-free 256-512 byte Frames Received Counter */\n-pub(crate) const FXMAC_RX512CNT_OFFSET:u64 = 0x00000178;   /* Error-free 512-1023 byte Frames Received Counter */\n-pub(crate) const FXMAC_RX1024CNT_OFFSET:u64 = 0x0000017C;  /* Error-free 1024-1518 byte Frames Received Counter */\n-pub(crate) const FXMAC_RX1519CNT_OFFSET:u64 = 0x00000180;  /* Error-free 1519-max byte Frames Received Counter */\n-pub(crate) const FXMAC_RXUNDRCNT_OFFSET:u64 = 0x00000184;  /* Undersize Frames Received Counter */\n-pub(crate) const FXMAC_RXOVRCNT_OFFSET:u64 = 0x00000188;   /* Oversize Frames Received Counter */\n-pub(crate) const FXMAC_RXJABCNT_OFFSET:u64 = 0x0000018C;   /* Jabbers Received Counter */\n-pub(crate) const FXMAC_RXFCSCNT_OFFSET:u64 = 0x00000190;   /* Frame Check Sequence Error Counter */\n-pub(crate) const FXMAC_RXLENGTHCNT_OFFSET:u64 = 0x00000194;/* Length Field Error Counter */\n-pub(crate) const FXMAC_RXSYMBCNT_OFFSET:u64 = 0x00000198;  /* Symbol Error Counter */\n-pub(crate) const FXMAC_RXALIGNCNT_OFFSET:u64 = 0x0000019C; /* Alignment Error Counter */\n-pub(crate) const FXMAC_RXRESERRCNT_OFFSET:u64 = 0x000001A0;/* Receive Resource Error Counter */\n-pub(crate) const FXMAC_RXORCNT_OFFSET:u64 = 0x000001A4;    /* Receive Overrun Counter */\n-pub(crate) const FXMAC_RXIPCCNT_OFFSET:u64 = 0x000001A8;   /* IP header Checksum Error Counter */\n-pub(crate) const FXMAC_RXTCPCCNT_OFFSET:u64 = 0x000001AC;  /* TCP Checksum Error Counter */\n-pub(crate) const FXMAC_RXUDPCCNT_OFFSET:u64 = 0x000001B0;  /* UDP Checksum Error Counter */\n-pub(crate) const FXMAC_LAST_OFFSET:u64 = 0x000001B4;       /* Last statistic counter offset, for clearing */\n+pub(crate) const FXMAC_1588_SEC_OFFSET: u64 = 0x000001D0; /* 1588 second counter */\n+pub(crate) const FXMAC_1588_NANOSEC_OFFSET: u64 = 0x000001D4; /* 1588 nanosecond counter */\n+pub(crate) const FXMAC_1588_ADJ_OFFSET: u64 = 0x000001D8; /* 1588 nanosecond adjustment counter */\n+pub(crate) const FXMAC_1588_INC_OFFSET: u64 = 0x000001DC; /* 1588 nanosecond increment counter */\n+pub(crate) const FXMAC_PTP_TXSEC_OFFSET: u64 = 0x000001E0; /* 1588 PTP transmit second counter */\n+pub(crate) const FXMAC_PTP_TXNANOSEC_OFFSET: u64 = 0x000001E4; /* 1588 PTP transmit nanosecond counter */\n+pub(crate) const FXMAC_PTP_RXSEC_OFFSET: u64 = 0x000001E8; /* 1588 PTP receive second counter */\n+pub(crate) const FXMAC_PTP_RXNANOSEC_OFFSET: u64 = 0x000001EC; /* 1588 PTP receive nanosecond counter */\n+pub(crate) const FXMAC_PTPP_TXSEC_OFFSET: u64 = 0x000001F0; /* 1588 PTP peer transmit second counter */\n+pub(crate) const FXMAC_PTPP_TXNANOSEC_OFFSET: u64 = 0x000001F4; /* 1588 PTP peer transmit nanosecond counter */\n+pub(crate) const FXMAC_PTPP_RXSEC_OFFSET: u64 = 0x000001F8; /* 1588 PTP peer receive second counter */\n+pub(crate) const FXMAC_PTPP_RXNANOSEC_OFFSET: u64 = 0x000001FC; /* 1588 PTP peer receive nanosecond counter */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 116 to 127)\n-pub(crate) const FXMAC_1588_SEC_OFFSET:u64 = 0x000001D0;      /* 1588 second counter */\n-pub(crate) const FXMAC_1588_NANOSEC_OFFSET:u64 = 0x000001D4;  /* 1588 nanosecond counter */\n-pub(crate) const FXMAC_1588_ADJ_OFFSET:u64 = 0x000001D8;      /* 1588 nanosecond adjustment counter */\n-pub(crate) const FXMAC_1588_INC_OFFSET:u64 = 0x000001DC;      /* 1588 nanosecond increment counter */\n-pub(crate) const FXMAC_PTP_TXSEC_OFFSET:u64 = 0x000001E0;     /* 1588 PTP transmit second counter */\n-pub(crate) const FXMAC_PTP_TXNANOSEC_OFFSET:u64 = 0x000001E4; /* 1588 PTP transmit nanosecond counter */\n-pub(crate) const FXMAC_PTP_RXSEC_OFFSET:u64 = 0x000001E8;     /* 1588 PTP receive second counter */\n-pub(crate) const FXMAC_PTP_RXNANOSEC_OFFSET:u64 = 0x000001EC; /* 1588 PTP receive nanosecond counter */\n-pub(crate) const FXMAC_PTPP_TXSEC_OFFSET:u64 = 0x000001F0;    /* 1588 PTP peer transmit second counter */\n-pub(crate) const FXMAC_PTPP_TXNANOSEC_OFFSET:u64 = 0x000001F4;/* 1588 PTP peer transmit nanosecond counter */\n-pub(crate) const FXMAC_PTPP_RXSEC_OFFSET:u64 = 0x000001F8;    /* 1588 PTP peer receive second counter */\n-pub(crate) const FXMAC_PTPP_RXNANOSEC_OFFSET:u64 = 0x000001FC;/* 1588 PTP peer receive nanosecond counter */\n+pub(crate) const FXMAC_PCS_CONTROL_OFFSET: u64 = 0x00000200; /* All PCS registers */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 129 to 129)\n-pub(crate) const FXMAC_PCS_CONTROL_OFFSET:u64 = 0x00000200;/* All PCS registers */\n+pub(crate) const FXMAC_PCS_STATUS_OFFSET: u64 = 0x00000204; /* All PCS status */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 131 to 131)\n-pub(crate) const FXMAC_PCS_STATUS_OFFSET:u64 =  0x00000204;/* All PCS status */\n+pub(crate) const FXMAC_PCS_AN_LP_OFFSET: u64 = 0x00000214; /* All PCS link partner's base page */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 133 to 133)\n-pub(crate) const FXMAC_PCS_AN_LP_OFFSET:u64 = 0x00000214; /* All PCS link partner's base page */\n+pub(crate) const FXMAC_DESIGNCFG_DEBUG1_OFFSET: u64 = 0x00000280; /* Design Configuration Register 1 */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 135 to 135)\n-pub(crate) const FXMAC_DESIGNCFG_DEBUG1_OFFSET:u64 = 0x00000280;/* Design Configuration Register 1 */\n+pub(crate) const FXMAC_DESIGNCFG_DEBUG2_OFFSET: u64 = 0x00000284; /* Design Configuration Register 2 */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 137 to 137)\n-pub(crate) const FXMAC_DESIGNCFG_DEBUG2_OFFSET:u64 = 0x00000284;/* Design Configuration Register 2 */\n+pub(crate) const FXMAC_INTQ1_STS_OFFSET: u64 = 0x00000400; /* Interrupt Q1 Status reg */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 139 to 139)\n-pub(crate) const FXMAC_INTQ1_STS_OFFSET:u64 = 0x00000400;/* Interrupt Q1 Status reg */\n+pub(crate) const FXMAC_TXQ1BASE_OFFSET: u64 = 0x00000440; /* TX Q1 Base address reg */\n+pub(crate) const FXMAC_RXQ1BASE_OFFSET: u64 = 0x00000480; /* RX Q1 Base address reg */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 141 to 144)\n-pub(crate) const FXMAC_TXQ1BASE_OFFSET:u64 = 0x00000440;/* TX Q1 Base address reg */\n-pub(crate) const FXMAC_RXQ1BASE_OFFSET:u64 = 0x00000480;/* RX Q1 Base address reg */\n-\n-pub(crate) const FXMAC_RXBUFQ1_SIZE_OFFSET:u64 = 0x000004a0;/* Receive Buffer Size */\n+pub(crate) const FXMAC_RXBUFQ1_SIZE_OFFSET: u64 = 0x000004a0; /* Receive Buffer Size */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 149 to 149)\n-pub(crate) const FXMAC_RXBUFQX_SIZE_MASK:u32 = GENMASK(7, 0);\n+pub(crate) const FXMAC_RXBUFQX_SIZE_MASK: u32 = GENMASK(7, 0);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 151 to 154)\n-pub(crate) const FXMAC_MSBBUF_TXQBASE_OFFSET:u64 = 0x000004C8;/* MSB Buffer TX Q Base reg */\n-pub(crate) const FXMAC_MSBBUF_RXQBASE_OFFSET:u64 = 0x000004D4;/* MSB Buffer RX Q Base reg */\n-pub(crate) const FXMAC_TXQSEGALLOC_QLOWER_OFFSET:u64 = 0x000005A0;/* Transmit SRAM segment distribution */\n-pub(crate) const FXMAC_INTQ1_IER_OFFSET:u64 = 0x00000600;     /* Interrupt Q1 Enable reg */\n+pub(crate) const FXMAC_MSBBUF_TXQBASE_OFFSET: u64 = 0x000004C8; /* MSB Buffer TX Q Base reg */\n+pub(crate) const FXMAC_MSBBUF_RXQBASE_OFFSET: u64 = 0x000004D4; /* MSB Buffer RX Q Base reg */\n+pub(crate) const FXMAC_TXQSEGALLOC_QLOWER_OFFSET: u64 = 0x000005A0; /* Transmit SRAM segment distribution */\n+pub(crate) const FXMAC_INTQ1_IER_OFFSET: u64 = 0x00000600; /* Interrupt Q1 Enable reg */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 159 to 159)\n-pub(crate) const FXMAC_INTQ1_IDR_OFFSET:u64 = 0x00000620;/* Interrupt Q1 Disable reg */\n+pub(crate) const FXMAC_INTQ1_IDR_OFFSET: u64 = 0x00000620; /* Interrupt Q1 Disable reg */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 164 to 164)\n-pub(crate) const FXMAC_INTQ1_IMR_OFFSET:u64 = 0x00000640;/* Interrupt Q1 Mask reg */\n+pub(crate) const FXMAC_INTQ1_IMR_OFFSET: u64 = 0x00000640; /* Interrupt Q1 Mask reg */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 166 to 168)\n-pub(crate) const FXMAC_GEM_USX_CONTROL_OFFSET:u64 = 0x0A80; /* High speed PCS control register */\n-pub(crate) const FXMAC_TEST_CONTROL_OFFSET:u64 = 0x0A84;    /* USXGMII Test Control Register */\n-pub(crate) const FXMAC_GEM_USX_STATUS_OFFSET:u64 = 0x0A88;    /* USXGMII Status Register */\n+pub(crate) const FXMAC_GEM_USX_CONTROL_OFFSET: u64 = 0x0A80; /* High speed PCS control register */\n+pub(crate) const FXMAC_TEST_CONTROL_OFFSET: u64 = 0x0A84; /* USXGMII Test Control Register */\n+pub(crate) const FXMAC_GEM_USX_STATUS_OFFSET: u64 = 0x0A88; /* USXGMII Status Register */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 170 to 195)\n-pub(crate) const FXMAC_GEM_SRC_SEL_LN:u32 = 0x1C04;\n-pub(crate) const FXMAC_GEM_DIV_SEL0_LN:u32 = 0x1C08;\n-pub(crate) const FXMAC_GEM_DIV_SEL1_LN:u32 = 0x1C0C;\n-pub(crate) const FXMAC_GEM_PMA_XCVR_POWER_STATE:u32 = 0x1C10;\n-pub(crate) const FXMAC_GEM_SPEED_MODE:u32 = 0x1C14;\n-pub(crate) const FXMAC_GEM_MII_SELECT:u32 = 0x1C18;\n-pub(crate) const FXMAC_GEM_SEL_MII_ON_RGMII:u32 = 0x1C1C;\n-pub(crate) const FXMAC_GEM_TX_CLK_SEL0:u32 = 0x1C20;\n-pub(crate) const FXMAC_GEM_TX_CLK_SEL1:u32 = 0x1C24;\n-pub(crate) const FXMAC_GEM_TX_CLK_SEL2:u32 = 0x1C28;\n-pub(crate) const FXMAC_GEM_TX_CLK_SEL3:u32 = 0x1C2C;\n-pub(crate) const FXMAC_GEM_RX_CLK_SEL0:u32 = 0x1C30;\n-pub(crate) const FXMAC_GEM_RX_CLK_SEL1:u32 = 0x1C34;\n-pub(crate) const FXMAC_GEM_CLK_250M_DIV10_DIV100_SEL:u32 = 0x1C38;\n-pub(crate) const FXMAC_GEM_TX_CLK_SEL5:u32 = 0x1C3C;\n-pub(crate) const FXMAC_GEM_TX_CLK_SEL6:u32 = 0x1C40;\n-pub(crate) const FXMAC_GEM_RX_CLK_SEL4:u32 = 0x1C44;\n-pub(crate) const FXMAC_GEM_RX_CLK_SEL5:u32 = 0x1C48;\n-pub(crate) const FXMAC_GEM_TX_CLK_SEL3_0:u32 = 0x1C70;\n-pub(crate) const FXMAC_GEM_TX_CLK_SEL4_0:u32 = 0x1C74;\n-pub(crate) const FXMAC_GEM_RX_CLK_SEL3_0:u32 = 0x1C78;\n-pub(crate) const FXMAC_GEM_RX_CLK_SEL4_0:u32 = 0x1C7C;\n-pub(crate) const FXMAC_GEM_RGMII_TX_CLK_SEL0:u32 = 0x1C80;\n-pub(crate) const FXMAC_GEM_RGMII_TX_CLK_SEL1:u32 = 0x1C84;\n-pub(crate) const FXMAC_GEM_MODE_SEL_OFFSET:u64 = 0xDC00;\n-pub(crate) const FXMAC_LOOPBACK_SEL_OFFSET:u64 = 0xDC04;\n+pub(crate) const FXMAC_GEM_SRC_SEL_LN: u32 = 0x1C04;\n+pub(crate) const FXMAC_GEM_DIV_SEL0_LN: u32 = 0x1C08;\n+pub(crate) const FXMAC_GEM_DIV_SEL1_LN: u32 = 0x1C0C;\n+pub(crate) const FXMAC_GEM_PMA_XCVR_POWER_STATE: u32 = 0x1C10;\n+pub(crate) const FXMAC_GEM_SPEED_MODE: u32 = 0x1C14;\n+pub(crate) const FXMAC_GEM_MII_SELECT: u32 = 0x1C18;\n+pub(crate) const FXMAC_GEM_SEL_MII_ON_RGMII: u32 = 0x1C1C;\n+pub(crate) const FXMAC_GEM_TX_CLK_SEL0: u32 = 0x1C20;\n+pub(crate) const FXMAC_GEM_TX_CLK_SEL1: u32 = 0x1C24;\n+pub(crate) const FXMAC_GEM_TX_CLK_SEL2: u32 = 0x1C28;\n+pub(crate) const FXMAC_GEM_TX_CLK_SEL3: u32 = 0x1C2C;\n+pub(crate) const FXMAC_GEM_RX_CLK_SEL0: u32 = 0x1C30;\n+pub(crate) const FXMAC_GEM_RX_CLK_SEL1: u32 = 0x1C34;\n+pub(crate) const FXMAC_GEM_CLK_250M_DIV10_DIV100_SEL: u32 = 0x1C38;\n+pub(crate) const FXMAC_GEM_TX_CLK_SEL5: u32 = 0x1C3C;\n+pub(crate) const FXMAC_GEM_TX_CLK_SEL6: u32 = 0x1C40;\n+pub(crate) const FXMAC_GEM_RX_CLK_SEL4: u32 = 0x1C44;\n+pub(crate) const FXMAC_GEM_RX_CLK_SEL5: u32 = 0x1C48;\n+pub(crate) const FXMAC_GEM_TX_CLK_SEL3_0: u32 = 0x1C70;\n+pub(crate) const FXMAC_GEM_TX_CLK_SEL4_0: u32 = 0x1C74;\n+pub(crate) const FXMAC_GEM_RX_CLK_SEL3_0: u32 = 0x1C78;\n+pub(crate) const FXMAC_GEM_RX_CLK_SEL4_0: u32 = 0x1C7C;\n+pub(crate) const FXMAC_GEM_RGMII_TX_CLK_SEL0: u32 = 0x1C80;\n+pub(crate) const FXMAC_GEM_RGMII_TX_CLK_SEL1: u32 = 0x1C84;\n+pub(crate) const FXMAC_GEM_MODE_SEL_OFFSET: u64 = 0xDC00;\n+pub(crate) const FXMAC_LOOPBACK_SEL_OFFSET: u64 = 0xDC04;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 197 to 197)\n-pub(crate) const FXMAC_TAIL_ENABLE:u64 = 0xe7c;  /*Enable tail Register*/ \n+pub(crate) const FXMAC_TAIL_ENABLE: u64 = 0xe7c; /*Enable tail Register*/\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 200 to 200)\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 207 to 210)\n-pub(crate) const FXMAC_IXR_PTPPSTX_MASK:u32 = BIT(25);  /* PTP Pdelay_resp TXed */\n-pub(crate) const FXMAC_IXR_PTPPDRTX_MASK:u32 = BIT(24); /* PTP Pdelay_req TXed */\n-pub(crate) const FXMAC_IXR_PTPPSRX_MASK:u32 = BIT(23);  /* PTP Pdelay_resp RXed */\n-pub(crate) const FXMAC_IXR_PTPPDRRX_MASK:u32 = BIT(22); /* PTP Pdelay_req RXed */\n+pub(crate) const FXMAC_IXR_PTPPSTX_MASK: u32 = BIT(25); /* PTP Pdelay_resp TXed */\n+pub(crate) const FXMAC_IXR_PTPPDRTX_MASK: u32 = BIT(24); /* PTP Pdelay_req TXed */\n+pub(crate) const FXMAC_IXR_PTPPSRX_MASK: u32 = BIT(23); /* PTP Pdelay_resp RXed */\n+pub(crate) const FXMAC_IXR_PTPPDRRX_MASK: u32 = BIT(22); /* PTP Pdelay_req RXed */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 212 to 215)\n-pub(crate) const FXMAC_IXR_PTPSTX_MASK:u32 = BIT(21);  /* PTP Sync TXed */\n-pub(crate) const FXMAC_IXR_PTPDRTX_MASK:u32 = BIT(20); /* PTP Delay_req TXed */\n-pub(crate) const FXMAC_IXR_PTPSRX_MASK:u32 = BIT(19);  /* PTP Sync RXed */\n-pub(crate) const FXMAC_IXR_PTPDRRX_MASK:u32 = BIT(18); /* PTP Delay_req RXed */\n+pub(crate) const FXMAC_IXR_PTPSTX_MASK: u32 = BIT(21); /* PTP Sync TXed */\n+pub(crate) const FXMAC_IXR_PTPDRTX_MASK: u32 = BIT(20); /* PTP Delay_req TXed */\n+pub(crate) const FXMAC_IXR_PTPSRX_MASK: u32 = BIT(19); /* PTP Sync RXed */\n+pub(crate) const FXMAC_IXR_PTPDRRX_MASK: u32 = BIT(18); /* PTP Delay_req RXed */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 217 to 231)\n-pub(crate) const FXMAC_IXR_PAUSETX_MASK:u32 = BIT(14);    /* Pause frame transmitted */\n-pub(crate) const FXMAC_IXR_PAUSEZERO_MASK:u32 = BIT(13);  /* Pause time has reached zero */\n-pub(crate) const FXMAC_IXR_PAUSENZERO_MASK:u32 = BIT(12); /* Pause frame received */\n-pub(crate) const FXMAC_IXR_HRESPNOK_MASK:u32 = BIT(11);   /* hresp not ok */\n-pub(crate) const FXMAC_IXR_RXOVR_MASK:u32 = BIT(10);      /* Receive overrun occurred */\n-pub(crate) const FXMAC_IXR_LINKCHANGE_MASK:u32 = BIT(9);   /* link status change */\n-pub(crate) const FXMAC_IXR_TXCOMPL_MASK:u32 = BIT(7);     /* Frame transmitted ok */\n-pub(crate) const FXMAC_IXR_TXEXH_MASK:u32 = BIT(6);       /* Transmit err occurred or no buffers*/\n-pub(crate) const FXMAC_IXR_RETRY_MASK:u32 = BIT(5);       /* Retry limit exceeded */\n-pub(crate) const FXMAC_IXR_URUN_MASK:u32 = BIT(4);        /* Transmit underrun */\n-pub(crate) const FXMAC_IXR_TXUSED_MASK:u32 = BIT(3);      /* Tx buffer used bit read */\n-pub(crate) const FXMAC_IXR_RXUSED_MASK:u32 = BIT(2);      /* Rx buffer used bit read */\n-pub(crate) const FXMAC_IXR_RXCOMPL_MASK:u32 = BIT(1);     /* Frame received ok */\n-pub(crate) const FXMAC_IXR_MGMNT_MASK:u32 = BIT(0);       /* PHY management complete */\n-pub(crate) const FXMAC_IXR_ALL_MASK:u32 = GENMASK(31, 0); /* Everything! */\n+pub(crate) const FXMAC_IXR_PAUSETX_MASK: u32 = BIT(14); /* Pause frame transmitted */\n+pub(crate) const FXMAC_IXR_PAUSEZERO_MASK: u32 = BIT(13); /* Pause time has reached zero */\n+pub(crate) const FXMAC_IXR_PAUSENZERO_MASK: u32 = BIT(12); /* Pause frame received */\n+pub(crate) const FXMAC_IXR_HRESPNOK_MASK: u32 = BIT(11); /* hresp not ok */\n+pub(crate) const FXMAC_IXR_RXOVR_MASK: u32 = BIT(10); /* Receive overrun occurred */\n+pub(crate) const FXMAC_IXR_LINKCHANGE_MASK: u32 = BIT(9); /* link status change */\n+pub(crate) const FXMAC_IXR_TXCOMPL_MASK: u32 = BIT(7); /* Frame transmitted ok */\n+pub(crate) const FXMAC_IXR_TXEXH_MASK: u32 = BIT(6); /* Transmit err occurred or no buffers*/\n+pub(crate) const FXMAC_IXR_RETRY_MASK: u32 = BIT(5); /* Retry limit exceeded */\n+pub(crate) const FXMAC_IXR_URUN_MASK: u32 = BIT(4); /* Transmit underrun */\n+pub(crate) const FXMAC_IXR_TXUSED_MASK: u32 = BIT(3); /* Tx buffer used bit read */\n+pub(crate) const FXMAC_IXR_RXUSED_MASK: u32 = BIT(2); /* Rx buffer used bit read */\n+pub(crate) const FXMAC_IXR_RXCOMPL_MASK: u32 = BIT(1); /* Frame received ok */\n+pub(crate) const FXMAC_IXR_MGMNT_MASK: u32 = BIT(0); /* PHY management complete */\n+pub(crate) const FXMAC_IXR_ALL_MASK: u32 = GENMASK(31, 0); /* Everything! */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 233 to 233)\n-pub(crate) const FXMAC_IXR_TX_ERR_MASK:u32 = (FXMAC_IXR_TXEXH_MASK | FXMAC_IXR_RETRY_MASK | FXMAC_IXR_URUN_MASK);\n+pub(crate) const FXMAC_IXR_TX_ERR_MASK: u32 =\n+    (FXMAC_IXR_TXEXH_MASK | FXMAC_IXR_RETRY_MASK | FXMAC_IXR_URUN_MASK);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 235 to 235)\n-pub(crate) const FXMAC_IXR_RX_ERR_MASK:u32 = (FXMAC_IXR_HRESPNOK_MASK | FXMAC_IXR_RXUSED_MASK | FXMAC_IXR_RXOVR_MASK);\n+pub(crate) const FXMAC_IXR_RX_ERR_MASK: u32 =\n+    (FXMAC_IXR_HRESPNOK_MASK | FXMAC_IXR_RXUSED_MASK | FXMAC_IXR_RXOVR_MASK);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 237 to 237)\n-pub(crate) const FXMAC_INTR_MASK:u32 = (FXMAC_IXR_LINKCHANGE_MASK | FXMAC_IXR_TX_ERR_MASK | FXMAC_IXR_RX_ERR_MASK | FXMAC_IXR_RXCOMPL_MASK | FXMAC_IXR_TXCOMPL_MASK);\n+pub(crate) const FXMAC_INTR_MASK: u32 = (FXMAC_IXR_LINKCHANGE_MASK\n+    | FXMAC_IXR_TX_ERR_MASK\n+    | FXMAC_IXR_RX_ERR_MASK\n+    | FXMAC_IXR_RXCOMPL_MASK\n+    | FXMAC_IXR_TXCOMPL_MASK);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 242 to 242)\n-pub(crate) const FXMAC_NWCTRL_ENABLE_HS_MAC_MASK:u32 = BIT(31);\n+pub(crate) const FXMAC_NWCTRL_ENABLE_HS_MAC_MASK: u32 = BIT(31);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 244 to 244)\n-pub(crate) const FXMAC_NWCTRL_TWO_PT_FIVE_GIG_MASK:u32 = BIT(29); /* 2.5G operation selected */\n+pub(crate) const FXMAC_NWCTRL_TWO_PT_FIVE_GIG_MASK: u32 = BIT(29); /* 2.5G operation selected */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 246 to 250)\n-pub(crate) const FXMAC_NWCTRL_FLUSH_DPRAM_MASK:u32 = BIT(18); /* Flush a packet from Rx SRAM */\n-pub(crate) const FXMAC_NWCTRL_ZEROPAUSETX_MASK:u32 = BIT(11); /* Transmit zero quantum pause frame */\n-pub(crate) const FXMAC_NWCTRL_PAUSETX_MASK:u32 = BIT(11);     /* Transmit pause frame */\n-pub(crate) const FXMAC_NWCTRL_HALTTX_MASK:u32 = BIT(10);      /* Halt transmission after current frame */\n-pub(crate) const FXMAC_NWCTRL_STARTTX_MASK:u32 = BIT(9);      /* Start tx (tx_go) */\n+pub(crate) const FXMAC_NWCTRL_FLUSH_DPRAM_MASK: u32 = BIT(18); /* Flush a packet from Rx SRAM */\n+pub(crate) const FXMAC_NWCTRL_ZEROPAUSETX_MASK: u32 = BIT(11); /* Transmit zero quantum pause frame */\n+pub(crate) const FXMAC_NWCTRL_PAUSETX_MASK: u32 = BIT(11); /* Transmit pause frame */\n+pub(crate) const FXMAC_NWCTRL_HALTTX_MASK: u32 = BIT(10); /* Halt transmission after current frame */\n+pub(crate) const FXMAC_NWCTRL_STARTTX_MASK: u32 = BIT(9); /* Start tx (tx_go) */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 252 to 258)\n-pub(crate) const FXMAC_NWCTRL_STATWEN_MASK:u32 = BIT(7); /* Enable writing to stat counters */\n-pub(crate) const FXMAC_NWCTRL_STATINC_MASK:u32 = BIT(6); /* Increment statistic registers */\n-pub(crate) const FXMAC_NWCTRL_STATCLR_MASK:u32 = BIT(5); /* Clear statistic registers */\n-pub(crate) const FXMAC_NWCTRL_MDEN_MASK:u32 = BIT(4);    /* Enable MDIO port */\n-pub(crate) const FXMAC_NWCTRL_TXEN_MASK:u32 = BIT(3);    /* Enable transmit */\n-pub(crate) const FXMAC_NWCTRL_RXEN_MASK:u32 = BIT(2);    /* Enable receive */\n-pub(crate) const FXMAC_NWCTRL_LOOPBACK_LOCAL_MASK:u32 = BIT(1); /* Loopback local */\n+pub(crate) const FXMAC_NWCTRL_STATWEN_MASK: u32 = BIT(7); /* Enable writing to stat counters */\n+pub(crate) const FXMAC_NWCTRL_STATINC_MASK: u32 = BIT(6); /* Increment statistic registers */\n+pub(crate) const FXMAC_NWCTRL_STATCLR_MASK: u32 = BIT(5); /* Clear statistic registers */\n+pub(crate) const FXMAC_NWCTRL_MDEN_MASK: u32 = BIT(4); /* Enable MDIO port */\n+pub(crate) const FXMAC_NWCTRL_TXEN_MASK: u32 = BIT(3); /* Enable transmit */\n+pub(crate) const FXMAC_NWCTRL_RXEN_MASK: u32 = BIT(2); /* Enable receive */\n+pub(crate) const FXMAC_NWCTRL_LOOPBACK_LOCAL_MASK: u32 = BIT(1); /* Loopback local */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 260 to 261)\n-\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 265 to 271)\n-pub(crate) const FXMAC_NWCFG_BADPREAMBEN_MASK:u32 = BIT(29);       /* disable rejection of non-standard preamble */\n-pub(crate) const FXMAC_NWCFG_IPDSTRETCH_MASK:u32 = BIT(28);        /* enable transmit IPG */\n-pub(crate) const FXMAC_NWCFG_SGMII_MODE_ENABLE_MASK:u32 = BIT(27); /* SGMII mode enable */\n-pub(crate) const FXMAC_NWCFG_FCSIGNORE_MASK:u32 = BIT(26);         /* disable rejection of FCS error */\n-pub(crate) const FXMAC_NWCFG_HDRXEN_MASK:u32 = BIT(25);            /* RX half duplex */\n-pub(crate) const FXMAC_NWCFG_RXCHKSUMEN_MASK:u32 = BIT(24);        /* enable RX checksum offload */\n-pub(crate) const FXMAC_NWCFG_PAUSECOPYDI_MASK:u32 = BIT(23);       /* Do not copy pause Frames to memory */\n+pub(crate) const FXMAC_NWCFG_BADPREAMBEN_MASK: u32 = BIT(29); /* disable rejection of non-standard preamble */\n+pub(crate) const FXMAC_NWCFG_IPDSTRETCH_MASK: u32 = BIT(28); /* enable transmit IPG */\n+pub(crate) const FXMAC_NWCFG_SGMII_MODE_ENABLE_MASK: u32 = BIT(27); /* SGMII mode enable */\n+pub(crate) const FXMAC_NWCFG_FCSIGNORE_MASK: u32 = BIT(26); /* disable rejection of FCS error */\n+pub(crate) const FXMAC_NWCFG_HDRXEN_MASK: u32 = BIT(25); /* RX half duplex */\n+pub(crate) const FXMAC_NWCFG_RXCHKSUMEN_MASK: u32 = BIT(24); /* enable RX checksum offload */\n+pub(crate) const FXMAC_NWCFG_PAUSECOPYDI_MASK: u32 = BIT(23); /* Do not copy pause Frames to memory */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 273 to 276)\n-pub(crate) const FXMAC_NWCFG_DWIDTH_64_MASK:u32 = BIT(21);         /* 64 bit Data bus width */\n-pub(crate) const FXMAC_NWCFG_BUS_WIDTH_32_MASK:u32 = (0 << 21);\n-pub(crate) const FXMAC_NWCFG_BUS_WIDTH_64_MASK:u32 = (1 << 21);\n-pub(crate) const FXMAC_NWCFG_BUS_WIDTH_128_MASK:u32 = (2 << 21);\n+pub(crate) const FXMAC_NWCFG_DWIDTH_64_MASK: u32 = BIT(21); /* 64 bit Data bus width */\n+pub(crate) const FXMAC_NWCFG_BUS_WIDTH_32_MASK: u32 = (0 << 21);\n+pub(crate) const FXMAC_NWCFG_BUS_WIDTH_64_MASK: u32 = (1 << 21);\n+pub(crate) const FXMAC_NWCFG_BUS_WIDTH_128_MASK: u32 = (2 << 21);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 278 to 288)\n-pub(crate) const FXMAC_NWCFG_CLOCK_DIV224_MASK:u32 = (7 << 18);\n-pub(crate) const FXMAC_NWCFG_CLOCK_DIV128_MASK:u32 = (6 << 18);\n-pub(crate) const FXMAC_NWCFG_CLOCK_DIV96_MASK:u32 = (5 << 18);\n-pub(crate) const FXMAC_NWCFG_CLOCK_DIV64_MASK:u32 = (4 << 18);\n-pub(crate) const FXMAC_NWCFG_CLOCK_DIV48_MASK:u32 = (3 << 18);\n-pub(crate) const FXMAC_NWCFG_CLOCK_DIV32_MASK:u32 = (2 << 18);\n-pub(crate) const FXMAC_NWCFG_CLOCK_DIV16_MASK:u32 = (1 << 18);\n-pub(crate) const FXMAC_NWCFG_CLOCK_DIV8_MASK:u32 = (0 << 18);\n-pub(crate) const FXMAC_NWCFG_RESET_MASK:u32 = BIT(19);      /* reset value of mdc_clock_division*/\n-pub(crate) const FXMAC_NWCFG_MDC_SHIFT_MASK:u32 = 18;            /* shift bits for MDC */\n-pub(crate) const FXMAC_NWCFG_MDCCLKDIV_MASK:u32 = GENMASK(20, 18); /* MDC Mask PCLK divisor */\n+pub(crate) const FXMAC_NWCFG_CLOCK_DIV224_MASK: u32 = (7 << 18);\n+pub(crate) const FXMAC_NWCFG_CLOCK_DIV128_MASK: u32 = (6 << 18);\n+pub(crate) const FXMAC_NWCFG_CLOCK_DIV96_MASK: u32 = (5 << 18);\n+pub(crate) const FXMAC_NWCFG_CLOCK_DIV64_MASK: u32 = (4 << 18);\n+pub(crate) const FXMAC_NWCFG_CLOCK_DIV48_MASK: u32 = (3 << 18);\n+pub(crate) const FXMAC_NWCFG_CLOCK_DIV32_MASK: u32 = (2 << 18);\n+pub(crate) const FXMAC_NWCFG_CLOCK_DIV16_MASK: u32 = (1 << 18);\n+pub(crate) const FXMAC_NWCFG_CLOCK_DIV8_MASK: u32 = (0 << 18);\n+pub(crate) const FXMAC_NWCFG_RESET_MASK: u32 = BIT(19); /* reset value of mdc_clock_division*/\n+pub(crate) const FXMAC_NWCFG_MDC_SHIFT_MASK: u32 = 18; /* shift bits for MDC */\n+pub(crate) const FXMAC_NWCFG_MDCCLKDIV_MASK: u32 = GENMASK(20, 18); /* MDC Mask PCLK divisor */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 290 to 291)\n-pub(crate) const FXMAC_NWCFG_FCS_REMOVE_MASK:u32 = BIT(17);      /* FCS remove - setting this bit will cause received frames to be written to memory without their frame check sequence (last 4 bytes). */\n-pub(crate) const FXMAC_NWCFG_LENGTH_FIELD_ERROR_FRAME_DISCARD_MASK:u32 = BIT(16);    /* RX length error discard */\n+pub(crate) const FXMAC_NWCFG_FCS_REMOVE_MASK: u32 = BIT(17); /* FCS remove - setting this bit will cause received frames to be written to memory without their frame check sequence (last 4 bytes). */\n+pub(crate) const FXMAC_NWCFG_LENGTH_FIELD_ERROR_FRAME_DISCARD_MASK: u32 = BIT(16); /* RX length error discard */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 293 to 306)\n-pub(crate) const FXMAC_NWCFG_PAUSE_ENABLE_MASK:u32 = BIT(13);    /* Pause enable - when set, transmission will pause if a non-zero 802.3 classic pause frame is received and PFC has not been negotiated. */\n-pub(crate) const FXMAC_NWCFG_RETRYTESTEN_MASK:u32 = BIT(12); /* Retry test */\n-pub(crate) const FXMAC_NWCFG_PCSSEL_MASK:u32 = BIT(11);     /* PCS Select */\n-pub(crate) const FXMAC_NWCFG_1000_MASK:u32 = BIT(10);       /* Gigabit mode enable */\n-pub(crate) const FXMAC_NWCFG_XTADDMACHEN_MASK:u32 = BIT(9); /* External address match enable */\n-pub(crate) const FXMAC_NWCFG_1536RXEN_MASK:u32 = BIT(8);    /* Enable 1536 byte frames reception */\n-pub(crate) const FXMAC_NWCFG_UCASTHASHEN_MASK:u32 = BIT(7); /* Receive unicast hash frames */\n-pub(crate) const FXMAC_NWCFG_MCASTHASHEN_MASK:u32 = BIT(6); /* Receive multicast hash frames */\n-pub(crate) const FXMAC_NWCFG_BCASTDI_MASK:u32 = BIT(5);     /* Do not receive broadcast frames */\n-pub(crate) const FXMAC_NWCFG_COPYALLEN_MASK:u32 = BIT(4);   /* Copy all frames */\n-pub(crate) const FXMAC_NWCFG_JUMBO_MASK:u32 = BIT(3);       /* Jumbo frames */\n-pub(crate) const FXMAC_NWCFG_NVLANDISC_MASK:u32 = BIT(2);   /* Receive only VLAN frames */\n-pub(crate) const FXMAC_NWCFG_FDEN_MASK:u32 = BIT(1);        /* full duplex */\n-pub(crate) const FXMAC_NWCFG_100_MASK:u32 = BIT(0);         /* 100 Mbps */\n+pub(crate) const FXMAC_NWCFG_PAUSE_ENABLE_MASK: u32 = BIT(13); /* Pause enable - when set, transmission will pause if a non-zero 802.3 classic pause frame is received and PFC has not been negotiated. */\n+pub(crate) const FXMAC_NWCFG_RETRYTESTEN_MASK: u32 = BIT(12); /* Retry test */\n+pub(crate) const FXMAC_NWCFG_PCSSEL_MASK: u32 = BIT(11); /* PCS Select */\n+pub(crate) const FXMAC_NWCFG_1000_MASK: u32 = BIT(10); /* Gigabit mode enable */\n+pub(crate) const FXMAC_NWCFG_XTADDMACHEN_MASK: u32 = BIT(9); /* External address match enable */\n+pub(crate) const FXMAC_NWCFG_1536RXEN_MASK: u32 = BIT(8); /* Enable 1536 byte frames reception */\n+pub(crate) const FXMAC_NWCFG_UCASTHASHEN_MASK: u32 = BIT(7); /* Receive unicast hash frames */\n+pub(crate) const FXMAC_NWCFG_MCASTHASHEN_MASK: u32 = BIT(6); /* Receive multicast hash frames */\n+pub(crate) const FXMAC_NWCFG_BCASTDI_MASK: u32 = BIT(5); /* Do not receive broadcast frames */\n+pub(crate) const FXMAC_NWCFG_COPYALLEN_MASK: u32 = BIT(4); /* Copy all frames */\n+pub(crate) const FXMAC_NWCFG_JUMBO_MASK: u32 = BIT(3); /* Jumbo frames */\n+pub(crate) const FXMAC_NWCFG_NVLANDISC_MASK: u32 = BIT(2); /* Receive only VLAN frames */\n+pub(crate) const FXMAC_NWCFG_FDEN_MASK: u32 = BIT(1); /* full duplex */\n+pub(crate) const FXMAC_NWCFG_100_MASK: u32 = BIT(0); /* 100 Mbps */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 308 to 308)\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 320 to 325)\n-pub(crate) const FXMAC_RXBUF_BCAST_MASK:u32 = BIT(31);            /* Broadcast frame */\n-pub(crate) const FXMAC_RXBUF_HASH_MASK:u32 = GENMASK(30, 29);\n-pub(crate) const FXMAC_RXBUF_MULTIHASH_MASK:u32 = BIT(30);        /* Multicast hashed frame */\n-pub(crate) const FXMAC_RXBUF_UNIHASH_MASK:u32 = BIT(29);          /* Unicast hashed frame */\n-pub(crate) const FXMAC_RXBUF_EXH_MASK:u32 = BIT(27);              /* buffer exhausted */\n-pub(crate) const FXMAC_RXBUF_AMATCH_MASK:u32 = GENMASK(26, 25);   /* Specific address \\\n+pub(crate) const FXMAC_RXBUF_BCAST_MASK: u32 = BIT(31); /* Broadcast frame */\n+pub(crate) const FXMAC_RXBUF_HASH_MASK: u32 = GENMASK(30, 29);\n+pub(crate) const FXMAC_RXBUF_MULTIHASH_MASK: u32 = BIT(30); /* Multicast hashed frame */\n+pub(crate) const FXMAC_RXBUF_UNIHASH_MASK: u32 = BIT(29); /* Unicast hashed frame */\n+pub(crate) const FXMAC_RXBUF_EXH_MASK: u32 = BIT(27); /* buffer exhausted */\n+pub(crate) const FXMAC_RXBUF_AMATCH_MASK: u32 = GENMASK(26, 25); /* Specific address \\\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 327 to 337)\n-pub(crate) const FXMAC_RXBUF_IDFOUND_MASK:u32 = BIT(24);          /* Type ID matched */\n-pub(crate) const FXMAC_RXBUF_IDMATCH_MASK:u32 = GENMASK(23, 22);  /* ID matched mask */\n-pub(crate) const FXMAC_RXBUF_VLAN_MASK:u32 = BIT(21);             /* VLAN tagged */\n-pub(crate) const FXMAC_RXBUF_PRI_MASK:u32 = BIT(20);              /* Priority tagged */\n-pub(crate) const FXMAC_RXBUF_VPRI_MASK:u32 = GENMASK(19, 17);     /* Vlan priority */\n-pub(crate) const FXMAC_RXBUF_CFI_MASK:u32 = BIT(16);              /* CFI frame */\n-pub(crate) const FXMAC_RXBUF_EOF_MASK:u32 = BIT(15);              /* End of frame. */\n-pub(crate) const FXMAC_RXBUF_SOF_MASK:u32 = BIT(14);              /* Start of frame. */\n-pub(crate) const FXMAC_RXBUF_FCS_STATUS_MASK:u32 = BIT(13);       /* Status of fcs. */\n-pub(crate) const FXMAC_RXBUF_LEN_MASK:u32 = GENMASK(12, 0);       /* Mask for length field */\n-pub(crate) const FXMAC_RXBUF_LEN_JUMBO_MASK:u32 = GENMASK(13, 0); /* Mask for jumbo length */\n+pub(crate) const FXMAC_RXBUF_IDFOUND_MASK: u32 = BIT(24); /* Type ID matched */\n+pub(crate) const FXMAC_RXBUF_IDMATCH_MASK: u32 = GENMASK(23, 22); /* ID matched mask */\n+pub(crate) const FXMAC_RXBUF_VLAN_MASK: u32 = BIT(21); /* VLAN tagged */\n+pub(crate) const FXMAC_RXBUF_PRI_MASK: u32 = BIT(20); /* Priority tagged */\n+pub(crate) const FXMAC_RXBUF_VPRI_MASK: u32 = GENMASK(19, 17); /* Vlan priority */\n+pub(crate) const FXMAC_RXBUF_CFI_MASK: u32 = BIT(16); /* CFI frame */\n+pub(crate) const FXMAC_RXBUF_EOF_MASK: u32 = BIT(15); /* End of frame. */\n+pub(crate) const FXMAC_RXBUF_SOF_MASK: u32 = BIT(14); /* Start of frame. */\n+pub(crate) const FXMAC_RXBUF_FCS_STATUS_MASK: u32 = BIT(13); /* Status of fcs. */\n+pub(crate) const FXMAC_RXBUF_LEN_MASK: u32 = GENMASK(12, 0); /* Mask for length field */\n+pub(crate) const FXMAC_RXBUF_LEN_JUMBO_MASK: u32 = GENMASK(13, 0); /* Mask for jumbo length */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 339 to 341)\n-pub(crate) const FXMAC_RXBUF_WRAP_MASK:u32 = BIT(1);        /* Wrap bit, last BD */\n-pub(crate) const FXMAC_RXBUF_NEW_MASK:u32 = BIT(0);         /* Used bit.. */\n-pub(crate) const FXMAC_RXBUF_ADD_MASK:u32 = GENMASK(31, 2); /* Mask for address */\n+pub(crate) const FXMAC_RXBUF_WRAP_MASK: u32 = BIT(1); /* Wrap bit, last BD */\n+pub(crate) const FXMAC_RXBUF_NEW_MASK: u32 = BIT(0); /* Used bit.. */\n+pub(crate) const FXMAC_RXBUF_ADD_MASK: u32 = GENMASK(31, 2); /* Mask for address */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 356 to 364)\n-pub(crate) const FXMAC_TXBUF_USED_MASK:u32 = BIT(31);       /* Used bit. */\n-pub(crate) const FXMAC_TXBUF_WRAP_MASK:u32 = BIT(30);       /* Wrap bit, last descriptor */\n-pub(crate) const FXMAC_TXBUF_RETRY_MASK:u32 = BIT(29);      /* Retry limit exceeded */\n-pub(crate) const FXMAC_TXBUF_URUN_MASK:u32 = BIT(28);       /* Transmit underrun occurred */\n-pub(crate) const FXMAC_TXBUF_EXH_MASK:u32 = BIT(27);        /* Buffers exhausted */\n-pub(crate) const FXMAC_TXBUF_TCP_MASK:u32 = BIT(26);        /* Late collision. */\n-pub(crate) const FXMAC_TXBUF_NOCRC_MASK:u32 = BIT(16);      /* No CRC */\n-pub(crate) const FXMAC_TXBUF_LAST_MASK:u32 = BIT(15);       /* Last buffer */\n-pub(crate) const FXMAC_TXBUF_LEN_MASK:u32 = GENMASK(13, 0); /* Mask for length field */\n+pub(crate) const FXMAC_TXBUF_USED_MASK: u32 = BIT(31); /* Used bit. */\n+pub(crate) const FXMAC_TXBUF_WRAP_MASK: u32 = BIT(30); /* Wrap bit, last descriptor */\n+pub(crate) const FXMAC_TXBUF_RETRY_MASK: u32 = BIT(29); /* Retry limit exceeded */\n+pub(crate) const FXMAC_TXBUF_URUN_MASK: u32 = BIT(28); /* Transmit underrun occurred */\n+pub(crate) const FXMAC_TXBUF_EXH_MASK: u32 = BIT(27); /* Buffers exhausted */\n+pub(crate) const FXMAC_TXBUF_TCP_MASK: u32 = BIT(26); /* Late collision. */\n+pub(crate) const FXMAC_TXBUF_NOCRC_MASK: u32 = BIT(16); /* No CRC */\n+pub(crate) const FXMAC_TXBUF_LAST_MASK: u32 = BIT(15); /* Last buffer */\n+pub(crate) const FXMAC_TXBUF_LEN_MASK: u32 = GENMASK(13, 0); /* Mask for length field */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 369 to 369)\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 374 to 377)\n-pub(crate) const FXMAC_RXSR_HRESPNOK_MASK:u32 = BIT(3); /* Receive hresp not OK */\n-pub(crate) const FXMAC_RXSR_RXOVR_MASK:u32 = BIT(2);    /* Receive overrun */\n-pub(crate) const FXMAC_RXSR_FRAMERX_MASK:u32 = BIT(1);  /* Frame received OK */\n-pub(crate) const FXMAC_RXSR_BUFFNA_MASK:u32 = BIT(0);   /* RX buffer used bit set */\n+pub(crate) const FXMAC_RXSR_HRESPNOK_MASK: u32 = BIT(3); /* Receive hresp not OK */\n+pub(crate) const FXMAC_RXSR_RXOVR_MASK: u32 = BIT(2); /* Receive overrun */\n+pub(crate) const FXMAC_RXSR_FRAMERX_MASK: u32 = BIT(1); /* Frame received OK */\n+pub(crate) const FXMAC_RXSR_BUFFNA_MASK: u32 = BIT(0); /* RX buffer used bit set */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 379 to 379)\n-pub(crate) const FXMAC_RXSR_ERROR_MASK:u32 = (FXMAC_RXSR_HRESPNOK_MASK | FXMAC_RXSR_RXOVR_MASK | FXMAC_RXSR_BUFFNA_MASK);\n+pub(crate) const FXMAC_RXSR_ERROR_MASK: u32 =\n+    (FXMAC_RXSR_HRESPNOK_MASK | FXMAC_RXSR_RXOVR_MASK | FXMAC_RXSR_BUFFNA_MASK);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 381 to 381)\n-pub(crate) const FXMAC_SR_ALL_MASK:u32 = GENMASK(31, 0); /* Mask for full register */\n+pub(crate) const FXMAC_SR_ALL_MASK: u32 = GENMASK(31, 0); /* Mask for full register */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 386 to 401)\n-pub(crate) const FXMAC_DMACR_ADDR_WIDTH_64:u32 = BIT(30);       /* 64 bit address bus */\n-pub(crate) const FXMAC_DMACR_TXEXTEND_MASK:u32 = BIT(29);       /* Tx Extended desc mode */\n-pub(crate) const FXMAC_DMACR_RXEXTEND_MASK:u32 = BIT(28);       /* Rx Extended desc mode */\n-pub(crate) const FXMAC_DMACR_ORCE_DISCARD_ON_ERR_MASK:u32 = BIT(24); /* Auto Discard RX frames during lack of resource. */\n-pub(crate) const FXMAC_DMACR_RXBUF_MASK:u32 = GENMASK(23, 16);  /* Mask bit for RX buffer size */\n-pub(crate) const FXMAC_DMACR_RXBUF_SHIFT:u32 = 16;            /* Shift bit for RX buffer size */\n-pub(crate) const FXMAC_DMACR_TCPCKSUM_MASK:u32 = BIT(11);       /* enable/disable TX checksum offload */\n-pub(crate) const FXMAC_DMACR_TXSIZE_MASK:u32 = BIT(10);         /* TX buffer memory size bit[10] */\n-pub(crate) const FXMAC_DMACR_RXSIZE_MASK:u32 = GENMASK(9, 8);   /* RX buffer memory size bit[9:8] */\n-pub(crate) const FXMAC_DMACR_ENDIAN_MASK:u32 = BIT(7);          /* endian configuration */\n-pub(crate) const FXMAC_DMACR_SWAP_MANAGEMENT_MASK:u32 = BIT(6); /*  When clear, selects little endian mode */\n-pub(crate) const FXMAC_DMACR_BLENGTH_MASK:u32 = GENMASK(4, 0);  /* buffer burst length */\n-pub(crate) const FXMAC_DMACR_SINGLE_AHB_AXI_BURST:u32 = BIT(0); /* single AHB_AXI bursts */\n-pub(crate) const FXMAC_DMACR_INCR4_AHB_AXI_BURST:u32 = BIT(2);  /* 4 bytes AHB_AXI bursts */\n-pub(crate) const FXMAC_DMACR_INCR8_AHB_AXI_BURST:u32 = BIT(3);  /* 8 bytes AHB_AXI bursts */\n-pub(crate) const FXMAC_DMACR_INCR16_AHB_AXI_BURST:u32 = BIT(4); /* 16 bytes AHB_AXI bursts */\n+pub(crate) const FXMAC_DMACR_ADDR_WIDTH_64: u32 = BIT(30); /* 64 bit address bus */\n+pub(crate) const FXMAC_DMACR_TXEXTEND_MASK: u32 = BIT(29); /* Tx Extended desc mode */\n+pub(crate) const FXMAC_DMACR_RXEXTEND_MASK: u32 = BIT(28); /* Rx Extended desc mode */\n+pub(crate) const FXMAC_DMACR_ORCE_DISCARD_ON_ERR_MASK: u32 = BIT(24); /* Auto Discard RX frames during lack of resource. */\n+pub(crate) const FXMAC_DMACR_RXBUF_MASK: u32 = GENMASK(23, 16); /* Mask bit for RX buffer size */\n+pub(crate) const FXMAC_DMACR_RXBUF_SHIFT: u32 = 16; /* Shift bit for RX buffer size */\n+pub(crate) const FXMAC_DMACR_TCPCKSUM_MASK: u32 = BIT(11); /* enable/disable TX checksum offload */\n+pub(crate) const FXMAC_DMACR_TXSIZE_MASK: u32 = BIT(10); /* TX buffer memory size bit[10] */\n+pub(crate) const FXMAC_DMACR_RXSIZE_MASK: u32 = GENMASK(9, 8); /* RX buffer memory size bit[9:8] */\n+pub(crate) const FXMAC_DMACR_ENDIAN_MASK: u32 = BIT(7); /* endian configuration */\n+pub(crate) const FXMAC_DMACR_SWAP_MANAGEMENT_MASK: u32 = BIT(6); /*  When clear, selects little endian mode */\n+pub(crate) const FXMAC_DMACR_BLENGTH_MASK: u32 = GENMASK(4, 0); /* buffer burst length */\n+pub(crate) const FXMAC_DMACR_SINGLE_AHB_AXI_BURST: u32 = BIT(0); /* single AHB_AXI bursts */\n+pub(crate) const FXMAC_DMACR_INCR4_AHB_AXI_BURST: u32 = BIT(2); /* 4 bytes AHB_AXI bursts */\n+pub(crate) const FXMAC_DMACR_INCR8_AHB_AXI_BURST: u32 = BIT(3); /* 8 bytes AHB_AXI bursts */\n+pub(crate) const FXMAC_DMACR_INCR16_AHB_AXI_BURST: u32 = BIT(4); /* 16 bytes AHB_AXI bursts */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 405 to 407)\n-pub(crate) const FXMAC_REVISION_MODULE_MASK:u32 = GENMASK(15, 0); /* Module revision */\n-pub(crate) const FXMAC_IDENTIFICATION_MASK:u32 = GENMASK(27, 16); /* Module identification number */\n-pub(crate) const FXMAC_FIX_NUM_MASK:u32 = GENMASK(31, 28);        /*  Fix number - incremented for fix releases */\n+pub(crate) const FXMAC_REVISION_MODULE_MASK: u32 = GENMASK(15, 0); /* Module revision */\n+pub(crate) const FXMAC_IDENTIFICATION_MASK: u32 = GENMASK(27, 16); /* Module identification number */\n+pub(crate) const FXMAC_FIX_NUM_MASK: u32 = GENMASK(31, 28); /*  Fix number - incremented for fix releases */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 412 to 414)\n-pub(crate) const FXMAC_NWSR_MDIOIDLE_MASK:u32 = BIT(2); /* PHY management idle */\n-pub(crate) const FXMAC_NWSR_MDIO_MASK:u32 = BIT(1);     /* Status of mdio_in */\n-pub(crate) const FXMAC_NWSR_PCS_LINK_STATE_MASK:u32 =  BIT(0);\n+pub(crate) const FXMAC_NWSR_MDIOIDLE_MASK: u32 = BIT(2); /* PHY management idle */\n+pub(crate) const FXMAC_NWSR_MDIO_MASK: u32 = BIT(1); /* Status of mdio_in */\n+pub(crate) const FXMAC_NWSR_PCS_LINK_STATE_MASK: u32 = BIT(0);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 419 to 426)\n-pub(crate) const FXMAC_PHYMNTNC_OP_MASK:u32 = (BIT(17) | BIT(30)); /* operation mask bits */\n-pub(crate) const FXMAC_PHYMNTNC_OP_R_MASK:u32 = BIT(29);           /* read operation */\n-pub(crate) const FXMAC_PHYMNTNC_OP_W_MASK:u32 = BIT(28);           /* write operation */\n-pub(crate) const FXMAC_PHYMNTNC_ADDR_MASK:u32 = GENMASK(27, 23);   /* Address bits */\n-pub(crate) const FXMAC_PHYMNTNC_REG_MASK:u32 = GENMASK(22, 18);    /* register bits */\n-pub(crate) const FXMAC_PHYMNTNC_DATA_MASK:u32 = GENMASK(11, 0);    /* data bits */\n-pub(crate) const FXMAC_PHYMNTNC_PHAD_SHFT_MSK:u32 = 23;          /* Shift bits for PHYAD */\n-pub(crate) const FXMAC_PHYMNTNC_PREG_SHFT_MSK:u32 = 18;          /* Shift bits for PHREG */\n+pub(crate) const FXMAC_PHYMNTNC_OP_MASK: u32 = (BIT(17) | BIT(30)); /* operation mask bits */\n+pub(crate) const FXMAC_PHYMNTNC_OP_R_MASK: u32 = BIT(29); /* read operation */\n+pub(crate) const FXMAC_PHYMNTNC_OP_W_MASK: u32 = BIT(28); /* write operation */\n+pub(crate) const FXMAC_PHYMNTNC_ADDR_MASK: u32 = GENMASK(27, 23); /* Address bits */\n+pub(crate) const FXMAC_PHYMNTNC_REG_MASK: u32 = GENMASK(22, 18); /* register bits */\n+pub(crate) const FXMAC_PHYMNTNC_DATA_MASK: u32 = GENMASK(11, 0); /* data bits */\n+pub(crate) const FXMAC_PHYMNTNC_PHAD_SHFT_MSK: u32 = 23; /* Shift bits for PHYAD */\n+pub(crate) const FXMAC_PHYMNTNC_PREG_SHFT_MSK: u32 = 18; /* Shift bits for PHREG */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 431 to 438)\n-pub(crate) const FXMAC_TXSR_HRESPNOK_MASK:u32 = BIT(8); /* Transmit hresp not OK */\n-pub(crate) const FXMAC_TXSR_URUN_MASK:u32 = BIT(6);     /* Transmit underrun */\n-pub(crate) const FXMAC_TXSR_TXCOMPL_MASK:u32 = BIT(5);  /* Transmit completed OK */\n-pub(crate) const FXMAC_TXSR_BUFEXH_MASK:u32 = BIT(4);   /* Transmit buffs exhausted mid frame */\n-pub(crate) const FXMAC_TXSR_TXGO_MASK:u32 = BIT(3);     /* Status of go flag */\n-pub(crate) const FXMAC_TXSR_RXOVR_MASK:u32 = BIT(2);    /* Retry limit exceeded */\n-pub(crate) const FXMAC_TXSR_FRAMERX_MASK:u32 = BIT(1);  /* Collision tx frame */\n-pub(crate) const FXMAC_TXSR_USEDREAD_MASK:u32 = BIT(0); /* TX buffer used bit set */\n+pub(crate) const FXMAC_TXSR_HRESPNOK_MASK: u32 = BIT(8); /* Transmit hresp not OK */\n+pub(crate) const FXMAC_TXSR_URUN_MASK: u32 = BIT(6); /* Transmit underrun */\n+pub(crate) const FXMAC_TXSR_TXCOMPL_MASK: u32 = BIT(5); /* Transmit completed OK */\n+pub(crate) const FXMAC_TXSR_BUFEXH_MASK: u32 = BIT(4); /* Transmit buffs exhausted mid frame */\n+pub(crate) const FXMAC_TXSR_TXGO_MASK: u32 = BIT(3); /* Status of go flag */\n+pub(crate) const FXMAC_TXSR_RXOVR_MASK: u32 = BIT(2); /* Retry limit exceeded */\n+pub(crate) const FXMAC_TXSR_FRAMERX_MASK: u32 = BIT(1); /* Collision tx frame */\n+pub(crate) const FXMAC_TXSR_USEDREAD_MASK: u32 = BIT(0); /* TX buffer used bit set */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 440 to 445)\n-pub(crate) const FXMAC_TXSR_ERROR_MASK:u32 = (FXMAC_TXSR_HRESPNOK_MASK |\n-                               FXMAC_TXSR_URUN_MASK |    \n-                               FXMAC_TXSR_BUFEXH_MASK |  \n-                               FXMAC_TXSR_RXOVR_MASK |   \n-                               FXMAC_TXSR_FRAMERX_MASK | \n-                               FXMAC_TXSR_USEDREAD_MASK);\n+pub(crate) const FXMAC_TXSR_ERROR_MASK: u32 = (FXMAC_TXSR_HRESPNOK_MASK\n+    | FXMAC_TXSR_URUN_MASK\n+    | FXMAC_TXSR_BUFEXH_MASK\n+    | FXMAC_TXSR_RXOVR_MASK\n+    | FXMAC_TXSR_FRAMERX_MASK\n+    | FXMAC_TXSR_USEDREAD_MASK);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 448 to 449)\n- */                                \n-pub(crate) const FXMAC_TXQSEGALLOC_QLOWER_JUMBO_MASK:u32 = BIT(2);  /* 16 segments are distributed to queue 0*/\n+ */\n+pub(crate) const FXMAC_TXQSEGALLOC_QLOWER_JUMBO_MASK: u32 = BIT(2); /* 16 segments are distributed to queue 0*/\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 454 to 455)\n-pub(crate) const FXMAC_INTQ1SR_TXCOMPL_MASK:u32 = BIT(7); /* Transmit completed OK */\n-pub(crate) const FXMAC_INTQ1SR_TXERR_MASK:u32 = BIT(6);   /* Transmit AMBA Error */\n+pub(crate) const FXMAC_INTQ1SR_TXCOMPL_MASK: u32 = BIT(7); /* Transmit completed OK */\n+pub(crate) const FXMAC_INTQ1SR_TXERR_MASK: u32 = BIT(6); /* Transmit AMBA Error */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 457 to 457)\n-pub(crate) const FXMAC_INTQ1_IXR_ALL_MASK:u32 = (FXMAC_INTQ1SR_TXCOMPL_MASK | FXMAC_INTQ1SR_TXERR_MASK);\n+pub(crate) const FXMAC_INTQ1_IXR_ALL_MASK: u32 =\n+    (FXMAC_INTQ1SR_TXCOMPL_MASK | FXMAC_INTQ1SR_TXERR_MASK);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 463 to 466)\n-pub(crate) const FXMAC_INTQUESR_TXCOMPL_MASK:u32 = BIT(7); /* Transmit completed OK */\n-pub(crate) const FXMAC_INTQUESR_TXERR_MASK:u32 = BIT(6);   /* Transmit AMBA Error */\n-pub(crate) const FXMAC_INTQUESR_RCOMP_MASK:u32 = BIT(1);\n-pub(crate) const FXMAC_INTQUESR_RXUBR_MASK:u32 = BIT(2);\n+pub(crate) const FXMAC_INTQUESR_TXCOMPL_MASK: u32 = BIT(7); /* Transmit completed OK */\n+pub(crate) const FXMAC_INTQUESR_TXERR_MASK: u32 = BIT(6); /* Transmit AMBA Error */\n+pub(crate) const FXMAC_INTQUESR_RCOMP_MASK: u32 = BIT(1);\n+pub(crate) const FXMAC_INTQUESR_RXUBR_MASK: u32 = BIT(2);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 468 to 468)\n-pub(crate) const FXMAC_INTQUE_IXR_ALL_MASK:u32 = (FXMAC_INTQUESR_TXCOMPL_MASK | FXMAC_INTQUESR_TXERR_MASK);\n+pub(crate) const FXMAC_INTQUE_IXR_ALL_MASK: u32 =\n+    (FXMAC_INTQUESR_TXCOMPL_MASK | FXMAC_INTQUESR_TXERR_MASK);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 476 to 477)\n-pub(crate) const FXMAC_DESIGNCFG_DEBUG1_BUS_WIDTH_MASK:u32 = GENMASK(27, 25);\n-pub(crate) const FXMAC_DESIGNCFG_DEBUG1_BUS_IRQCOR_MASK:u32 = BIT(23);\n+pub(crate) const FXMAC_DESIGNCFG_DEBUG1_BUS_WIDTH_MASK: u32 = GENMASK(27, 25);\n+pub(crate) const FXMAC_DESIGNCFG_DEBUG1_BUS_IRQCOR_MASK: u32 = BIT(23);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 480 to 482)\n-pub(crate) const FXMAC_GEM_HSMACSPEED_OFFSET:u64 = 0;\n-pub(crate) const FXMAC_GEM_HSMACSPEED_SIZE:u32 = 3;\n-pub(crate) const FXMAC_GEM_HSMACSPEED_MASK:u32 = 0x7;\n+pub(crate) const FXMAC_GEM_HSMACSPEED_OFFSET: u64 = 0;\n+pub(crate) const FXMAC_GEM_HSMACSPEED_SIZE: u32 = 3;\n+pub(crate) const FXMAC_GEM_HSMACSPEED_MASK: u32 = 0x7;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 487 to 489)\n-pub(crate) const FXMAC_BD_ADDR_OFFSET:u64 = 0x00000000;/* word 0/addr of BDs */\n-pub(crate) const FXMAC_BD_STAT_OFFSET:u64 = 4;           /* word 1/status of BDs, 4 bytes */\n-pub(crate) const FXMAC_BD_ADDR_HI_OFFSET:u32 = BIT(3);   /* word 2/addr of BDs */\n+pub(crate) const FXMAC_BD_ADDR_OFFSET: u64 = 0x00000000; /* word 0/addr of BDs */\n+pub(crate) const FXMAC_BD_STAT_OFFSET: u64 = 4; /* word 1/status of BDs, 4 bytes */\n+pub(crate) const FXMAC_BD_ADDR_HI_OFFSET: u32 = BIT(3); /* word 2/addr of BDs */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 494 to 494)\n-pub(crate) const FXMAC_GEM_SAB_MASK:u32 = GENMASK(15, 0); /* Address bits[47:32] bit[31:0] are in BOTTOM */\n+pub(crate) const FXMAC_GEM_SAB_MASK: u32 = GENMASK(15, 0); /* Address bits[47:32] bit[31:0] are in BOTTOM */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 497 to 508)\n-pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_100M:u32 = (0x0 << 14); /* 100M operation */\n-pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_1G:u32 = (0x1 << 14);   /* 1G operation */\n-pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_2_5G:u32 = (0x2 << 14); /* 2.5G operation */\n-pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_5G:u32 =  (0x3 << 14);  /* 5G operation */\n-pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_10G:u32 = (0x4 << 14);  /* 10G operation */\n-pub(crate) const FXMAC_GEM_USX_SERDES_RATE_5G:u32 =    (0x0 << 12);\n-pub(crate) const FXMAC_GEM_USX_SERDES_RATE_10G:u32 =    (0x1 << 12);\n-pub(crate) const FXMAC_GEM_USX_TX_SCR_BYPASS:u32 = BIT(8);          /* RX Scrambler Bypass. Set high to bypass the receive descrambler. */\n-pub(crate) const FXMAC_GEM_USX_RX_SCR_BYPASS:u32 = BIT(9);          /* TX Scrambler Bypass. Set high to bypass the transmit scrambler. */\n-pub(crate) const FXMAC_GEM_USX_RX_SYNC_RESET:u32 = BIT(2);          /* RX Reset. Set high to reset the receive datapath. When low the receive datapath is enabled. */\n-pub(crate) const FXMAC_GEM_USX_TX_DATAPATH_EN:u32 = BIT(1);         /* TX Datapath Enable. */\n-pub(crate) const FXMAC_GEM_USX_SIGNAL_OK:u32 = BIT(0);              /* Enable the USXGMII/BASE-R receive PCS. */\n+pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_100M: u32 = (0x0 << 14); /* 100M operation */\n+pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_1G: u32 = (0x1 << 14); /* 1G operation */\n+pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_2_5G: u32 = (0x2 << 14); /* 2.5G operation */\n+pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_5G: u32 = (0x3 << 14); /* 5G operation */\n+pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_10G: u32 = (0x4 << 14); /* 10G operation */\n+pub(crate) const FXMAC_GEM_USX_SERDES_RATE_5G: u32 = (0x0 << 12);\n+pub(crate) const FXMAC_GEM_USX_SERDES_RATE_10G: u32 = (0x1 << 12);\n+pub(crate) const FXMAC_GEM_USX_TX_SCR_BYPASS: u32 = BIT(8); /* RX Scrambler Bypass. Set high to bypass the receive descrambler. */\n+pub(crate) const FXMAC_GEM_USX_RX_SCR_BYPASS: u32 = BIT(9); /* TX Scrambler Bypass. Set high to bypass the transmit scrambler. */\n+pub(crate) const FXMAC_GEM_USX_RX_SYNC_RESET: u32 = BIT(2); /* RX Reset. Set high to reset the receive datapath. When low the receive datapath is enabled. */\n+pub(crate) const FXMAC_GEM_USX_TX_DATAPATH_EN: u32 = BIT(1); /* TX Datapath Enable. */\n+pub(crate) const FXMAC_GEM_USX_SIGNAL_OK: u32 = BIT(0); /* Enable the USXGMII/BASE-R receive PCS. */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 511 to 511)\n-pub(crate) const FXMAC_PCS_CONTROL_ENABLE_AUTO_NEG:u32 = BIT(12); /* Enable auto-negotiation - when set active high, autonegotiation operation is enabled.  */\n+pub(crate) const FXMAC_PCS_CONTROL_ENABLE_AUTO_NEG: u32 = BIT(12); /* Enable auto-negotiation - when set active high, autonegotiation operation is enabled.  */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 513 to 513)\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 515 to 516)\n-pub(crate) const FXMAC_PCS_STATUS_LINK_STATUS_OFFSET:u32 = 2;\n-pub(crate) const FXMAC_PCS_STATUS_LINK_STATUS:u32 = BIT(FXMAC_PCS_STATUS_LINK_STATUS_OFFSET);   /* Link status - indicates the status of the physical connection to the link partner. When set to logic 1 the link is up, and when set to logic 0, the link is down. */\n+pub(crate) const FXMAC_PCS_STATUS_LINK_STATUS_OFFSET: u32 = 2;\n+pub(crate) const FXMAC_PCS_STATUS_LINK_STATUS: u32 = BIT(FXMAC_PCS_STATUS_LINK_STATUS_OFFSET); /* Link status - indicates the status of the physical connection to the link partner. When set to logic 1 the link is up, and when set to logic 0, the link is down. */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 519 to 524)\n-pub(crate) const FXMAC_PCS_AN_LP_SPEED_OFFSET:u64 =   10;\n-pub(crate) const FXMAC_PCS_AN_LP_SPEED:u32 =    (0x3 << FXMAC_PCS_AN_LP_SPEED_OFFSET); /* SGMII 11 : Reserved 10 : 1000 Mbps 01 : 100Mbps 00 : 10 Mbps */\n-pub(crate) const FXMAC_PCS_AN_LP_DUPLEX_OFFSET:u64 =  12;\n-pub(crate) const FXMAC_PCS_AN_LP_DUPLEX:u32 =   (0x3 << FXMAC_PCS_AN_LP_DUPLEX_OFFSET); /* SGMII Bit 13: Reserved. read as 0. Bit 12 : 0 : half-duplex. 1: Full Duplex.\" */\n-pub(crate) const FXMAC_PCS_LINK_PARTNER_NEXT_PAGE_STATUS:u32 = (1 << 15); /* In sgmii mode, 0 is link down . 1 is link up */\n-pub(crate) const FXMAC_PCS_LINK_PARTNER_NEXT_PAGE_OFFSET:u64 = 15;\n+pub(crate) const FXMAC_PCS_AN_LP_SPEED_OFFSET: u64 = 10;\n+pub(crate) const FXMAC_PCS_AN_LP_SPEED: u32 = (0x3 << FXMAC_PCS_AN_LP_SPEED_OFFSET); /* SGMII 11 : Reserved 10 : 1000 Mbps 01 : 100Mbps 00 : 10 Mbps */\n+pub(crate) const FXMAC_PCS_AN_LP_DUPLEX_OFFSET: u64 = 12;\n+pub(crate) const FXMAC_PCS_AN_LP_DUPLEX: u32 = (0x3 << FXMAC_PCS_AN_LP_DUPLEX_OFFSET); /* SGMII Bit 13: Reserved. read as 0. Bit 12 : 0 : half-duplex. 1: Full Duplex.\" */\n+pub(crate) const FXMAC_PCS_LINK_PARTNER_NEXT_PAGE_STATUS: u32 = (1 << 15); /* In sgmii mode, 0 is link down . 1 is link up */\n+pub(crate) const FXMAC_PCS_LINK_PARTNER_NEXT_PAGE_OFFSET: u64 = 15;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 526 to 526)\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 528 to 528)\n-pub(crate) const FXMAC_GEM_USX_STATUS_BLOCK_LOCK:u32 = BIT(0);  /* Block Lock. A value of one indicates that the PCS has achieved block synchronization. */\n+pub(crate) const FXMAC_GEM_USX_STATUS_BLOCK_LOCK: u32 = BIT(0); /* Block Lock. A value of one indicates that the PCS has achieved block synchronization. */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 536 to 540)\n-pub const fn GENMASK(h:u32, l: u32) -> u32 {\n-    (\n-    (!(0 as u64) - (1 << l) + 1) &\n-     (!(0 as u64) >> (BITS_PER_LONG - 1 - h))\n-    ) as u32\n+pub const fn GENMASK(h: u32, l: u32) -> u32 {\n+    ((!(0 as u64) - (1 << l) + 1) & (!(0 as u64) >> (BITS_PER_LONG - 1 - h))) as u32\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 546 to 546)\n-pub(crate) const FXMAC_PROMISC_OPTION:u32 = 0x00000001;\n+pub(crate) const FXMAC_PROMISC_OPTION: u32 = 0x00000001;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 550 to 550)\n-pub(crate) const FXMAC_FRAME1536_OPTION:u32 = 0x00000002;\n+pub(crate) const FXMAC_FRAME1536_OPTION: u32 = 0x00000002;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 554 to 554)\n-pub(crate) const FXMAC_VLAN_OPTION:u32 = 0x00000004;\n+pub(crate) const FXMAC_VLAN_OPTION: u32 = 0x00000004;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 558 to 558)\n-pub(crate) const FXMAC_FLOW_CONTROL_OPTION:u32 = 0x00000010;\n+pub(crate) const FXMAC_FLOW_CONTROL_OPTION: u32 = 0x00000010;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 562 to 562)\n-pub(crate) const FXMAC_FCS_STRIP_OPTION:u32 = 0x00000020;\n+pub(crate) const FXMAC_FCS_STRIP_OPTION: u32 = 0x00000020;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 567 to 567)\n-pub(crate) const FXMAC_FCS_INSERT_OPTION:u32 = 0x00000040;\n+pub(crate) const FXMAC_FCS_INSERT_OPTION: u32 = 0x00000040;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 571 to 571)\n-pub(crate) const FXMAC_LENTYPE_ERR_OPTION:u32 = 0x00000080;\n+pub(crate) const FXMAC_LENTYPE_ERR_OPTION: u32 = 0x00000080;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 580 to 580)\n-pub(crate) const FXMAC_TRANSMITTER_ENABLE_OPTION:u32 = 0x00000100;\n+pub(crate) const FXMAC_TRANSMITTER_ENABLE_OPTION: u32 = 0x00000100;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 584 to 584)\n-pub(crate) const FXMAC_RECEIVER_ENABLE_OPTION:u32 = 0x00000200;\n+pub(crate) const FXMAC_RECEIVER_ENABLE_OPTION: u32 = 0x00000200;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 588 to 588)\n-pub(crate) const FXMAC_BROADCAST_OPTION:u32 = 0x00000400;\n+pub(crate) const FXMAC_BROADCAST_OPTION: u32 = 0x00000400;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 592 to 592)\n-pub(crate) const FXMAC_MULTICAST_OPTION:u32 = 0x00000800;\n+pub(crate) const FXMAC_MULTICAST_OPTION: u32 = 0x00000800;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 596 to 596)\n-pub(crate) const FXMAC_RX_CHKSUM_ENABLE_OPTION:u32 = 0x00001000;\n+pub(crate) const FXMAC_RX_CHKSUM_ENABLE_OPTION: u32 = 0x00001000;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 600 to 600)\n-pub(crate) const FXMAC_TX_CHKSUM_ENABLE_OPTION:u32 = 0x00002000;\n+pub(crate) const FXMAC_TX_CHKSUM_ENABLE_OPTION: u32 = 0x00002000;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 604 to 605)\n-pub(crate) const FXMAC_JUMBO_ENABLE_OPTION:u32 = 0x00004000;\n-pub(crate) const FXMAC_SGMII_ENABLE_OPTION:u32 = 0x00008000;\n+pub(crate) const FXMAC_JUMBO_ENABLE_OPTION: u32 = 0x00004000;\n+pub(crate) const FXMAC_SGMII_ENABLE_OPTION: u32 = 0x00008000;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 607 to 608)\n-pub(crate) const FXMAC_LOOPBACK_NO_MII_OPTION:u32 = 0x00010000;\n-pub(crate) const FXMAC_LOOPBACK_USXGMII_OPTION:u32 = 0x00020000;\n+pub(crate) const FXMAC_LOOPBACK_NO_MII_OPTION: u32 = 0x00010000;\n+pub(crate) const FXMAC_LOOPBACK_USXGMII_OPTION: u32 = 0x00020000;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 610 to 610)\n-pub(crate) const FXMAC_UNICAST_OPTION:u32 = 0x00040000;\n+pub(crate) const FXMAC_UNICAST_OPTION: u32 = 0x00040000;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 612 to 612)\n-pub(crate) const FXMAC_TAIL_PTR_OPTION:u32 = 0x00080000;\n+pub(crate) const FXMAC_TAIL_PTR_OPTION: u32 = 0x00080000;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 614 to 614)\n+pub(crate) const FXMAC_DEFAULT_OPTIONS: u32 = (FXMAC_FLOW_CONTROL_OPTION\n+    | FXMAC_FCS_INSERT_OPTION\n+    | FXMAC_FCS_STRIP_OPTION\n+    | FXMAC_BROADCAST_OPTION\n+    | FXMAC_LENTYPE_ERR_OPTION\n+    | FXMAC_TRANSMITTER_ENABLE_OPTION\n+    | FXMAC_RECEIVER_ENABLE_OPTION\n+    | FXMAC_RX_CHKSUM_ENABLE_OPTION\n+    | FXMAC_TX_CHKSUM_ENABLE_OPTION);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 615 to 625)\n-pub(crate) const FXMAC_DEFAULT_OPTIONS:u32 =               \n-    (FXMAC_FLOW_CONTROL_OPTION |       \n-     FXMAC_FCS_INSERT_OPTION |         \n-     FXMAC_FCS_STRIP_OPTION |          \n-     FXMAC_BROADCAST_OPTION |          \n-     FXMAC_LENTYPE_ERR_OPTION |        \n-     FXMAC_TRANSMITTER_ENABLE_OPTION | \n-     FXMAC_RECEIVER_ENABLE_OPTION |    \n-     FXMAC_RX_CHKSUM_ENABLE_OPTION |   \n-     FXMAC_TX_CHKSUM_ENABLE_OPTION);\n-     \n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 629 to 629)\n-pub(crate) const FXMAC_MAC_ADDR_SIZE:u32 = 6; /* size of Ethernet header */\n+pub(crate) const FXMAC_MAC_ADDR_SIZE: u32 = 6; /* size of Ethernet header */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 631 to 635)\n-pub(crate) const FXMAC_MTU:u32 = 1500;         /* max MTU size of Ethernet frame */\n-pub(crate) const FXMAC_MTU_JUMBO:u32 = 10240;  /* max MTU size of jumbo frame including Ip header + IP payload */\n-pub(crate) const FXMAC_HDR_SIZE:u32 = 14;      /* size of Ethernet header  , DA + SA + TYPE*/\n-pub(crate) const FXMAC_HDR_VLAN_SIZE:u32 = 18; /* size of Ethernet header with VLAN */\n-pub(crate) const FXMAC_TRL_SIZE:u32 = 4;       /* size of Ethernet trailer (FCS) */\n+pub(crate) const FXMAC_MTU: u32 = 1500; /* max MTU size of Ethernet frame */\n+pub(crate) const FXMAC_MTU_JUMBO: u32 = 10240; /* max MTU size of jumbo frame including Ip header + IP payload */\n+pub(crate) const FXMAC_HDR_SIZE: u32 = 14; /* size of Ethernet header  , DA + SA + TYPE*/\n+pub(crate) const FXMAC_HDR_VLAN_SIZE: u32 = 18; /* size of Ethernet header with VLAN */\n+pub(crate) const FXMAC_TRL_SIZE: u32 = 4; /* size of Ethernet trailer (FCS) */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 637 to 638)\n-pub(crate) const FXMAC_MAX_FRAME_SIZE:u32 = (FXMAC_MTU + FXMAC_HDR_SIZE + FXMAC_TRL_SIZE);\n-pub(crate) const FXMAC_MAX_FRAME_SIZE_JUMBO:u32 = (FXMAC_MTU_JUMBO + FXMAC_HDR_SIZE + FXMAC_TRL_SIZE);\n+pub(crate) const FXMAC_MAX_FRAME_SIZE: u32 = (FXMAC_MTU + FXMAC_HDR_SIZE + FXMAC_TRL_SIZE);\n+pub(crate) const FXMAC_MAX_FRAME_SIZE_JUMBO: u32 =\n+    (FXMAC_MTU_JUMBO + FXMAC_HDR_SIZE + FXMAC_TRL_SIZE);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 640 to 641)\n-pub(crate) const FXMAC_MAX_VLAN_FRAME_SIZE:u32 = (FXMAC_MTU + FXMAC_HDR_SIZE + FXMAC_HDR_VLAN_SIZE + FXMAC_TRL_SIZE);\n-pub(crate) const FXMAC_MAX_VLAN_FRAME_SIZE_JUMBO:u32 = (FXMAC_MTU_JUMBO + FXMAC_HDR_SIZE + FXMAC_HDR_VLAN_SIZE + FXMAC_TRL_SIZE);\n+pub(crate) const FXMAC_MAX_VLAN_FRAME_SIZE: u32 =\n+    (FXMAC_MTU + FXMAC_HDR_SIZE + FXMAC_HDR_VLAN_SIZE + FXMAC_TRL_SIZE);\n+pub(crate) const FXMAC_MAX_VLAN_FRAME_SIZE_JUMBO: u32 =\n+    (FXMAC_MTU_JUMBO + FXMAC_HDR_SIZE + FXMAC_HDR_VLAN_SIZE + FXMAC_TRL_SIZE);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 648 to 652)\n-pub(crate) const FXMAC_HANDLER_DMASEND:u32 = 1;        /* 发送中断 */\n-pub(crate) const FXMAC_HANDLER_DMARECV:u32 = 2;        /* 接收中断 */\n-pub(crate) const FXMAC_HANDLER_ERROR:u32 = 3;          /* 异常中断 */\n-pub(crate) const FXMAC_HANDLER_LINKCHANGE:u32 = 4;     /* 连接状态 */\n-pub(crate) const FXMAC_HANDLER_RESTART:u32 = 5;        /* 发送描述符队列发生异常 */\n+pub(crate) const FXMAC_HANDLER_DMASEND: u32 = 1; /* 发送中断 */\n+pub(crate) const FXMAC_HANDLER_DMARECV: u32 = 2; /* 接收中断 */\n+pub(crate) const FXMAC_HANDLER_ERROR: u32 = 3; /* 异常中断 */\n+pub(crate) const FXMAC_HANDLER_LINKCHANGE: u32 = 4; /* 连接状态 */\n+pub(crate) const FXMAC_HANDLER_RESTART: u32 = 5; /* 发送描述符队列发生异常 */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 655 to 656)\n-pub(crate) const FXMAC_DMA_SG_IS_STARTED:u32 = 0;\n-pub(crate) const FXMAC_DMA_SG_IS_STOPED:u32 = 1;\n+pub(crate) const FXMAC_DMA_SG_IS_STARTED: u32 = 0;\n+pub(crate) const FXMAC_DMA_SG_IS_STOPED: u32 = 1;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 658 to 664)\n-pub(crate) const FXMAC_SPEED_10:u32 = 10;\n-pub(crate) const FXMAC_SPEED_100:u32 = 100;\n-pub(crate) const FXMAC_SPEED_1000:u32 = 1000;\n-pub(crate) const FXMAC_SPEED_2500:u32 = 2500;\n-pub(crate) const FXMAC_SPEED_5000:u32 = 5000;\n-pub(crate) const FXMAC_SPEED_10000:u32 = 10000;\n-pub(crate) const FXMAC_SPEED_25000:u32 = 25000;\n+pub(crate) const FXMAC_SPEED_10: u32 = 10;\n+pub(crate) const FXMAC_SPEED_100: u32 = 100;\n+pub(crate) const FXMAC_SPEED_1000: u32 = 1000;\n+pub(crate) const FXMAC_SPEED_2500: u32 = 2500;\n+pub(crate) const FXMAC_SPEED_5000: u32 = 5000;\n+pub(crate) const FXMAC_SPEED_10000: u32 = 10000;\n+pub(crate) const FXMAC_SPEED_25000: u32 = 25000;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 667 to 668)\n-pub(crate) const FXMAC_CAPS_ISR_CLEAR_ON_WRITE:u32 =   0x00000001; /* irq status parameters need to be written to clear after they have been read */\n-pub(crate) const FXMAC_CAPS_TAILPTR:u32 =              0x00000002; /* use tail ptr */\n+pub(crate) const FXMAC_CAPS_ISR_CLEAR_ON_WRITE: u32 = 0x00000001; /* irq status parameters need to be written to clear after they have been read */\n+pub(crate) const FXMAC_CAPS_TAILPTR: u32 = 0x00000002; /* use tail ptr */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_const.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 683 to 683)\n+\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 2 to 2)\n-use core::ptr::{null_mut, null};\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 4 to 4)\n+use core::ptr::{null, null_mut};\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 6 to 7)\n-use alloc::boxed::Box;\n-use alloc::vec::Vec;\n+use crate::fxmac::*;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 10 to 10)\n-use crate::fxmac::*;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 12 to 12)\n+use alloc::boxed::Box;\n+use alloc::vec::Vec;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 20 to 20)\n-pub const FXMAX_MAX_HARDWARE_ADDRESS_LENGTH: usize =6;\n+pub const FXMAX_MAX_HARDWARE_ADDRESS_LENGTH: usize = 6;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 25 to 27)\n-pub const FXMAC_LWIP_PORT_CONFIG_COPY_ALL_FRAMES: u32 =BIT(2); /* enable copy all frames */\n-pub const FXMAC_LWIP_PORT_CONFIG_CLOSE_FCS_CHECK: u32 =BIT(3); /* close fcs check */\n-pub const FXMAC_LWIP_PORT_CONFIG_UNICAST_ADDRESS_FILITER: u32 =BIT(5); /* Allow unicast address filtering  */\n+pub const FXMAC_LWIP_PORT_CONFIG_COPY_ALL_FRAMES: u32 = BIT(2); /* enable copy all frames */\n+pub const FXMAC_LWIP_PORT_CONFIG_CLOSE_FCS_CHECK: u32 = BIT(3); /* close fcs check */\n+pub const FXMAC_LWIP_PORT_CONFIG_UNICAST_ADDRESS_FILITER: u32 = BIT(5); /* Allow unicast address filtering  */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 30 to 33)\n-pub const FXMAC_PHY_SPEED_10M: u32 =   10;\n-pub const FXMAC_PHY_SPEED_100M: u32 =   100;\n-pub const FXMAC_PHY_SPEED_1000M: u32 =   1000;\n-pub const FXMAC_PHY_SPEED_10G: u32 =   10000;\n+pub const FXMAC_PHY_SPEED_10M: u32 = 10;\n+pub const FXMAC_PHY_SPEED_100M: u32 = 100;\n+pub const FXMAC_PHY_SPEED_1000M: u32 = 1000;\n+pub const FXMAC_PHY_SPEED_10G: u32 = 10000;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 35 to 35)\n+pub const FXMAC_PHY_HALF_DUPLEX: u32 = 0;\n+pub const FXMAC_PHY_FULL_DUPLEX: u32 = 1;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 36 to 37)\n-pub const FXMAC_PHY_HALF_DUPLEX: u32 =  0;\n-pub const FXMAC_PHY_FULL_DUPLEX: u32 =  1;\n+pub const FXMAC_RECV_MAX_COUNT: u32 = 10;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 39 to 40)\n-pub const FXMAC_RECV_MAX_COUNT: u32 =10;\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 42 to 42)\n-pub const PQ_QUEUE_SIZE: u32 =4096;\n+pub const PQ_QUEUE_SIZE: u32 = 4096;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 53 to 53)\n-pub const FXMAC_RXBUF_NEW_MASK: u32 = 1<<0;\n+pub const FXMAC_RXBUF_NEW_MASK: u32 = 1 << 0;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 55 to 55)\n-pub const FXMAC_RXBUF_WRAP_MASK: u32 = 1<<1;\n+pub const FXMAC_RXBUF_WRAP_MASK: u32 = 1 << 1;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 61 to 61)\n-pub const FXMAC_TXBUF_USED_MASK: u32 = 1<<31;\n+pub const FXMAC_TXBUF_USED_MASK: u32 = 1 << 31;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 63 to 63)\n-pub const FXMAC_TXBUF_WRAP_MASK: u32 = 1<<30;\n+pub const FXMAC_TXBUF_WRAP_MASK: u32 = 1 << 30;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 69 to 69)\n-pub const BD_ALIGNMENT: u64 = FXMAC_DMABD_MINIMUM_ALIGNMENT*2; // 128\n+pub const BD_ALIGNMENT: u64 = FXMAC_DMABD_MINIMUM_ALIGNMENT * 2; // 128\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 146 to 147)\n-pub struct FXmacNetifBuffer\n-{\n+pub struct FXmacNetifBuffer {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 159 to 159)\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 161 to 161)\n-        let (mut rx_vaddr, mut rx_dma) = crate_interface::call_interface!(crate::KernelFunc::dma_alloc_coherent(alloc_pages));\n+        let (mut rx_vaddr, mut rx_dma) =\n+            crate_interface::call_interface!(crate::KernelFunc::dma_alloc_coherent(alloc_pages));\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 164 to 164)\n-        let (mut tx_vaddr, mut tx_dma) = crate_interface::call_interface!(crate::KernelFunc::dma_alloc_coherent(alloc_pages));\n+        let (mut tx_vaddr, mut tx_dma) =\n+            crate_interface::call_interface!(crate::KernelFunc::dma_alloc_coherent(alloc_pages));\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 177 to 178)\n-pub struct FXmacLwipPort\n-{\n+pub struct FXmacLwipPort {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 189 to 189)\n-    read_reg((crate_interface::call_interface!(crate::KernelFunc::virt_to_phys(bd_ptr as usize)) + offset as usize) as *const u32)\n+    read_reg(\n+        (crate_interface::call_interface!(crate::KernelFunc::virt_to_phys(bd_ptr as usize))\n+            + offset as usize) as *const u32,\n+    )\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 191 to 193)\n-pub fn fxmac_bd_write(bd_ptr: u64, offset: u32, data: u32)\n-{\n-    debug!(\"fxmac_bd_write {:#x} to {:#x}\", data, bd_ptr + offset as u64);\n+pub fn fxmac_bd_write(bd_ptr: u64, offset: u32, data: u32) {\n+    debug!(\n+        \"fxmac_bd_write {:#x} to {:#x}\",\n+        data,\n+        bd_ptr + offset as u64\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 195 to 195)\n-    write_reg((crate_interface::call_interface!(crate::KernelFunc::virt_to_phys(bd_ptr as usize)) + offset as usize) as *mut u32, data);\n+    write_reg(\n+        (crate_interface::call_interface!(crate::KernelFunc::virt_to_phys(bd_ptr as usize))\n+            + offset as usize) as *mut u32,\n+        data,\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 197 to 197)\n-    \n+\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 201 to 210)\n-   bdptr += FXMAC_BD_ADDR_OFFSET as u64;\n-   let temp_ptr = bdptr as *mut u32;\n-   if !temp_ptr.is_null() {\n-       let mut data_value_rx: u32 = unsafe{*temp_ptr};\n-   info!(\"RX WRAP of BD @ {:#x} set {:#x} | FXMAC_RXBUF_WRAP_MASK\", bdptr, data_value_rx);\n-       data_value_rx |= FXMAC_RXBUF_WRAP_MASK;\n-       unsafe {\n-        temp_ptr.write_volatile(data_value_rx);\n-       }\n-   }\n+    bdptr += FXMAC_BD_ADDR_OFFSET as u64;\n+    let temp_ptr = bdptr as *mut u32;\n+    if !temp_ptr.is_null() {\n+        let mut data_value_rx: u32 = unsafe { *temp_ptr };\n+        info!(\n+            \"RX WRAP of BD @ {:#x} set {:#x} | FXMAC_RXBUF_WRAP_MASK\",\n+            bdptr, data_value_rx\n+        );\n+        data_value_rx |= FXMAC_RXBUF_WRAP_MASK;\n+        unsafe {\n+            temp_ptr.write_volatile(data_value_rx);\n+        }\n+    }\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 216 to 225)\n-   bdptr += FXMAC_BD_STAT_OFFSET as u64;\n-   let temp_ptr = bdptr as *mut u32;\n-   if !temp_ptr.is_null() {\n-       let mut data_value_tx: u32 = unsafe{*temp_ptr};\n-   info!(\"TX WRAP of BD @ {:#x} set {:#x} | TXBUF_WRAP\", bdptr, data_value_tx);\n-       data_value_tx |= FXMAC_TXBUF_WRAP_MASK;\n-       unsafe {\n-        temp_ptr.write_volatile(data_value_tx);\n-       }\n-   }\n+    bdptr += FXMAC_BD_STAT_OFFSET as u64;\n+    let temp_ptr = bdptr as *mut u32;\n+    if !temp_ptr.is_null() {\n+        let mut data_value_tx: u32 = unsafe { *temp_ptr };\n+        info!(\n+            \"TX WRAP of BD @ {:#x} set {:#x} | TXBUF_WRAP\",\n+            bdptr, data_value_tx\n+        );\n+        data_value_tx |= FXMAC_TXBUF_WRAP_MASK;\n+        unsafe {\n+            temp_ptr.write_volatile(data_value_tx);\n+        }\n+    }\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 229 to 235)\n-fn FXmacBdringPtrReset(ring_ptr: &mut FXmacBdRing, virtaddrloc: *mut FXmacBd)\n-{\n-   ring_ptr.free_head = virtaddrloc;\n-   ring_ptr.pre_head = virtaddrloc;\n-   ring_ptr.hw_head = virtaddrloc;\n-   ring_ptr.hw_tail = virtaddrloc;\n-   ring_ptr.post_head = virtaddrloc;\n+fn FXmacBdringPtrReset(ring_ptr: &mut FXmacBdRing, virtaddrloc: *mut FXmacBd) {\n+    ring_ptr.free_head = virtaddrloc;\n+    ring_ptr.pre_head = virtaddrloc;\n+    ring_ptr.hw_head = virtaddrloc;\n+    ring_ptr.hw_tail = virtaddrloc;\n+    ring_ptr.post_head = virtaddrloc;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 240 to 244)\n-    fxmac_bd_write((bd_ptr), FXMAC_BD_ADDR_OFFSET,\n-                   ((fxmac_bd_read(bd_ptr, FXMAC_BD_ADDR_OFFSET) & !FXMAC_RXBUF_ADD_MASK) |\n-                    (addr & ULONG64_LO_MASK) as u32));\n-                    \n-    fxmac_bd_write(bd_ptr, FXMAC_BD_ADDR_HI_OFFSET, ((addr & ULONG64_HI_MASK) >> 32) as u32);\n+    fxmac_bd_write(\n+        (bd_ptr),\n+        FXMAC_BD_ADDR_OFFSET,\n+        ((fxmac_bd_read(bd_ptr, FXMAC_BD_ADDR_OFFSET) & !FXMAC_RXBUF_ADD_MASK)\n+            | (addr & ULONG64_LO_MASK) as u32),\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 246 to 246)\n+    fxmac_bd_write(\n+        bd_ptr,\n+        FXMAC_BD_ADDR_HI_OFFSET,\n+        ((addr & ULONG64_HI_MASK) >> 32) as u32,\n+    );\n+\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 251 to 253)\n-    fxmac_bd_write(bd_ptr, FXMAC_BD_ADDR_OFFSET, (addr & ULONG64_LO_MASK) as u32);\n-                   \n-    fxmac_bd_write(bd_ptr, FXMAC_BD_ADDR_HI_OFFSET, ((addr & ULONG64_HI_MASK) >> 32) as u32);\n+    fxmac_bd_write(\n+        bd_ptr,\n+        FXMAC_BD_ADDR_OFFSET,\n+        (addr & ULONG64_LO_MASK) as u32,\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 255 to 255)\n+    fxmac_bd_write(\n+        bd_ptr,\n+        FXMAC_BD_ADDR_HI_OFFSET,\n+        ((addr & ULONG64_HI_MASK) >> 32) as u32,\n+    );\n+\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 259 to 260)\n-fn FXMAC_RING_SEEKAHEAD(ring_ptr: &mut FXmacBdRing, bdptr: &mut (*mut FXmacBd), num_bd: u32)\n-{\n+fn FXMAC_RING_SEEKAHEAD(ring_ptr: &mut FXmacBdRing, bdptr: &mut (*mut FXmacBd), num_bd: u32) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 263 to 266)\n-        // 第一个free BD\n-        // bdptr = free_head\n-        let mut addr: u64 = *bdptr as u64;\n-        addr += (ring_ptr.separation * num_bd) as u64;\n+    // 第一个free BD\n+    // bdptr = free_head\n+    let mut addr: u64 = *bdptr as u64;\n+    addr += (ring_ptr.separation * num_bd) as u64;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 268 to 274)\n-        if (addr > ring_ptr.high_bd_addr) || (*bdptr as u64 > addr)\n-        {\n-            addr -= ring_ptr.length as u64;\n-        }\n-        *bdptr = addr as *mut FXmacBd;\n-        \n-        trace!(\"FXMAC_RING_SEEKAHEAD, bdptr: {:#x}, addr: {:#x}\", *bdptr as u64, addr);\n+    if (addr > ring_ptr.high_bd_addr) || (*bdptr as u64 > addr) {\n+        addr -= ring_ptr.length as u64;\n+    }\n+    *bdptr = addr as *mut FXmacBd;\n+\n+    trace!(\n+        \"FXMAC_RING_SEEKAHEAD, bdptr: {:#x}, addr: {:#x}\",\n+        *bdptr as u64, addr\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 286 to 289)\n-    for i in 0..FXMAX_RX_PBUFS_LENGTH\n-    {\n-        let max_frame_size = if (instance_p.lwipport.feature & FXMAC_LWIP_PORT_CONFIG_JUMBO) != 0\n-        { info!(\"FXMAC_LWIP_PORT_CONFIG_JUMBO\"); FXMAC_MAX_FRAME_SIZE_JUMBO } else { info!(\"NO CONFIG_JUMBO\"); FXMAC_MAX_FRAME_SIZE };\n+    for i in 0..FXMAX_RX_PBUFS_LENGTH {\n+        let max_frame_size = if (instance_p.lwipport.feature & FXMAC_LWIP_PORT_CONFIG_JUMBO) != 0 {\n+            info!(\"FXMAC_LWIP_PORT_CONFIG_JUMBO\");\n+            FXMAC_MAX_FRAME_SIZE_JUMBO\n+        } else {\n+            info!(\"NO CONFIG_JUMBO\");\n+            FXMAC_MAX_FRAME_SIZE\n+        };\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 292 to 293)\n-        let (mut rx_mbufs_vaddr, mut rx_mbufs_dma) = \n-        crate_interface::call_interface!(crate::KernelFunc::dma_alloc_coherent(alloc_rx_buffer_pages));\n+        let (mut rx_mbufs_vaddr, mut rx_mbufs_dma) = crate_interface::call_interface!(\n+            crate::KernelFunc::dma_alloc_coherent(alloc_rx_buffer_pages)\n+        );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 295 to 295)\n-    let rxringptr: &mut FXmacBdRing = &mut instance_p.rx_bd_queue.bdring;\n+        let rxringptr: &mut FXmacBdRing = &mut instance_p.rx_bd_queue.bdring;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 297 to 301)\n-//let my_speed: Box<i32> = Box::new(88);\n-//rxbd = Box::into_raw(my_speed);\n-// OR\n-//let mut my_speed: i32 = 88;\n-//rxbd = &mut my_speed;\n+        //let my_speed: Box<i32> = Box::new(88);\n+        //rxbd = Box::into_raw(my_speed);\n+        // OR\n+        //let mut my_speed: i32 = 88;\n+        //rxbd = &mut my_speed;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 306 to 307)\n-        if (status != 0)\n-        {\n+        if (status != 0) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 324 to 327)\n-        unsafe{\n-        temp.write_volatile(v);\n-        // Clear word 1 in  descriptor\n-        temp.add(1).write_volatile(0);\n+        unsafe {\n+            temp.write_volatile(v);\n+            // Clear word 1 in  descriptor\n+            temp.add(1).write_volatile(0);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 341 to 349)\n-        for index in  0..FXMAX_TX_PBUFS_LENGTH {\n-            let max_fr_size = if (instance_p.lwipport.feature & FXMAC_LWIP_PORT_CONFIG_JUMBO) != 0\n-            {\n-               FXMAC_MAX_FRAME_SIZE_JUMBO\n-            } else {\n-                FXMAC_MAX_FRAME_SIZE\n-            };\n-            let alloc_pages = (max_fr_size as usize + (PAGE_SIZE - 1)) / PAGE_SIZE;\n-            let (mut tx_mbufs_vaddr, mut tx_mbufs_dma) = \n+    for index in 0..FXMAX_TX_PBUFS_LENGTH {\n+        let max_fr_size = if (instance_p.lwipport.feature & FXMAC_LWIP_PORT_CONFIG_JUMBO) != 0 {\n+            FXMAC_MAX_FRAME_SIZE_JUMBO\n+        } else {\n+            FXMAC_MAX_FRAME_SIZE\n+        };\n+        let alloc_pages = (max_fr_size as usize + (PAGE_SIZE - 1)) / PAGE_SIZE;\n+        let (mut tx_mbufs_vaddr, mut tx_mbufs_dma) =\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 351 to 352)\n-    \n-            instance_p.lwipport.buffer.tx_pbufs_storage[index as usize] = tx_mbufs_vaddr as u64;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 354 to 357)\n-            /*\n-            let txbd: *mut FXmacBd = null_mut();\n-            FXmacBdRingAlloc(txringptr, 1, txbd);\n-            FXmacBdRingToHw(txringptr, 1, txbd);\n+        instance_p.lwipport.buffer.tx_pbufs_storage[index as usize] = tx_mbufs_vaddr as u64;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 359 to 361)\n-            let bdindex = FXMAC_BD_TO_INDEX(txringptr, txbd as u64);\n-            assert!(index == bdindex as usize);\n-            */\n+        /*\n+        let txbd: *mut FXmacBd = null_mut();\n+        FXmacBdRingAlloc(txringptr, 1, txbd);\n+        FXmacBdRingToHw(txringptr, 1, txbd);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 363 to 364)\n-            // From index to BD\n-            let txbd = (txringptr.base_bd_addr + (index as u64 * txringptr.separation as u64)) as *mut FXmacBd;\n+        let bdindex = FXMAC_BD_TO_INDEX(txringptr, txbd as u64);\n+        assert!(index == bdindex as usize);\n+        */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 366 to 367)\n-            fxmac_bd_set_address_tx(txbd as u64, tx_mbufs_dma as u64);\n-            //debug!(\"TX DMA DESC {}: {:#010x?}\", index, unsafe{*(txbd as *const macb_dma_desc)});\n+        // From index to BD\n+        let txbd =\n+            (txringptr.base_bd_addr + (index as u64 * txringptr.separation as u64)) as *mut FXmacBd;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 369 to 371)\n-            //curbdpntr = FXMAC_BD_RING_NEXT(txring, curbdpntr);\n-            crate::utils::DSB();\n-        }\n+        fxmac_bd_set_address_tx(txbd as u64, tx_mbufs_dma as u64);\n+        //debug!(\"TX DMA DESC {}: {:#010x?}\", index, unsafe{*(txbd as *const macb_dma_desc)});\n+\n+        //curbdpntr = FXMAC_BD_RING_NEXT(txring, curbdpntr);\n+        crate::utils::DSB();\n+    }\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 375 to 376)\n-pub fn FXmacInitDma(instance_p: &mut FXmac) -> u32\n-{\n+pub fn FXmacInitDma(instance_p: &mut FXmac) -> u32 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 383 to 384)\n-    info!(\"FXmacInitDma, rx_bdspace: {:#x}\", &instance_p.lwipport.buffer.rx_bdspace);\n-    info!(\"FXmacInitDma, tx_bdspace: {:#x}\", &instance_p.lwipport.buffer.tx_bdspace);\n+    info!(\n+        \"FXmacInitDma, rx_bdspace: {:#x}\",\n+        &instance_p.lwipport.buffer.rx_bdspace\n+    );\n+    info!(\n+        \"FXmacInitDma, tx_bdspace: {:#x}\",\n+        &instance_p.lwipport.buffer.tx_bdspace\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 395 to 395)\n-    let mut status: u32 = FXmacBdRingCreate(rxringptr, instance_p.lwipport.buffer.rx_bdspace as u64, instance_p.lwipport.buffer.rx_bdspace as u64, BD_ALIGNMENT, FXMAX_RX_PBUFS_LENGTH as u32);\n+    let mut status: u32 = FXmacBdRingCreate(\n+        rxringptr,\n+        instance_p.lwipport.buffer.rx_bdspace as u64,\n+        instance_p.lwipport.buffer.rx_bdspace as u64,\n+        BD_ALIGNMENT,\n+        FXMAX_RX_PBUFS_LENGTH as u32,\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 409 to 410)\n-    fxmac_bd_write((&bdtemplate as *const _ as u64), FXMAC_BD_STAT_OFFSET, \n-        fxmac_bd_read((&mut bdtemplate as *mut _ as u64), FXMAC_BD_STAT_OFFSET) | (FXMAC_TXBUF_USED_MASK));\n+    fxmac_bd_write(\n+        (&bdtemplate as *const _ as u64),\n+        FXMAC_BD_STAT_OFFSET,\n+        fxmac_bd_read((&mut bdtemplate as *mut _ as u64), FXMAC_BD_STAT_OFFSET)\n+            | (FXMAC_TXBUF_USED_MASK),\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 413 to 413)\n-    status = FXmacBdRingCreate(txringptr, instance_p.lwipport.buffer.tx_bdspace as u64, instance_p.lwipport.buffer.tx_bdspace as u64, BD_ALIGNMENT, FXMAX_TX_PBUFS_LENGTH as u32);\n+    status = FXmacBdRingCreate(\n+        txringptr,\n+        instance_p.lwipport.buffer.tx_bdspace as u64,\n+        instance_p.lwipport.buffer.tx_bdspace as u64,\n+        BD_ALIGNMENT,\n+        FXMAX_TX_PBUFS_LENGTH as u32,\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 423 to 423)\n-    \n+\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 425 to 427)\n-    if (instance_p.config.caps & FXMAC_CAPS_TAILPTR) != 0\n-    {   \n-        write_reg((instance_p.config.base_address + FXMAC_TAIL_QUEUE(0)) as *mut u32, (1<<31) | 0);\n+    if (instance_p.config.caps & FXMAC_CAPS_TAILPTR) != 0 {\n+        write_reg(\n+            (instance_p.config.base_address + FXMAC_TAIL_QUEUE(0)) as *mut u32,\n+            (1 << 31) | 0,\n+        );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 433 to 434)\n-fn FXMAC_BD_TO_INDEX (ringptr: &mut FXmacBdRing, bdptr: u64) -> u32 {\n-    ( (bdptr - ringptr.base_bd_addr as u64) / ringptr.separation as u64 ) as u32\n+fn FXMAC_BD_TO_INDEX(ringptr: &mut FXmacBdRing, bdptr: u64) -> u32 {\n+    ((bdptr - ringptr.base_bd_addr as u64) / ringptr.separation as u64) as u32\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 439 to 443)\n-        if bd_ptr as u64 >= ring_ptr.high_bd_addr {\n-            ring_ptr.base_bd_addr as *mut FXmacBd\n-        }else{\n-            (bd_ptr as u64 + ring_ptr.separation as u64) as *mut FXmacBd\n-        }\n+    if bd_ptr as u64 >= ring_ptr.high_bd_addr {\n+        ring_ptr.base_bd_addr as *mut FXmacBd\n+    } else {\n+        (bd_ptr as u64 + ring_ptr.separation as u64) as *mut FXmacBd\n+    }\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 448 to 449)\n-pub fn FXmacBdRingCreate(ring_ptr: &mut FXmacBdRing, phys_addr: u64, virt_addr: u64, alignment: u64, bd_count: u32) -> u32\n-    {\n+pub fn FXmacBdRingCreate(\n+    ring_ptr: &mut FXmacBdRing,\n+    phys_addr: u64,\n+    virt_addr: u64,\n+    alignment: u64,\n+    bd_count: u32,\n+) -> u32 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 452 to 454)\n-        // alignment=128, bd_count=128\n-       //let alignment = BD_ALIGNMENT;\n-       //let bd_count = FXMAX_RX_PBUFS_LENGTH;\n+    // alignment=128, bd_count=128\n+    //let alignment = BD_ALIGNMENT;\n+    //let bd_count = FXMAX_RX_PBUFS_LENGTH;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 456 to 457)\n-       //let virt_addr_loc = instance_p.buffer.rx_bdspace;\n-       let virt_addr_loc: u64 = virt_addr;\n+    //let virt_addr_loc = instance_p.buffer.rx_bdspace;\n+    let virt_addr_loc: u64 = virt_addr;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 459 to 463)\n- ring_ptr.all_cnt = 0;\n- ring_ptr.free_cnt = 0;\n- ring_ptr.hw_cnt = 0;\n- ring_ptr.pre_cnt = 0;\n- ring_ptr.post_cnt = 0;\n+    ring_ptr.all_cnt = 0;\n+    ring_ptr.free_cnt = 0;\n+    ring_ptr.hw_cnt = 0;\n+    ring_ptr.pre_cnt = 0;\n+    ring_ptr.post_cnt = 0;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 465 to 467)\n-       // 该地址必须对齐alignment=128\n-       assert!((virt_addr_loc % alignment) == 0);\n-       assert!(bd_count > 0);\n+    // 该地址必须对齐alignment=128\n+    assert!((virt_addr_loc % alignment) == 0);\n+    assert!(bd_count > 0);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 469 to 470)\n-       // 相邻BD之间隔多少bytes\n-       ring_ptr.separation = size_of::<FXmacBd>() as u32;\n+    // 相邻BD之间隔多少bytes\n+    ring_ptr.separation = size_of::<FXmacBd>() as u32;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 472 to 474)\n-// Initial ring setup:\n-//  - Clear the entire space\n-//  - Setup each BD's BDA field with the physical address of the next BD\n+    // Initial ring setup:\n+    //  - Clear the entire space\n+    //  - Setup each BD's BDA field with the physical address of the next BD\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 483 to 483)\n-    info!(\"FXmacBdRingCreate BDs count={}, separation={}, {:#x}~{:#x}\", bd_count, ring_ptr.separation, virt_addr, bd_virt_addr);\n+    info!(\n+        \"FXmacBdRingCreate BDs count={}, separation={}, {:#x}~{:#x}\",\n+        bd_count, ring_ptr.separation, virt_addr, bd_virt_addr\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 510 to 510)\n-    }\n+}\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 513 to 514)\n-pub fn FXmacBdRingClone(ring_ptr: &mut FXmacBdRing, src_bd_ptr: & FXmacBd, direction: u32) -> u32\n-{\n+pub fn FXmacBdRingClone(ring_ptr: &mut FXmacBdRing, src_bd_ptr: &FXmacBd, direction: u32) -> u32 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 540 to 540)\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 542 to 546)\n-pub fn FXmacBdRingAlloc(ring_ptr: &mut FXmacBdRing, num_bd: u32, bd_set_ptr: &mut(*mut FXmacBd)) -> u32 {\n-/*\n-let num_bd = 1;\n-let bd_set_ptr = &rxbd;\n-*/\n+pub fn FXmacBdRingAlloc(\n+    ring_ptr: &mut FXmacBdRing,\n+    num_bd: u32,\n+    bd_set_ptr: &mut (*mut FXmacBd),\n+) -> u32 {\n+    /*\n+    let num_bd = 1;\n+    let bd_set_ptr = &rxbd;\n+    */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 554 to 554)\n-        \n+\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 560 to 560)\n-        debug!(\"free_head {:#x} seekahead to {:#x}\", b as usize, ring_ptr.free_head as usize);\n+        debug!(\n+            \"free_head {:#x} seekahead to {:#x}\",\n+            b as usize, ring_ptr.free_head as usize\n+        );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 570 to 570)\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 591 to 592)\n-pub fn FXmacBdRingFromHwRx(ring_ptr: &mut FXmacBdRing, bd_limit: usize, bd_set_ptr: &mut (*mut FXmacBd)) -> u32 {\n-\n+pub fn FXmacBdRingFromHwRx(\n+    ring_ptr: &mut FXmacBdRing,\n+    bd_limit: usize,\n+    bd_set_ptr: &mut (*mut FXmacBd),\n+) -> u32 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 603 to 603)\n-        \n+\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 605 to 606)\n-    }else{\n-         /* Starting at hw_head, keep moving forward in the list until:\n+    } else {\n+        /* Starting at hw_head, keep moving forward in the list until:\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 612 to 612)\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 618 to 618)\n-            let bd_rx_new = fxmac_bd_read(cur_bd_ptr as u64, FXMAC_BD_ADDR_OFFSET) & FXMAC_RXBUF_NEW_MASK;\n+            let bd_rx_new =\n+                fxmac_bd_read(cur_bd_ptr as u64, FXMAC_BD_ADDR_OFFSET) & FXMAC_RXBUF_NEW_MASK;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 632 to 632)\n+            } else {\n+                bd_partial_count += 1;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 633 to 636)\n-            else\n-            {\n-                bd_partial_count+=1;\n-            }\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 640 to 640)\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 655 to 655)\n-    let mut hw_head_t = ring_ptr.hw_head;\n+            let mut hw_head_t = ring_ptr.hw_head;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 671 to 671)\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 677 to 677)\n-pub fn FXmacBdRingFromHwTx(ring_ptr: &mut FXmacBdRing, bd_limit: usize, bd_set_ptr: &mut(*mut FXmacBd)) -> u32 {\n+pub fn FXmacBdRingFromHwTx(\n+    ring_ptr: &mut FXmacBdRing,\n+    bd_limit: usize,\n+    bd_set_ptr: &mut (*mut FXmacBd),\n+) -> u32 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 687 to 688)\n-    if ring_ptr.hw_cnt == 0\n-    {\n+    if ring_ptr.hw_cnt == 0 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 693 to 695)\n-\n-        if bd_limitLoc > ring_ptr.hw_cnt\n-        {\n+        if bd_limitLoc > ring_ptr.hw_cnt {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 706 to 706)\n-                bd_str = fxmac_bd_read(cur_bd_ptr as u64, FXMAC_BD_STAT_OFFSET);\n+            bd_str = fxmac_bd_read(cur_bd_ptr as u64, FXMAC_BD_STAT_OFFSET);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 710 to 711)\n-            if (bd_str & FXMAC_TXBUF_USED_MASK) != 0\n-            {\n+            if (bd_str & FXMAC_TXBUF_USED_MASK) != 0 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 721 to 722)\n-            if (bd_str & FXMAC_TXBUF_LAST_MASK) != 0\n-            {\n+            if (bd_str & FXMAC_TXBUF_LAST_MASK) != 0 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 784 to 786)\n-   \n-        if (instance_p.lwipport.feature & FXMAC_LWIP_PORT_CONFIG_JUMBO) != 0\n-        {\n+\n+        if (instance_p.lwipport.feature & FXMAC_LWIP_PORT_CONFIG_JUMBO) != 0 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 788 to 790)\n-        }\n-        else\n-        {\n+        } else {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 799 to 799)\n-         warn!(\">>>>>>>>> TX PKT {} @{:#x} - {}\", pbufs_len, pbufs_virt, bdindex);\n+        warn!(\n+            \">>>>>>>>> TX PKT {} @{:#x} - {}\",\n+            pbufs_len, pbufs_virt, bdindex\n+        );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 806 to 807)\n-        if q.len() > max_fr_size as usize\n-        {\n+        if q.len() > max_fr_size as usize {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 811 to 812)\n-            fxmac_bd_write(txbd as u64, FXMAC_BD_STAT_OFFSET,\n-                ((fxmac_bd_read(txbd as u64, FXMAC_BD_STAT_OFFSET) & !FXMAC_TXBUF_LEN_MASK) | (max_fr_size & 0x3FFF)));\n+            fxmac_bd_write(\n+                txbd as u64,\n+                FXMAC_BD_STAT_OFFSET,\n+                ((fxmac_bd_read(txbd as u64, FXMAC_BD_STAT_OFFSET) & !FXMAC_TXBUF_LEN_MASK)\n+                    | (max_fr_size & 0x3FFF)),\n+            );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 814 to 815)\n-        fxmac_bd_write(txbd as u64, FXMAC_BD_STAT_OFFSET,\n-            ((fxmac_bd_read(txbd as u64, FXMAC_BD_STAT_OFFSET) & !FXMAC_TXBUF_LEN_MASK) | (q.len() as u32 & 0x3FFF)));\n+            fxmac_bd_write(\n+                txbd as u64,\n+                FXMAC_BD_STAT_OFFSET,\n+                ((fxmac_bd_read(txbd as u64, FXMAC_BD_STAT_OFFSET) & !FXMAC_TXBUF_LEN_MASK)\n+                    | (q.len() as u32 & 0x3FFF)),\n+            );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 827 to 828)\n-        fxmac_bd_write(t_txbd, FXMAC_BD_STAT_OFFSET,\n-            fxmac_bd_read(t_txbd, FXMAC_BD_STAT_OFFSET) & !FXMAC_TXBUF_LAST_MASK );\n+        fxmac_bd_write(\n+            t_txbd,\n+            FXMAC_BD_STAT_OFFSET,\n+            fxmac_bd_read(t_txbd, FXMAC_BD_STAT_OFFSET) & !FXMAC_TXBUF_LAST_MASK,\n+        );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 835 to 836)\n-    fxmac_bd_write(t_txbd, FXMAC_BD_STAT_OFFSET,\n-        fxmac_bd_read(t_txbd, FXMAC_BD_STAT_OFFSET) | FXMAC_TXBUF_LAST_MASK );\n+    fxmac_bd_write(\n+        t_txbd,\n+        FXMAC_BD_STAT_OFFSET,\n+        fxmac_bd_read(t_txbd, FXMAC_BD_STAT_OFFSET) | FXMAC_TXBUF_LAST_MASK,\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 841 to 843)\n-    if (instance_p.config.caps & FXMAC_CAPS_TAILPTR) != 0\n-    {\n-         bdindex = FXMAC_BD_TO_INDEX(txring, txbd as u64);\n+    if (instance_p.config.caps & FXMAC_CAPS_TAILPTR) != 0 {\n+        bdindex = FXMAC_BD_TO_INDEX(txring, txbd as u64);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 848 to 849)\n-    let FXMAC_BD_CLEAR_TX_USED = |bd_ptr: u64|\n-            fxmac_bd_write(bd_ptr, FXMAC_BD_STAT_OFFSET, fxmac_bd_read(bd_ptr, FXMAC_BD_STAT_OFFSET) & (!FXMAC_TXBUF_USED_MASK));\n+    let FXMAC_BD_CLEAR_TX_USED = |bd_ptr: u64| {\n+        fxmac_bd_write(\n+            bd_ptr,\n+            FXMAC_BD_STAT_OFFSET,\n+            fxmac_bd_read(bd_ptr, FXMAC_BD_STAT_OFFSET) & (!FXMAC_TXBUF_USED_MASK),\n+        )\n+    };\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 862 to 864)\n-    if (instance_p.config.caps & FXMAC_CAPS_TAILPTR) != 0\n-    {   \n-        write_reg((instance_p.config.base_address + FXMAC_TAIL_QUEUE(0)) as *mut u32, (1 << 31) | bdindex);\n+    if (instance_p.config.caps & FXMAC_CAPS_TAILPTR) != 0 {\n+        write_reg(\n+            (instance_p.config.base_address + FXMAC_TAIL_QUEUE(0)) as *mut u32,\n+            (1 << 31) | bdindex,\n+        );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 867 to 867)\n-    debug!(\"TX DMA DESC: {:#010x?}\", unsafe{*(txbdset as *const macb_dma_desc)});\n+    debug!(\"TX DMA DESC: {:#010x?}\", unsafe {\n+        *(txbdset as *const macb_dma_desc)\n+    });\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 870 to 871)\n-    let value = read_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32) | FXMAC_NWCTRL_STARTTX_MASK;\n-    write_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32, value);\n+    let value = read_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32)\n+        | FXMAC_NWCTRL_STARTTX_MASK;\n+    write_reg(\n+        (instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32,\n+        value,\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 885 to 885)\n-     to handle the processed BDs and then raise the according flag.*/\n+    to handle the processed BDs and then raise the according flag.*/\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 887 to 887)\n-    write_reg((instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *mut u32, regval);\n+    write_reg(\n+        (instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *mut u32,\n+        regval,\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 891 to 893)\n-        let bd_processed: u32 = FXmacBdRingFromHwRx(&mut instance_p.rx_bd_queue.bdring, FXMAX_RX_PBUFS_LENGTH, &mut rxbdset);\n-        if bd_processed == 0\n-        {\n+        let bd_processed: u32 = FXmacBdRingFromHwRx(\n+            &mut instance_p.rx_bd_queue.bdring,\n+            FXMAX_RX_PBUFS_LENGTH,\n+            &mut rxbdset,\n+        );\n+        if bd_processed == 0 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 901 to 901)\n+            let rxring: &mut FXmacBdRing = &mut instance_p.rx_bd_queue.bdring;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 902 to 903)\n-    let rxring: &mut FXmacBdRing = &mut instance_p.rx_bd_queue.bdring;\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 905 to 906)\n-            let rx_bytes: u32 =\n-            if (instance_p.lwipport.feature & FXMAC_LWIP_PORT_CONFIG_JUMBO) != 0\n+            let rx_bytes: u32 = if (instance_p.lwipport.feature & FXMAC_LWIP_PORT_CONFIG_JUMBO) != 0\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 910 to 910)\n-           \n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 919 to 919)\n-            debug!(\"RX PKT {} @{:#x} <<<<<<<<< - {}\", rx_bytes, pbufs_virt, bdindex);\n+            debug!(\n+                \"RX PKT {} @{:#x} <<<<<<<<< - {}\",\n+                rx_bytes, pbufs_virt, bdindex\n+            );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 927 to 935)\n-           /*  \n-            The value of hash_match indicates the hash result of the received packet \n-               0: No hash match \n-               1: Unicast hash match \n-               2: Multicast hash match\n-               3: Reserved, the value is not legal\n-           */\n-           // FXMAC_BD_GET_HASH_MATCH(bd_ptr)\n-            let mut hash_match: u32 = (fxmac_bd_read(curbdptr as u64, FXMAC_BD_STAT_OFFSET) & FXMAC_RXBUF_HASH_MASK) >> 29;\n+            /*\n+             The value of hash_match indicates the hash result of the received packet\n+                0: No hash match\n+                1: Unicast hash match\n+                2: Multicast hash match\n+                3: Reserved, the value is not legal\n+            */\n+            // FXMAC_BD_GET_HASH_MATCH(bd_ptr)\n+            let mut hash_match: u32 = (fxmac_bd_read(curbdptr as u64, FXMAC_BD_STAT_OFFSET)\n+                & FXMAC_RXBUF_HASH_MASK)\n+                >> 29;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 937 to 937)\n-    \n+\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 940 to 940)\n-            crate::utils::FCacheDCacheInvalidateRange(instance_p.lwipport.buffer.rx_pbufs_storage[bdindex as usize], rx_bytes as u64);\n+            crate::utils::FCacheDCacheInvalidateRange(\n+                instance_p.lwipport.buffer.rx_pbufs_storage[bdindex as usize],\n+                rx_bytes as u64,\n+            );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 999 to 999)\n-        let rx_macb_dma_desc = unsafe{(rxbd as *const macb_dma_desc).read_volatile()};\n+        let rx_macb_dma_desc = unsafe { (rxbd as *const macb_dma_desc).read_volatile() };\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1007 to 1007)\n-        \n+\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1010 to 1011)\n-        temp.add(1).write_volatile(0); // clear rx ctl\n-        temp.write_volatile(v); // set rx addr\n+            temp.add(1).write_volatile(0); // clear rx ctl\n+            temp.write_volatile(v); // set rx addr\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1025 to 1025)\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1037 to 1037)\n-        \n+\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1043 to 1044)\n-pub fn ResetDma(instance_p: &mut FXmac)\n-{\n+pub fn ResetDma(instance_p: &mut FXmac) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1050 to 1051)\n-    FXmacBdringPtrReset(txringptr, instance_p.lwipport.buffer.tx_bdspace as *mut FXmacBd);\n-    FXmacBdringPtrReset(rxringptr, instance_p.lwipport.buffer.rx_bdspace as *mut FXmacBd);\n+    FXmacBdringPtrReset(\n+        txringptr,\n+        instance_p.lwipport.buffer.tx_bdspace as *mut FXmacBd,\n+    );\n+    FXmacBdringPtrReset(\n+        rxringptr,\n+        instance_p.lwipport.buffer.rx_bdspace as *mut FXmacBd,\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1058 to 1059)\n-pub fn FXmacHandleDmaTxError(instance_p: &mut FXmac)\n-{\n+pub fn FXmacHandleDmaTxError(instance_p: &mut FXmac) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1077 to 1079)\n-pub fn FXmacHandleTxErrors(instance_p: &mut FXmac)\n-{\n-    let mut netctrlreg: u32 = read_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32);\n+pub fn FXmacHandleTxErrors(instance_p: &mut FXmac) {\n+    let mut netctrlreg: u32 =\n+        read_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1081 to 1081)\n-    write_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32, netctrlreg);\n+    write_reg(\n+        (instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32,\n+        netctrlreg,\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1087 to 1087)\n-    write_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32, netctrlreg);\n+    write_reg(\n+        (instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32,\n+        netctrlreg,\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1090 to 1091)\n-fn CleanDmaTxdescs(instance_p: &mut FXmac)\n-{\n+fn CleanDmaTxdescs(instance_p: &mut FXmac) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1098 to 1099)\n-    fxmac_bd_write((&mut bdtemplate as *mut _ as u64), FXMAC_BD_STAT_OFFSET, \n-        fxmac_bd_read((&mut bdtemplate as *mut _ as u64), FXMAC_BD_STAT_OFFSET) | (FXMAC_TXBUF_USED_MASK));\n+    fxmac_bd_write(\n+        (&mut bdtemplate as *mut _ as u64),\n+        FXMAC_BD_STAT_OFFSET,\n+        fxmac_bd_read((&mut bdtemplate as *mut _ as u64), FXMAC_BD_STAT_OFFSET)\n+            | (FXMAC_TXBUF_USED_MASK),\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1102 to 1102)\n-    FXmacBdRingCreate(txringptr, tx_bdspace_ptr, tx_bdspace_ptr, BD_ALIGNMENT, FXMAX_TX_BDSPACE_LENGTH as u32);\n+    FXmacBdRingCreate(\n+        txringptr,\n+        tx_bdspace_ptr,\n+        tx_bdspace_ptr,\n+        BD_ALIGNMENT,\n+        FXMAX_TX_BDSPACE_LENGTH as u32,\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1106 to 1107)\n-fn FreeOnlyTxPbufs(instance_p: &mut FXmac)\n-{\n+fn FreeOnlyTxPbufs(instance_p: &mut FXmac) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1109 to 1112)\n-    for index in  0..FXMAX_TX_PBUFS_LENGTH\n-    {\n-        if (instance_p.lwipport.buffer.tx_pbufs_storage[index] != 0)\n-        {\n+    for index in 0..FXMAX_TX_PBUFS_LENGTH {\n+        if (instance_p.lwipport.buffer.tx_pbufs_storage[index] != 0) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1115 to 1115)\n-            crate_interface::call_interface!(crate::KernelFunc::dma_free_coherent(pbuf as usize, pages));\n+            crate_interface::call_interface!(crate::KernelFunc::dma_free_coherent(\n+                pbuf as usize,\n+                pages\n+            ));\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1123 to 1124)\n-pub fn FXmacProcessSentBds(instance_p: &mut FXmac)\n-{\n+pub fn FXmacProcessSentBds(instance_p: &mut FXmac) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1140 to 1140)\n-            trace!(\"FXmacProcessSentBds - {}: {:#010x?}\", bdindex, unsafe{*(curbdpntr as *const macb_dma_desc)});\n+            trace!(\"FXmacProcessSentBds - {}: {:#010x?}\", bdindex, unsafe {\n+                *(curbdpntr as *const macb_dma_desc)\n+            });\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1150 to 1152)\n-            unsafe{\n-            //temp.write_volatile(0); // 这里不再对dma buffer地址清0\n-            temp.add(1).write_volatile(v); // 设置dma desc的ctrl\n+            unsafe {\n+                //temp.write_volatile(0); // 这里不再对dma buffer地址清0\n+                temp.add(1).write_volatile(v); // 设置dma desc的ctrl\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1178 to 1179)\n-pub fn FXmacSendHandler(instance: &mut FXmac)\n-{\n+pub fn FXmacSendHandler(instance: &mut FXmac) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1185 to 1185)\n-    write_reg((instance.config.base_address + FXMAC_TXSR_OFFSET) as *mut u32, regval);\n+    write_reg(\n+        (instance.config.base_address + FXMAC_TXSR_OFFSET) as *mut u32,\n+        regval,\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1192 to 1193)\n-pub fn FXmacLinkChange(instance: &mut FXmac)\n-{\n+pub fn FXmacLinkChange(instance: &mut FXmac) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1196 to 1197)\n-    if instance.config.interface == FXmacPhyInterface::FXMAC_PHY_INTERFACE_MODE_SGMII\n-    {\n+    if instance.config.interface == FXmacPhyInterface::FXMAC_PHY_INTERFACE_MODE_SGMII {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1201 to 1202)\n-        let ctrl: u32 = read_reg((instance.config.base_address + FXMAC_PCS_AN_LP_OFFSET) as *const u32);\n-        let link: u32 = (ctrl & FXMAC_PCS_LINK_PARTNER_NEXT_PAGE_STATUS) >> FXMAC_PCS_LINK_PARTNER_NEXT_PAGE_OFFSET;\n+        let ctrl: u32 =\n+            read_reg((instance.config.base_address + FXMAC_PCS_AN_LP_OFFSET) as *const u32);\n+        let link: u32 = (ctrl & FXMAC_PCS_LINK_PARTNER_NEXT_PAGE_STATUS)\n+            >> FXMAC_PCS_LINK_PARTNER_NEXT_PAGE_OFFSET;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1205 to 1207)\n-         0 => {\n-            info!(\"link status is down\");\n-            link_status = FXMAC_LINKDOWN;\n+            0 => {\n+                info!(\"link status is down\");\n+                link_status = FXMAC_LINKDOWN;\n+            }\n+            1 => {\n+                info!(\"link status is up\");\n+                link_status = FXMAC_LINKUP;\n+            }\n+            _ => {\n+                error!(\"link status is error {:#x}\", link);\n+            }\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1209 to 1216)\n-         1 => {\n-            info!(\"link status is up\");\n-            link_status = FXMAC_LINKUP;\n-        }\n-        _ => {\n-            error!(\"link status is error {:#x}\", link);\n-        }\n-    }\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1218 to 1221)\n-        if link_status == FXMAC_LINKUP\n-        {\n-            if link_status != instance.link_status\n-            {\n+        if link_status == FXMAC_LINKUP {\n+            if link_status != instance.link_status {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1225 to 1227)\n-        }\n-        else\n-        {\n+        } else {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1243 to 1244)\n-pub fn phy_link_detect(xmac_p: &mut FXmac, phy_addr: u32) -> u32\n-{\n+pub fn phy_link_detect(xmac_p: &mut FXmac, phy_addr: u32) -> u32 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1257 to 1258)\n-pub fn phy_autoneg_status(xmac_p: &mut FXmac, phy_addr: u32) -> u32\n-{\n+pub fn phy_autoneg_status(xmac_p: &mut FXmac, phy_addr: u32) -> u32 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1264 to 1264)\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1278 to 1278)\n-    if freecnt <= 4 { //5\n+    if freecnt <= 4 {\n+        //5\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1285 to 1285)\n-    }else{\n+    } else {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1291 to 1295)\n-pub fn ethernetif_input_to_recv_packets(instance_p: &mut FXmac)\n-{\n-    if(instance_p.lwipport.recv_flg > 0)\n-    {\n-      info!(\"ethernetif_input_to_recv_packets, fxmac_port->recv_flg={}\", instance_p.lwipport.recv_flg);\n+pub fn ethernetif_input_to_recv_packets(instance_p: &mut FXmac) {\n+    if (instance_p.lwipport.recv_flg > 0) {\n+        info!(\n+            \"ethernetif_input_to_recv_packets, fxmac_port->recv_flg={}\",\n+            instance_p.lwipport.recv_flg\n+        );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1297 to 1298)\n-      // 也许需要屏蔽中断的临界区来保护\n-      instance_p.lwipport.recv_flg -= 1;\n+        // 也许需要屏蔽中断的临界区来保护\n+        instance_p.lwipport.recv_flg -= 1;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1300 to 1301)\n-      // 开中断\n-      write_reg((instance_p.config.base_address + FXMAC_IER_OFFSET) as *mut u32, instance_p.mask);\n+        // 开中断\n+        write_reg(\n+            (instance_p.config.base_address + FXMAC_IER_OFFSET) as *mut u32,\n+            instance_p.mask,\n+        );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1303 to 1304)\n-      // 若需要中断处理函数中来接收包，可以这里解注释\n-      //FXmacRecvHandler(instance_p);\n+        // 若需要中断处理函数中来接收包，可以这里解注释\n+        //FXmacRecvHandler(instance_p);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_dma.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1314 to 1314)\n+\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 6 to 6)\n-use crate::fxmac_const::*;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 8 to 8)\n+use crate::fxmac_const::*;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 11 to 56)\n-pub const FXMAC_NUM:u32 = 4;\n-pub const FXMAC0_ID:u32 = 0;\n-pub const FXMAC1_ID:u32 = 1;\n-pub const FXMAC2_ID:u32 = 2;\n-pub const FXMAC3_ID:u32 = 3;\n-pub const FXMAC0_BASE_ADDR:u32 =  0x3200C000;\n-pub const FXMAC1_BASE_ADDR:u32 =  0x3200E000;\n-pub const FXMAC2_BASE_ADDR:u32 =  0x32010000;\n-pub const FXMAC3_BASE_ADDR:u32 =  0x32012000;\n-pub const FXMAC0_MODE_SEL_BASE_ADDR:u32 =  0x3200DC00;\n-pub const FXMAC0_LOOPBACK_SEL_BASE_ADDR:u32 =  0x3200DC04;\n-pub const FXMAC1_MODE_SEL_BASE_ADDR:u32 =  0x3200FC00;\n-pub const FXMAC1_LOOPBACK_SEL_BASE_ADDR:u32 =  0x3200FC04;\n-pub const FXMAC2_MODE_SEL_BASE_ADDR:u32 =  0x32011C00;\n-pub const FXMAC2_LOOPBACK_SEL_BASE_ADDR:u32 =  0x32011C04;\n-pub const FXMAC3_MODE_SEL_BASE_ADDR:u32 =  0x32013C00;\n-pub const FXMAC3_LOOPBACK_SEL_BASE_ADDR:u32 =  0x32013C04;\n-pub const FXMAC0_PCLK:u32 = 50000000;\n-pub const FXMAC1_PCLK:u32 = 50000000;\n-pub const FXMAC2_PCLK:u32 = 50000000;\n-pub const FXMAC3_PCLK:u32 = 50000000;\n-pub const FXMAC0_HOTPLUG_IRQ_NUM:u32 = (53 + 30);\n-pub const FXMAC1_HOTPLUG_IRQ_NUM:u32 = (54 + 30);\n-pub const FXMAC2_HOTPLUG_IRQ_NUM:u32 = (55 + 30);\n-pub const FXMAC3_HOTPLUG_IRQ_NUM:u32 = (56 + 30);\n-pub const FXMAC_QUEUE_MAX_NUM:u32 = 16; // #define FXMAC_QUEUE_MAX_NUM 16U\n-pub const FXMAC0_QUEUE0_IRQ_NUM:u32 = (57 + 30);\n-pub const FXMAC0_QUEUE1_IRQ_NUM:u32 = (58 + 30);\n-pub const FXMAC0_QUEUE2_IRQ_NUM:u32 = (59 + 30);\n-pub const FXMAC0_QUEUE3_IRQ_NUM:u32 = (60 + 30);\n-pub const FXMAC0_QUEUE4_IRQ_NUM:u32 = (30 + 30);\n-pub const FXMAC0_QUEUE5_IRQ_NUM:u32 = (31 + 30);\n-pub const FXMAC0_QUEUE6_IRQ_NUM:u32 = (32 + 30);\n-pub const FXMAC0_QUEUE7_IRQ_NUM:u32 = (33 + 30);\n-pub const FXMAC1_QUEUE0_IRQ_NUM:u32 = (61 + 30);\n-pub const FXMAC1_QUEUE1_IRQ_NUM:u32 = (62 + 30);\n-pub const FXMAC1_QUEUE2_IRQ_NUM:u32 = (63 + 30);\n-pub const FXMAC1_QUEUE3_IRQ_NUM:u32 = (64 + 30);\n-pub const FXMAC2_QUEUE0_IRQ_NUM:u32 = (66 + 30);\n-pub const FXMAC2_QUEUE1_IRQ_NUM:u32 = (67 + 30);\n-pub const FXMAC2_QUEUE2_IRQ_NUM:u32 = (68 + 30);\n-pub const FXMAC2_QUEUE3_IRQ_NUM:u32 = (69 + 30);\n-pub const FXMAC3_QUEUE0_IRQ_NUM:u32 = (70 + 30);\n-pub const FXMAC3_QUEUE1_IRQ_NUM:u32 = (71 + 30);\n-pub const FXMAC3_QUEUE2_IRQ_NUM:u32 = (72 + 30);\n-pub const FXMAC3_QUEUE3_IRQ_NUM:u32 = (73 + 30);\n+pub const FXMAC_NUM: u32 = 4;\n+pub const FXMAC0_ID: u32 = 0;\n+pub const FXMAC1_ID: u32 = 1;\n+pub const FXMAC2_ID: u32 = 2;\n+pub const FXMAC3_ID: u32 = 3;\n+pub const FXMAC0_BASE_ADDR: u32 = 0x3200C000;\n+pub const FXMAC1_BASE_ADDR: u32 = 0x3200E000;\n+pub const FXMAC2_BASE_ADDR: u32 = 0x32010000;\n+pub const FXMAC3_BASE_ADDR: u32 = 0x32012000;\n+pub const FXMAC0_MODE_SEL_BASE_ADDR: u32 = 0x3200DC00;\n+pub const FXMAC0_LOOPBACK_SEL_BASE_ADDR: u32 = 0x3200DC04;\n+pub const FXMAC1_MODE_SEL_BASE_ADDR: u32 = 0x3200FC00;\n+pub const FXMAC1_LOOPBACK_SEL_BASE_ADDR: u32 = 0x3200FC04;\n+pub const FXMAC2_MODE_SEL_BASE_ADDR: u32 = 0x32011C00;\n+pub const FXMAC2_LOOPBACK_SEL_BASE_ADDR: u32 = 0x32011C04;\n+pub const FXMAC3_MODE_SEL_BASE_ADDR: u32 = 0x32013C00;\n+pub const FXMAC3_LOOPBACK_SEL_BASE_ADDR: u32 = 0x32013C04;\n+pub const FXMAC0_PCLK: u32 = 50000000;\n+pub const FXMAC1_PCLK: u32 = 50000000;\n+pub const FXMAC2_PCLK: u32 = 50000000;\n+pub const FXMAC3_PCLK: u32 = 50000000;\n+pub const FXMAC0_HOTPLUG_IRQ_NUM: u32 = (53 + 30);\n+pub const FXMAC1_HOTPLUG_IRQ_NUM: u32 = (54 + 30);\n+pub const FXMAC2_HOTPLUG_IRQ_NUM: u32 = (55 + 30);\n+pub const FXMAC3_HOTPLUG_IRQ_NUM: u32 = (56 + 30);\n+pub const FXMAC_QUEUE_MAX_NUM: u32 = 16; // #define FXMAC_QUEUE_MAX_NUM 16U\n+pub const FXMAC0_QUEUE0_IRQ_NUM: u32 = (57 + 30);\n+pub const FXMAC0_QUEUE1_IRQ_NUM: u32 = (58 + 30);\n+pub const FXMAC0_QUEUE2_IRQ_NUM: u32 = (59 + 30);\n+pub const FXMAC0_QUEUE3_IRQ_NUM: u32 = (60 + 30);\n+pub const FXMAC0_QUEUE4_IRQ_NUM: u32 = (30 + 30);\n+pub const FXMAC0_QUEUE5_IRQ_NUM: u32 = (31 + 30);\n+pub const FXMAC0_QUEUE6_IRQ_NUM: u32 = (32 + 30);\n+pub const FXMAC0_QUEUE7_IRQ_NUM: u32 = (33 + 30);\n+pub const FXMAC1_QUEUE0_IRQ_NUM: u32 = (61 + 30);\n+pub const FXMAC1_QUEUE1_IRQ_NUM: u32 = (62 + 30);\n+pub const FXMAC1_QUEUE2_IRQ_NUM: u32 = (63 + 30);\n+pub const FXMAC1_QUEUE3_IRQ_NUM: u32 = (64 + 30);\n+pub const FXMAC2_QUEUE0_IRQ_NUM: u32 = (66 + 30);\n+pub const FXMAC2_QUEUE1_IRQ_NUM: u32 = (67 + 30);\n+pub const FXMAC2_QUEUE2_IRQ_NUM: u32 = (68 + 30);\n+pub const FXMAC2_QUEUE3_IRQ_NUM: u32 = (69 + 30);\n+pub const FXMAC3_QUEUE0_IRQ_NUM: u32 = (70 + 30);\n+pub const FXMAC3_QUEUE1_IRQ_NUM: u32 = (71 + 30);\n+pub const FXMAC3_QUEUE2_IRQ_NUM: u32 = (72 + 30);\n+pub const FXMAC3_QUEUE3_IRQ_NUM: u32 = (73 + 30);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 67 to 67)\n-         let xmac_ptr = unsafe{ &mut (*xmac)};\n+        let xmac_ptr = unsafe { &mut (*xmac) };\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 69 to 71)\n-         // maybe irq num\n-         let vector = xmac_ptr.config.queue_irq_num[0] ;\n-         FXmacIntrHandler(vector as i32, xmac_ptr);\n+        // maybe irq num\n+        let vector = xmac_ptr.config.queue_irq_num[0];\n+        FXmacIntrHandler(vector as i32, xmac_ptr);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 73 to 75)\n-         info!(\"xmac intr is already handled\");\n-} else {\n-    error!(\"static FXmac has not been initialized\");\n+        info!(\"xmac intr is already handled\");\n+    } else {\n+        error!(\"static FXmac has not been initialized\");\n+    }\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 78 to 79)\n-}\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 85 to 85)\n-/// \n+///\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 87 to 87)\n-     assert!(instance_p.is_ready == FT_COMPONENT_IS_READY as u32);\n+    assert!(instance_p.is_ready == FT_COMPONENT_IS_READY as u32);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 89 to 92)\n-     // 0 ~ FXMAC_QUEUE_MAX_NUM ,Index queue number\n-     let tx_queue_id = instance_p.tx_bd_queue.queue_id;\n-     // 0 ~ FXMAC_QUEUE_MAX_NUM ,Index queue number\n-     let rx_queue_id = instance_p.rx_bd_queue.queue_id;\n+    // 0 ~ FXMAC_QUEUE_MAX_NUM ,Index queue number\n+    let tx_queue_id = instance_p.tx_bd_queue.queue_id;\n+    // 0 ~ FXMAC_QUEUE_MAX_NUM ,Index queue number\n+    let rx_queue_id = instance_p.rx_bd_queue.queue_id;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 94 to 101)\n-     assert!((rx_queue_id < FXMAC_QUEUE_MAX_NUM) && (tx_queue_id < FXMAC_QUEUE_MAX_NUM));\n- \n-     /* This ISR will try to handle as many interrupts as it can in a single\n-      * call. However, in most of the places where the user's error handler\n-      * is called, this ISR exits because it is expected that the user will\n-      * reset the device in nearly all instances.\n-      */\n-     let mut reg_isr: u32 = read_reg((instance_p.config.base_address + FXMAC_ISR_OFFSET) as *const u32);\n+    assert!((rx_queue_id < FXMAC_QUEUE_MAX_NUM) && (tx_queue_id < FXMAC_QUEUE_MAX_NUM));\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 103 to 118)\n-     info!(\"+++++++++ IRQ num vector={}, Interrupt Status ISR={:#x}, tx_queue_id={}, rx_queue_id={}\", vector, reg_isr, tx_queue_id, rx_queue_id);\n- \n-     if vector as u32 == instance_p.config.queue_irq_num[tx_queue_id as usize] {\n-         if tx_queue_id == 0\n-         {\n-             if (reg_isr & FXMAC_IXR_TXCOMPL_MASK) != 0\n-             {\n-                 // Clear TX status register TX complete indication but preserve error bits if there is any\n-        write_reg((instance_p.config.base_address + FXMAC_TXSR_OFFSET) as *mut u32, FXMAC_TXSR_TXCOMPL_MASK | FXMAC_TXSR_USEDREAD_MASK);\n-                \n-                     FXmacSendHandler(instance_p);\n- \n-                 /* add */\n-                 if(instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0\n-                 {\n-        write_reg((instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32, FXMAC_IXR_TXCOMPL_MASK);\n+    /* This ISR will try to handle as many interrupts as it can in a single\n+     * call. However, in most of the places where the user's error handler\n+     * is called, this ISR exits because it is expected that the user will\n+     * reset the device in nearly all instances.\n+     */\n+    let mut reg_isr: u32 =\n+        read_reg((instance_p.config.base_address + FXMAC_ISR_OFFSET) as *const u32);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 120 to 128)\n-                 }\n-             }\n- \n-             /* Transmit error conditions interrupt */\n-             if ((reg_isr & FXMAC_IXR_TX_ERR_MASK) != 0) &&\n-                 ((reg_isr & FXMAC_IXR_TXCOMPL_MASK) == 0)\n-             {\n-                 /* Clear TX status register */\n-                 let reg_txsr: u32 = read_reg((instance_p.config.base_address + FXMAC_TXSR_OFFSET) as *const u32);\n+    info!(\n+        \"+++++++++ IRQ num vector={}, Interrupt Status ISR={:#x}, tx_queue_id={}, rx_queue_id={}\",\n+        vector, reg_isr, tx_queue_id, rx_queue_id\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 130 to 130)\n-        write_reg((instance_p.config.base_address + FXMAC_TXSR_OFFSET) as *mut u32, reg_txsr);\n+    if vector as u32 == instance_p.config.queue_irq_num[tx_queue_id as usize] {\n+        if tx_queue_id == 0 {\n+            if (reg_isr & FXMAC_IXR_TXCOMPL_MASK) != 0 {\n+                // Clear TX status register TX complete indication but preserve error bits if there is any\n+                write_reg(\n+                    (instance_p.config.base_address + FXMAC_TXSR_OFFSET) as *mut u32,\n+                    FXMAC_TXSR_TXCOMPL_MASK | FXMAC_TXSR_USEDREAD_MASK,\n+                );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 132 to 132)\n-                    FXmacErrorHandler(instance_p, FXMAC_SEND as u8, reg_txsr);\n+                FXmacSendHandler(instance_p);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 134 to 147)\n-                 /* add */\n-                 if(instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0\n-                 {\n-        write_reg((instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32, FXMAC_IXR_TX_ERR_MASK);\n-                 }\n-             }\n- \n-             /* add restart */\n-             if (reg_isr & FXMAC_IXR_TXUSED_MASK) != 0\n-             {\n-                 /* add */\n-                 if(instance_p.caps& FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0\n-                 {\n-        write_reg((instance_p.config.base_address+FXMAC_ISR_OFFSET) as *mut u32, FXMAC_IXR_TXUSED_MASK);\n+                /* add */\n+                if (instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0 {\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32,\n+                        FXMAC_IXR_TXCOMPL_MASK,\n+                    );\n+                }\n+            }\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 149 to 181)\n-                 }\n- \n-                 /*\n-                 if (instance_p->restart_handler)\n-                 {\n-                     instance_p->restart_handler(instance_p->restart_args);\n-                 }\n-                 */\n-             }\n-             \n-             /* link changed */\n-             if (reg_isr & FXMAC_IXR_LINKCHANGE_MASK) != 0\n-             {\n-        \n-                    FXmacLinkChange(instance_p);\n- \n-                 if(instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0\n-                 {\n-                     write_reg((instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32, FXMAC_IXR_LINKCHANGE_MASK);\n-                 }\n-             }\n-         }\n-         else /* use queue number more than 0 */\n-         {\n-             reg_isr = read_reg((instance_p.config.base_address + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, tx_queue_id)) as *const u32);\n- \n-             /* Transmit Q1 complete interrupt */\n-             if ((reg_isr & FXMAC_INTQUESR_TXCOMPL_MASK) != 0)\n-             {\n-                 /* Clear TX status register TX complete indication but preserve\n-                  * error bits if there is any */\n-                write_reg((instance_p.config.base_address + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, tx_queue_id)) as *mut u32, FXMAC_INTQUESR_TXCOMPL_MASK);\n-                write_reg((instance_p.config.base_address + FXMAC_TXSR_OFFSET) as *mut u32, (FXMAC_TXSR_TXCOMPL_MASK | FXMAC_TXSR_USEDREAD_MASK) as u32);\n+            /* Transmit error conditions interrupt */\n+            if ((reg_isr & FXMAC_IXR_TX_ERR_MASK) != 0) && ((reg_isr & FXMAC_IXR_TXCOMPL_MASK) == 0)\n+            {\n+                /* Clear TX status register */\n+                let reg_txsr: u32 =\n+                    read_reg((instance_p.config.base_address + FXMAC_TXSR_OFFSET) as *const u32);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 183 to 183)\n+                write_reg(\n+                    (instance_p.config.base_address + FXMAC_TXSR_OFFSET) as *mut u32,\n+                    reg_txsr,\n+                );\n+\n+                FXmacErrorHandler(instance_p, FXMAC_SEND as u8, reg_txsr);\n+\n+                /* add */\n+                if (instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0 {\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32,\n+                        FXMAC_IXR_TX_ERR_MASK,\n+                    );\n+                }\n+            }\n+\n+            /* add restart */\n+            if (reg_isr & FXMAC_IXR_TXUSED_MASK) != 0 {\n+                /* add */\n+                if (instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0 {\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32,\n+                        FXMAC_IXR_TXUSED_MASK,\n+                    );\n+                }\n+\n+                /*\n+                if (instance_p->restart_handler)\n+                {\n+                    instance_p->restart_handler(instance_p->restart_args);\n+                }\n+                */\n+            }\n+\n+            /* link changed */\n+            if (reg_isr & FXMAC_IXR_LINKCHANGE_MASK) != 0 {\n+                FXmacLinkChange(instance_p);\n+\n+                if (instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0 {\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32,\n+                        FXMAC_IXR_LINKCHANGE_MASK,\n+                    );\n+                }\n+            }\n+        } else\n+        /* use queue number more than 0 */\n+        {\n+            reg_isr = read_reg(\n+                (instance_p.config.base_address\n+                    + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, tx_queue_id))\n+                    as *const u32,\n+            );\n+\n+            /* Transmit Q1 complete interrupt */\n+            if ((reg_isr & FXMAC_INTQUESR_TXCOMPL_MASK) != 0) {\n+                /* Clear TX status register TX complete indication but preserve\n+                 * error bits if there is any */\n+                write_reg(\n+                    (instance_p.config.base_address\n+                        + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, tx_queue_id))\n+                        as *mut u32,\n+                    FXMAC_INTQUESR_TXCOMPL_MASK,\n+                );\n+                write_reg(\n+                    (instance_p.config.base_address + FXMAC_TXSR_OFFSET) as *mut u32,\n+                    (FXMAC_TXSR_TXCOMPL_MASK | FXMAC_TXSR_USEDREAD_MASK) as u32,\n+                );\n+\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 184 to 191)\n-             }\n- \n-             /* Transmit Q1 error conditions interrupt */\n-             if (((reg_isr & FXMAC_INTQ1SR_TXERR_MASK) != 0) &&\n-                 ((reg_isr & FXMAC_INTQ1SR_TXCOMPL_MASK) != 0))\n-             {\n-                 /* Clear Interrupt Q1 status register */\n-                 write_reg((instance_p.config.base_address + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, tx_queue_id)) as *mut u32, reg_isr);\n+            }\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 193 to 193)\n+            /* Transmit Q1 error conditions interrupt */\n+            if (((reg_isr & FXMAC_INTQ1SR_TXERR_MASK) != 0)\n+                && ((reg_isr & FXMAC_INTQ1SR_TXCOMPL_MASK) != 0))\n+            {\n+                /* Clear Interrupt Q1 status register */\n+                write_reg(\n+                    (instance_p.config.base_address\n+                        + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, tx_queue_id))\n+                        as *mut u32,\n+                    reg_isr,\n+                );\n+\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 194 to 207)\n-             }\n-         }\n-     }\n- \n-     if vector as u32 == instance_p.config.queue_irq_num[rx_queue_id as usize]\n-     {\n-         if rx_queue_id == 0\n-         {\n-             /* Receive complete interrupt */\n-             if (reg_isr & FXMAC_IXR_RXCOMPL_MASK) != 0\n-             {\n-                 /* Clear RX status register RX complete indication but preserve\n-                  * error bits if there is any */\n-                 write_reg((instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *mut u32, (FXMAC_RXSR_FRAMERX_MASK | FXMAC_RXSR_BUFFNA_MASK) as u32);\n+            }\n+        }\n+    }\n+\n+    if vector as u32 == instance_p.config.queue_irq_num[rx_queue_id as usize] {\n+        if rx_queue_id == 0 {\n+            /* Receive complete interrupt */\n+            if (reg_isr & FXMAC_IXR_RXCOMPL_MASK) != 0 {\n+                /* Clear RX status register RX complete indication but preserve\n+                 * error bits if there is any */\n+                write_reg(\n+                    (instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *mut u32,\n+                    (FXMAC_RXSR_FRAMERX_MASK | FXMAC_RXSR_BUFFNA_MASK) as u32,\n+                );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 209 to 221)\n- \n-                 /* add */\n-                 if(instance_p.caps& FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0\n-                 {\n-                     write_reg((instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32, FXMAC_IXR_RXCOMPL_MASK);\n-                 }\n-             }\n- \n-             /* Receive error conditions interrupt */\n-             if (reg_isr & FXMAC_IXR_RX_ERR_MASK) != 0 {\n-                 /* Clear RX status register */\n-                 let mut reg_rxsr: u32 = read_reg((instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *const u32);\n-                 write_reg((instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *mut u32, reg_rxsr);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 223 to 224)\n-                 if (reg_isr & FXMAC_IXR_RXUSED_MASK) != 0 {\n-                     let reg_ctrl: u32 = read_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32);\n+                /* add */\n+                if (instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0 {\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32,\n+                        FXMAC_IXR_RXCOMPL_MASK,\n+                    );\n+                }\n+            }\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 226 to 314)\n-                     let mut reg_temp: u32 = reg_ctrl | FXMAC_NWCTRL_FLUSH_DPRAM_MASK as u32;\n-                     reg_temp &= (!FXMAC_NWCTRL_RXEN_MASK) as u32;\n-                     write_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32, reg_temp);\n- \n-                     /* add  */\n-                     reg_temp = reg_ctrl | FXMAC_NWCTRL_RXEN_MASK as u32;\n-                     write_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32, reg_temp);\n-                                     \n-                     if(instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0\n-                     {\n-                         write_reg((instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32, FXMAC_IXR_RXUSED_MASK);\n-                     }\n-                 }\n- \n-                 /* add */\n-                 if ((reg_isr & FXMAC_IXR_RXOVR_MASK) != 0) && ((instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0) {\n-                         write_reg((instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32, FXMAC_IXR_RXOVR_MASK);\n-                 }\n- \n-                 /* add */\n-                 if ((reg_isr & FXMAC_IXR_HRESPNOK_MASK) != 0) && ((instance_p.caps& FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0) {\n-                         write_reg((instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32, FXMAC_IXR_HRESPNOK_MASK);\n-                 }\n- \n-                 if reg_rxsr != 0 {\n-                    FXmacErrorHandler(instance_p, FXMAC_RECV as u8, reg_rxsr);\n-                 }\n-             }\n-         } else { /* use queue number more than 0 */\n-             reg_isr = read_reg((instance_p.config.base_address + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, rx_queue_id)) as *const u32);\n- \n-             /* Receive complete interrupt */\n-             if ((reg_isr & FXMAC_INTQUESR_RCOMP_MASK) != 0)\n-             {\n-                 /* Clear RX status register RX complete indication but preserve\n-                  * error bits if there is any */\n-                  write_reg((instance_p.config.base_address + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, rx_queue_id)) as *mut u32, FXMAC_INTQUESR_RCOMP_MASK);\n-                  FXmacRecvIsrHandler(instance_p);\n-             }\n- \n-             /* Receive error conditions interrupt */\n-             if (reg_isr & FXMAC_IXR_RX_ERR_MASK) != 0\n-             {\n- \n-                 let mut reg_ctrl: u32 = read_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32);\n-                 reg_ctrl &= !(FXMAC_NWCTRL_RXEN_MASK as u32);\n- \n-                 write_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32, reg_ctrl);\n- \n-                 /* Clear RX status register */\n-                 let mut reg_rxsr = read_reg((instance_p.config.base_address + FXMAC_RXSR_OFFSET)as *const u32);\n-                 write_reg((instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *mut u32, reg_rxsr);\n- \n-                 if ((reg_isr & FXMAC_IXR_RXUSED_MASK) != 0)\n-                 {\n-                     reg_ctrl = read_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32);\n-                     reg_ctrl |= FXMAC_NWCTRL_FLUSH_DPRAM_MASK;\n- \n-                     write_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32, reg_ctrl);\n-                 }\n- \n-                 /* Clear RX status register RX complete indication but preserve\n-                  * error bits if there is any */\n-                  write_reg((instance_p.config.base_address + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, rx_queue_id)) as *mut u32, FXMAC_INTQUESR_RXUBR_MASK);\n-                  FXmacRecvIsrHandler(instance_p);\n- \n-                 if reg_rxsr != 0\n-                 {\n-                    FXmacErrorHandler(instance_p, FXMAC_RECV as u8, reg_rxsr);\n-                 }\n-             }\n-         }\n-     }\n- }\n- \n- /**\n-  * @name: FXmacQueueIrqDisable\n-  * @msg:  Disable queue irq\n-  * @param {FXmac} *instance_p a pointer to the instance to be worked on.\n-  * @param {u32} queue_num queue number\n-  * @param {u32} mask is interrupt disable value mask\n-  */\n- pub fn FXmacQueueIrqDisable(instance_p: &mut FXmac, queue_num: u32, mask: u32)\n- {\n-     assert!(instance_p.is_ready == FT_COMPONENT_IS_READY as u32);\n-     assert!(instance_p.config.max_queue_num > queue_num);\n- \n-     if queue_num == 0 {\n-    write_reg((instance_p.config.base_address + FXMAC_IDR_OFFSET) as *mut u32, mask & FXMAC_IXR_ALL_MASK);\n+            /* Receive error conditions interrupt */\n+            if (reg_isr & FXMAC_IXR_RX_ERR_MASK) != 0 {\n+                /* Clear RX status register */\n+                let mut reg_rxsr: u32 =\n+                    read_reg((instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *const u32);\n+                write_reg(\n+                    (instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *mut u32,\n+                    reg_rxsr,\n+                );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 316 to 317)\n-     } else {\n-    write_reg((instance_p.config.base_address + FXMAC_INTQX_IDR_SIZE_OFFSET(queue_num as u64)) as *mut u32, mask & FXMAC_IXR_ALL_MASK);\n+                if (reg_isr & FXMAC_IXR_RXUSED_MASK) != 0 {\n+                    let reg_ctrl: u32 = read_reg(\n+                        (instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32,\n+                    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 319 to 329)\n-     }\n- }\n- \n- /// FXmacQueueIrqEnable, Enable queue irq\n- pub fn FXmacQueueIrqEnable(instance_p: &mut FXmac, queue_num: u32, mask: u32)\n- {\n-     assert!(instance_p.is_ready == FT_COMPONENT_IS_READY as u32);\n-     assert!(instance_p.config.max_queue_num > queue_num);\n- \n-     if queue_num == 0 {\n-    write_reg((instance_p.config.base_address + FXMAC_IER_OFFSET) as *mut u32, mask & FXMAC_IXR_ALL_MASK);\n+                    let mut reg_temp: u32 = reg_ctrl | FXMAC_NWCTRL_FLUSH_DPRAM_MASK as u32;\n+                    reg_temp &= (!FXMAC_NWCTRL_RXEN_MASK) as u32;\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32,\n+                        reg_temp,\n+                    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 331 to 332)\n-     } else {\n-    write_reg((instance_p.config.base_address + FXMAC_INTQX_IER_SIZE_OFFSET(queue_num as u64)) as *mut u32, mask & FXMAC_IXR_ALL_MASK);\n+                    /* add  */\n+                    reg_temp = reg_ctrl | FXMAC_NWCTRL_RXEN_MASK as u32;\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32,\n+                        reg_temp,\n+                    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 334 to 348)\n-     }\n- }\n- \n-pub fn FXmacErrorHandler(instance_p: &mut FXmac, direction: u8, error_word: u32)\n-{\n-    debug!(\"-> FXmacErrorHandler, direction={}, error_word={}\", direction, error_word);\n-    if error_word != 0\n-    {\n-        match direction as u32\n-        {\n-         FXMAC_RECV => {\n-            if (error_word & FXMAC_RXSR_HRESPNOK_MASK) != 0\n-            {\n-                error!(\"Receive DMA error\");\n-                FXmacHandleDmaTxError(instance_p);\n+                    if (instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0 {\n+                        write_reg(\n+                            (instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32,\n+                            FXMAC_IXR_RXUSED_MASK,\n+                        );\n+                    }\n+                }\n+\n+                /* add */\n+                if ((reg_isr & FXMAC_IXR_RXOVR_MASK) != 0)\n+                    && ((instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0)\n+                {\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32,\n+                        FXMAC_IXR_RXOVR_MASK,\n+                    );\n+                }\n+\n+                /* add */\n+                if ((reg_isr & FXMAC_IXR_HRESPNOK_MASK) != 0)\n+                    && ((instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0)\n+                {\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32,\n+                        FXMAC_IXR_HRESPNOK_MASK,\n+                    );\n+                }\n+\n+                if reg_rxsr != 0 {\n+                    FXmacErrorHandler(instance_p, FXMAC_RECV as u8, reg_rxsr);\n+                }\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 350 to 353)\n-            if (error_word & FXMAC_RXSR_RXOVR_MASK) != 0\n-            {\n-                error!(\"Receive over run\");\n-                //FXmacRecvHandler(instance_p);\n+        } else {\n+            /* use queue number more than 0 */\n+            reg_isr = read_reg(\n+                (instance_p.config.base_address\n+                    + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, rx_queue_id))\n+                    as *const u32,\n+            );\n+\n+            /* Receive complete interrupt */\n+            if ((reg_isr & FXMAC_INTQUESR_RCOMP_MASK) != 0) {\n+                /* Clear RX status register RX complete indication but preserve\n+                 * error bits if there is any */\n+                write_reg(\n+                    (instance_p.config.base_address\n+                        + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, rx_queue_id))\n+                        as *mut u32,\n+                    FXMAC_INTQUESR_RCOMP_MASK,\n+                );\n+                FXmacRecvIsrHandler(instance_p);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 355 to 358)\n-            if (error_word & FXMAC_RXSR_BUFFNA_MASK) != 0\n-            {\n-                error!(\"Receive buffer not available\");\n-                //FXmacRecvHandler(instance_p);\n+\n+            /* Receive error conditions interrupt */\n+            if (reg_isr & FXMAC_IXR_RX_ERR_MASK) != 0 {\n+                let mut reg_ctrl: u32 =\n+                    read_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32);\n+                reg_ctrl &= !(FXMAC_NWCTRL_RXEN_MASK as u32);\n+\n+                write_reg(\n+                    (instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32,\n+                    reg_ctrl,\n+                );\n+\n+                /* Clear RX status register */\n+                let mut reg_rxsr =\n+                    read_reg((instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *const u32);\n+                write_reg(\n+                    (instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *mut u32,\n+                    reg_rxsr,\n+                );\n+\n+                if ((reg_isr & FXMAC_IXR_RXUSED_MASK) != 0) {\n+                    reg_ctrl = read_reg(\n+                        (instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32,\n+                    );\n+                    reg_ctrl |= FXMAC_NWCTRL_FLUSH_DPRAM_MASK;\n+\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32,\n+                        reg_ctrl,\n+                    );\n+                }\n+\n+                /* Clear RX status register RX complete indication but preserve\n+                 * error bits if there is any */\n+                write_reg(\n+                    (instance_p.config.base_address\n+                        + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, rx_queue_id))\n+                        as *mut u32,\n+                    FXMAC_INTQUESR_RXUBR_MASK,\n+                );\n+                FXmacRecvIsrHandler(instance_p);\n+\n+                if reg_rxsr != 0 {\n+                    FXmacErrorHandler(instance_p, FXMAC_RECV as u8, reg_rxsr);\n+                }\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 361 to 365)\n-         FXMAC_SEND => {\n-            if (error_word & FXMAC_TXSR_HRESPNOK_MASK) != 0\n-            {\n-                error!(\"Transmit DMA error\");\n-                FXmacHandleDmaTxError(instance_p);\n+    }\n+}\n+\n+/**\n+ * @name: FXmacQueueIrqDisable\n+ * @msg:  Disable queue irq\n+ * @param {FXmac} *instance_p a pointer to the instance to be worked on.\n+ * @param {u32} queue_num queue number\n+ * @param {u32} mask is interrupt disable value mask\n+ */\n+pub fn FXmacQueueIrqDisable(instance_p: &mut FXmac, queue_num: u32, mask: u32) {\n+    assert!(instance_p.is_ready == FT_COMPONENT_IS_READY as u32);\n+    assert!(instance_p.config.max_queue_num > queue_num);\n+\n+    if queue_num == 0 {\n+        write_reg(\n+            (instance_p.config.base_address + FXMAC_IDR_OFFSET) as *mut u32,\n+            mask & FXMAC_IXR_ALL_MASK,\n+        );\n+    } else {\n+        write_reg(\n+            (instance_p.config.base_address + FXMAC_INTQX_IDR_SIZE_OFFSET(queue_num as u64))\n+                as *mut u32,\n+            mask & FXMAC_IXR_ALL_MASK,\n+        );\n+    }\n+}\n+\n+/// FXmacQueueIrqEnable, Enable queue irq\n+pub fn FXmacQueueIrqEnable(instance_p: &mut FXmac, queue_num: u32, mask: u32) {\n+    assert!(instance_p.is_ready == FT_COMPONENT_IS_READY as u32);\n+    assert!(instance_p.config.max_queue_num > queue_num);\n+\n+    if queue_num == 0 {\n+        write_reg(\n+            (instance_p.config.base_address + FXMAC_IER_OFFSET) as *mut u32,\n+            mask & FXMAC_IXR_ALL_MASK,\n+        );\n+    } else {\n+        write_reg(\n+            (instance_p.config.base_address + FXMAC_INTQX_IER_SIZE_OFFSET(queue_num as u64))\n+                as *mut u32,\n+            mask & FXMAC_IXR_ALL_MASK,\n+        );\n+    }\n+}\n+\n+pub fn FXmacErrorHandler(instance_p: &mut FXmac, direction: u8, error_word: u32) {\n+    debug!(\n+        \"-> FXmacErrorHandler, direction={}, error_word={}\",\n+        direction, error_word\n+    );\n+    if error_word != 0 {\n+        match direction as u32 {\n+            FXMAC_RECV => {\n+                if (error_word & FXMAC_RXSR_HRESPNOK_MASK) != 0 {\n+                    error!(\"Receive DMA error\");\n+                    FXmacHandleDmaTxError(instance_p);\n+                }\n+                if (error_word & FXMAC_RXSR_RXOVR_MASK) != 0 {\n+                    error!(\"Receive over run\");\n+                    //FXmacRecvHandler(instance_p);\n+                }\n+                if (error_word & FXMAC_RXSR_BUFFNA_MASK) != 0 {\n+                    error!(\"Receive buffer not available\");\n+                    //FXmacRecvHandler(instance_p);\n+                }\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 367 to 370)\n-            if (error_word & FXMAC_TXSR_URUN_MASK) != 0\n-            {\n-                error!(\"Transmit under run\");\n-                FXmacHandleTxErrors(instance_p);\n+            FXMAC_SEND => {\n+                if (error_word & FXMAC_TXSR_HRESPNOK_MASK) != 0 {\n+                    error!(\"Transmit DMA error\");\n+                    FXmacHandleDmaTxError(instance_p);\n+                }\n+                if (error_word & FXMAC_TXSR_URUN_MASK) != 0 {\n+                    error!(\"Transmit under run\");\n+                    FXmacHandleTxErrors(instance_p);\n+                }\n+                if (error_word & FXMAC_TXSR_BUFEXH_MASK) != 0 {\n+                    error!(\"Transmit buffer exhausted\");\n+                    FXmacHandleTxErrors(instance_p);\n+                }\n+                if (error_word & FXMAC_TXSR_RXOVR_MASK) != 0 {\n+                    error!(\"Transmit retry excessed limits\");\n+                    FXmacHandleTxErrors(instance_p);\n+                }\n+                if (error_word & FXMAC_TXSR_FRAMERX_MASK) != 0 {\n+                    error!(\"Transmit collision\");\n+                    FXmacProcessSentBds(instance_p);\n+                }\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 372 to 375)\n-            if (error_word & FXMAC_TXSR_BUFEXH_MASK) != 0\n-            {\n-                error!(\"Transmit buffer exhausted\");\n-                FXmacHandleTxErrors(instance_p);\n+            _ => {\n+                error!(\"FXmacErrorHandler failed, unknown direction={}\", direction);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 377 to 386)\n-            if (error_word & FXMAC_TXSR_RXOVR_MASK) != 0\n-            {\n-                error!(\"Transmit retry excessed limits\");\n-                FXmacHandleTxErrors(instance_p);\n-            }\n-            if (error_word & FXMAC_TXSR_FRAMERX_MASK) != 0\n-            {\n-                error!(\"Transmit collision\");\n-                FXmacProcessSentBds(instance_p);\n-            }\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 388 to 389)\n-         _ => { error!(\"FXmacErrorHandler failed, unknown direction={}\", direction); }\n-        }\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 396 to 396)\n-    write_reg((instance.config.base_address + FXMAC_IDR_OFFSET) as *mut u32, FXMAC_IXR_RXCOMPL_MASK);\n+    write_reg(\n+        (instance.config.base_address + FXMAC_IDR_OFFSET) as *mut u32,\n+        FXMAC_IXR_RXCOMPL_MASK,\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 403 to 405)\n- /// 网卡中断设置\n-pub fn FXmacSetupIsr(instance: &mut FXmac)\n-{\n+/// 网卡中断设置\n+pub fn FXmacSetupIsr(instance: &mut FXmac) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 428 to 429)\n-    crate_interface::call_interface!(crate::KernelFunc::dma_request_irq(irq_num, xmac_intr_handler));\n-\n+    crate_interface::call_interface!(crate::KernelFunc::dma_request_irq(\n+        irq_num,\n+        xmac_intr_handler\n+    ));\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_intr.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 431 to 431)\n+\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 1 to 1)\n-use crate::fxmac_const::*;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 3 to 3)\n+use crate::fxmac_const::*;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 26 to 26)\n-pub const PHY_STAT_LINK_STATUS: u16 =              0x0004;\n+pub const PHY_STAT_LINK_STATUS: u16 = 0x0004;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 32 to 38)\n-pub const PHY_AUTOADVERTISE_10HALF: u16 = 0x0020;        /* Try for 10mbps half-duplex  */\n-pub const PHY_AUTOADVERTISE_1000XFULL: u16 = 0x0020;     /* Try for 1000BASE-X full-duplex */\n-pub const PHY_AUTOADVERTISE_10FULL: u16 = 0x0040;        /* Try for 10mbps full-duplex  */\n-pub const PHY_AUTOADVERTISE_1000XHALF: u16 = 0x0040;     /* Try for 1000BASE-X half-duplex */\n-pub const PHY_AUTOADVERTISE_100HALF: u16 = 0x0080;       /* Try for 100mbps half-duplex */\n-pub const PHY_AUTOADVERTISE_1000XPAUSE: u16 = 0x0080;    /* Try for 1000BASE-X pause    */\n-pub const PHY_AUTOADVERTISE_100FULL: u16 = 0x0100;       /* Try for 100mbps full-duplex */\n+pub const PHY_AUTOADVERTISE_10HALF: u16 = 0x0020; /* Try for 10mbps half-duplex  */\n+pub const PHY_AUTOADVERTISE_1000XFULL: u16 = 0x0020; /* Try for 1000BASE-X full-duplex */\n+pub const PHY_AUTOADVERTISE_10FULL: u16 = 0x0040; /* Try for 10mbps full-duplex  */\n+pub const PHY_AUTOADVERTISE_1000XHALF: u16 = 0x0040; /* Try for 1000BASE-X half-duplex */\n+pub const PHY_AUTOADVERTISE_100HALF: u16 = 0x0080; /* Try for 100mbps half-duplex */\n+pub const PHY_AUTOADVERTISE_1000XPAUSE: u16 = 0x0080; /* Try for 1000BASE-X pause    */\n+pub const PHY_AUTOADVERTISE_100FULL: u16 = 0x0100; /* Try for 100mbps full-duplex */\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 40 to 41)\n-pub const PHY_AUTOADVERTISE_100BASE4: u16 = 0x0200;      /* Try for 100mbps 4k packets  */\n-pub const PHY_AUTOADVERTISE_100_AND_10: u16 = (PHY_AUTOADVERTISE_10FULL | PHY_AUTOADVERTISE_100FULL | PHY_AUTOADVERTISE_10HALF | PHY_AUTOADVERTISE_100HALF);\n+pub const PHY_AUTOADVERTISE_100BASE4: u16 = 0x0200; /* Try for 100mbps 4k packets  */\n+pub const PHY_AUTOADVERTISE_100_AND_10: u16 = (PHY_AUTOADVERTISE_10FULL\n+    | PHY_AUTOADVERTISE_100FULL\n+    | PHY_AUTOADVERTISE_10HALF\n+    | PHY_AUTOADVERTISE_100HALF);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 56 to 56)\n-pub const FXMAC_PHY_MAX_NUM:u32 = 32;\n+pub const FXMAC_PHY_MAX_NUM: u32 = 32;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 69 to 70)\n-pub fn FXmacPhyWrite(instance_p: &mut FXmac, phy_address: u32, register_num: u32, phy_data: u16) -> u32\n-{\n+pub fn FXmacPhyWrite(\n+    instance_p: &mut FXmac,\n+    phy_address: u32,\n+    register_num: u32,\n+    phy_data: u16,\n+) -> u32 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 76 to 76)\n-    debug!(\"FXmacPhyWrite, phy_address={:#x}, register_num={}, phy_data={:#x}\", phy_address, register_num, phy_data);\n+    debug!(\n+        \"FXmacPhyWrite, phy_address={:#x}, register_num={}, phy_data={:#x}\",\n+        phy_address, register_num, phy_data\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 79 to 81)\n-    if (read_reg((instance_p.config.base_address + FXMAC_NWSR_OFFSET) as *const u32) &\n-           FXMAC_NWSR_MDIOIDLE_MASK) == 0\n-    {   \n+    if (read_reg((instance_p.config.base_address + FXMAC_NWSR_OFFSET) as *const u32)\n+        & FXMAC_NWSR_MDIOIDLE_MASK)\n+        == 0\n+    {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 84 to 84)\n-    }else{   \n+    } else {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 86 to 88)\n-        mgtcr = FXMAC_PHYMNTNC_OP_MASK | FXMAC_PHYMNTNC_OP_W_MASK |\n-                (phy_address << FXMAC_PHYMNTNC_PHAD_SHFT_MSK) |\n-                (register_num << FXMAC_PHYMNTNC_PREG_SHFT_MSK) | phy_data as u32;\n+        mgtcr = FXMAC_PHYMNTNC_OP_MASK\n+            | FXMAC_PHYMNTNC_OP_W_MASK\n+            | (phy_address << FXMAC_PHYMNTNC_PHAD_SHFT_MSK)\n+            | (register_num << FXMAC_PHYMNTNC_PREG_SHFT_MSK)\n+            | phy_data as u32;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 91 to 91)\n-        write_reg((instance_p.config.base_address + FXMAC_PHYMNTNC_OFFSET) as *mut u32, mgtcr);\n+        write_reg(\n+            (instance_p.config.base_address + FXMAC_PHYMNTNC_OFFSET) as *mut u32,\n+            mgtcr,\n+        );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 93 to 93)\n-        loop{\n+        loop {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 108 to 109)\n-pub fn FXmacPhyRead(instance_p: &mut FXmac, phy_address: u32, register_num: u32, phydat_aptr: &mut u16) -> u32\n-{\n+pub fn FXmacPhyRead(\n+    instance_p: &mut FXmac,\n+    phy_address: u32,\n+    register_num: u32,\n+    phydat_aptr: &mut u16,\n+) -> u32 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 116 to 117)\n-    if (read_reg((instance_p.config.base_address + FXMAC_NWSR_OFFSET) as *const u32) & FXMAC_NWSR_MDIOIDLE_MASK) == 0\n-    {   \n+    if (read_reg((instance_p.config.base_address + FXMAC_NWSR_OFFSET) as *const u32)\n+        & FXMAC_NWSR_MDIOIDLE_MASK)\n+        == 0\n+    {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 120 to 120)\n-    }else{   \n+    } else {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 122 to 124)\n-        mgtcr = FXMAC_PHYMNTNC_OP_MASK | FXMAC_PHYMNTNC_OP_R_MASK |\n-        (phy_address << FXMAC_PHYMNTNC_PHAD_SHFT_MSK) |\n-        (register_num << FXMAC_PHYMNTNC_PREG_SHFT_MSK);\n+        mgtcr = FXMAC_PHYMNTNC_OP_MASK\n+            | FXMAC_PHYMNTNC_OP_R_MASK\n+            | (phy_address << FXMAC_PHYMNTNC_PHAD_SHFT_MSK)\n+            | (register_num << FXMAC_PHYMNTNC_PREG_SHFT_MSK);\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 127 to 127)\n-        write_reg((instance_p.config.base_address + FXMAC_PHYMNTNC_OFFSET) as *mut u32, mgtcr);\n+        write_reg(\n+            (instance_p.config.base_address + FXMAC_PHYMNTNC_OFFSET) as *mut u32,\n+            mgtcr,\n+        );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 129 to 129)\n-        loop{\n+        loop {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 139 to 139)\n-        *phydat_aptr = read_reg((instance_p.config.base_address + FXMAC_PHYMNTNC_OFFSET) as *const u32) as u16;\n+        *phydat_aptr =\n+            read_reg((instance_p.config.base_address + FXMAC_PHYMNTNC_OFFSET) as *const u32) as u16;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 141 to 141)\n-    debug!(\"FXmacPhyRead, phy_address={:#x}, register_num={}, phydat_aptr={:#x}\", phy_address, register_num, phydat_aptr);\n+        debug!(\n+            \"FXmacPhyRead, phy_address={:#x}, register_num={}, phydat_aptr={:#x}\",\n+            phy_address, register_num, phydat_aptr\n+        );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 145 to 145)\n-    \n+\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 149 to 149)\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 152 to 155)\n-pub fn FXmacPhyInit(\n-    instance_p: &mut FXmac,\n-    reset_flag: u32,\n-) -> u32 {\n+pub fn FXmacPhyInit(instance_p: &mut FXmac, reset_flag: u32) -> u32 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 159 to 163)\n-    info!(\"FXmacPhyInit, speed={}, duplex_mode={}, autonegotiation_en={}, reset_flag={}\",\n-    speed,\n-        duplex_mode,\n-        autonegotiation_en,\n-        reset_flag\n+    info!(\n+        \"FXmacPhyInit, speed={}, duplex_mode={}, autonegotiation_en={}, reset_flag={}\",\n+        speed, duplex_mode, autonegotiation_en, reset_flag\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 183 to 183)\n-    assert!(speed != FXMAC_SPEED_1000, \"The speed must be 100M or 10M!\");\n+        assert!(speed != FXMAC_SPEED_1000, \"The speed must be 100M or 10M!\");\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 196 to 197)\n-pub fn FXmacDetect(instance_p: &mut FXmac, phy_addr_p: &mut u32) -> u32\n-{\n+pub fn FXmacDetect(instance_p: &mut FXmac, phy_addr_p: &mut u32) -> u32 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 203 to 204)\n-    for phy_addr in 0..FXMAC_PHY_MAX_NUM\n-    {   \n+    for phy_addr in 0..FXMAC_PHY_MAX_NUM {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 206 to 207)\n-        if (ret != FT_SUCCESS)\n-        {\n+        if (ret != FT_SUCCESS) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 213 to 214)\n-        if (phy_reg != 0xffff)\n-        {\n+        if (phy_reg != 0xffff) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 217 to 217)\n-            info!(\"Phy id1 reg is {:#x}, Phy id2 reg is {:#x}\", phy_id1_reg , phy_id2_reg);\n+            info!(\n+                \"Phy id1 reg is {:#x}, Phy id2 reg is {:#x}\",\n+                phy_id1_reg, phy_id2_reg\n+            );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 219 to 219)\n-            if ((ret == FT_SUCCESS) && (phy_id2_reg != 0) && (phy_id2_reg != 0xffff) && (phy_id1_reg != 0xffff))\n+            if ((ret == FT_SUCCESS)\n+                && (phy_id2_reg != 0)\n+                && (phy_id2_reg != 0xffff)\n+                && (phy_id1_reg != 0xffff))\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 233 to 234)\n-pub fn FXmacPhyReset(instance_p: &mut FXmac, phy_addr: u32) -> u32\n- {\n+pub fn FXmacPhyReset(instance_p: &mut FXmac, phy_addr: u32) -> u32 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 236 to 261)\n- \n-     let mut ret: u32 = FXmacPhyRead(instance_p, phy_addr, PHY_CONTROL_REG_OFFSET, &mut control);\n-     if (ret != FT_SUCCESS)\n-     {\n-         error!(\"FXmacPhyReset, read PHY_CONTROL_REG_OFFSET is error\");\n-         return ret;\n-     }\n- \n-     control |= PHY_CONTROL_RESET_MASK;\n- \n-     ret = FXmacPhyWrite(instance_p, phy_addr, PHY_CONTROL_REG_OFFSET, control);\n-     if (ret != FT_SUCCESS)\n-     {\n-         error!(\"FXmacPhyReset, write PHY_CONTROL_REG_OFFSET is error\");\n-         return ret;\n-     }\n- \n-     loop\n-     {\n-         ret = FXmacPhyRead(instance_p, phy_addr, PHY_CONTROL_REG_OFFSET, &mut control);\n-         if (ret != FT_SUCCESS)\n-         {\n-             error!(\"FXmacPhyReset, read PHY_CONTROL_REG_OFFSET is error\");\n-             return ret;\n-         }\n-         if (control & PHY_CONTROL_RESET_MASK) == 0 {\n+\n+    let mut ret: u32 = FXmacPhyRead(instance_p, phy_addr, PHY_CONTROL_REG_OFFSET, &mut control);\n+    if (ret != FT_SUCCESS) {\n+        error!(\"FXmacPhyReset, read PHY_CONTROL_REG_OFFSET is error\");\n+        return ret;\n+    }\n+\n+    control |= PHY_CONTROL_RESET_MASK;\n+\n+    ret = FXmacPhyWrite(instance_p, phy_addr, PHY_CONTROL_REG_OFFSET, control);\n+    if (ret != FT_SUCCESS) {\n+        error!(\"FXmacPhyReset, write PHY_CONTROL_REG_OFFSET is error\");\n+        return ret;\n+    }\n+\n+    loop {\n+        ret = FXmacPhyRead(instance_p, phy_addr, PHY_CONTROL_REG_OFFSET, &mut control);\n+        if (ret != FT_SUCCESS) {\n+            error!(\"FXmacPhyReset, read PHY_CONTROL_REG_OFFSET is error\");\n+            return ret;\n+        }\n+        if (control & PHY_CONTROL_RESET_MASK) == 0 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 263 to 268)\n-         }\n-     }\n- \n-     info!(\"Phy reset end.\");\n-     ret\n- }\n+        }\n+    }\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 270 to 270)\n+    info!(\"Phy reset end.\");\n+    ret\n+}\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 271 to 272)\n-pub fn FXmacGetIeeePhySpeed(instance_p: &mut FXmac, phy_addr: u32) -> u32\n-{\n+pub fn FXmacGetIeeePhySpeed(instance_p: &mut FXmac, phy_addr: u32) -> u32 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 282 to 283)\n-    if (ret != FT_SUCCESS)\n-    {\n+    if (ret != FT_SUCCESS) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 291 to 292)\n-    if (ret != FT_SUCCESS)\n-    {\n+    if (ret != FT_SUCCESS) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 298 to 298)\n-    loop{\n+    loop {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 303 to 304)\n-        if (ret != FT_SUCCESS)\n-        {\n+        if (ret != FT_SUCCESS) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 309 to 309)\n-\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 311 to 312)\n-        if (negotitation_timeout_cnt >= 0xff)\n-        {\n+        if (negotitation_timeout_cnt >= 0xff) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 314 to 314)\n-            return 8;//FXMAC_PHY_AUTO_AUTONEGOTIATION_FAILED;\n+            return 8; //FXMAC_PHY_AUTO_AUTONEGOTIATION_FAILED;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 318 to 318)\n-            break\n+            break;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 321 to 321)\n-    \n+\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 325 to 326)\n-    if (ret != FT_SUCCESS)\n-    {\n+    if (ret != FT_SUCCESS) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 333 to 334)\n-    if (ret != FT_SUCCESS)\n-    {\n+    if (ret != FT_SUCCESS) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 341 to 342)\n-    if (temp & (1 << 13)) != 0\n-    {\n+    if (temp & (1 << 13)) != 0 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 345 to 347)\n-    }\n-    else\n-    {\n+    } else {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 352 to 353)\n-    if (temp & 0xC000) == PHY_SPECIFIC_STATUS_SPEED_1000M\n-    {\n+    if (temp & 0xC000) == PHY_SPECIFIC_STATUS_SPEED_1000M {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 356 to 358)\n-    }\n-    else if (temp & 0xC000) == PHY_SPECIFIC_STATUS_SPEED_100M\n-    {\n+    } else if (temp & 0xC000) == PHY_SPECIFIC_STATUS_SPEED_100M {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 361 to 363)\n-    }\n-    else\n-    {\n+    } else {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 371 to 374)\n-pub fn FXmacConfigureIeeePhySpeed(instance_p: &mut FXmac, phy_addr: u32, speed: u32, duplex_mode: u32) -> u32\n-{\n-    let mut control: u16 = 0;;\n-    let mut autonereg: u16 = 0;;\n+pub fn FXmacConfigureIeeePhySpeed(\n+    instance_p: &mut FXmac,\n+    phy_addr: u32,\n+    speed: u32,\n+    duplex_mode: u32,\n+) -> u32 {\n+    let mut control: u16 = 0;\n+    let mut autonereg: u16 = 0;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 377 to 377)\n-    info!(\"Manual setting, phy_addr is {:#x},speed {}, duplex_mode is {}.\", phy_addr, speed, duplex_mode);\n+    info!(\n+        \"Manual setting, phy_addr is {:#x},speed {}, duplex_mode is {}.\",\n+        phy_addr, speed, duplex_mode\n+    );\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 379 to 381)\n-    let mut ret: u32 = FXmacPhyRead(instance_p, phy_addr, PHY_AUTONEGO_ADVERTISE_REG, &mut autonereg);\n-    if (ret != FT_SUCCESS)\n-    {\n+    let mut ret: u32 = FXmacPhyRead(\n+        instance_p,\n+        phy_addr,\n+        PHY_AUTONEGO_ADVERTISE_REG,\n+        &mut autonereg,\n+    );\n+    if (ret != FT_SUCCESS) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 389 to 390)\n-    if (ret != FT_SUCCESS)\n-    {\n+    if (ret != FT_SUCCESS) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 396 to 397)\n-    if (ret != FT_SUCCESS)\n-    {\n+    if (ret != FT_SUCCESS) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 407 to 408)\n-    if speed == 100\n-    {\n+    if speed == 100 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 410 to 412)\n-    }\n-    else if speed == 10\n-    {\n+    } else if speed == 10 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 416 to 417)\n-    if duplex_mode == 1\n-    {\n+    if duplex_mode == 1 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 419 to 421)\n-    }\n-    else\n-    {\n+    } else {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 430 to 431)\n-    if (ret != FT_SUCCESS)\n-    {\n+    if (ret != FT_SUCCESS) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 441 to 443)\n-    ret = FXmacPhyRead(instance_p, phy_addr, PHY_SPECIFIC_STATUS_REG, &mut specific_reg);\n-    if (ret != FT_SUCCESS)\n-    {\n+    ret = FXmacPhyRead(\n+        instance_p,\n+        phy_addr,\n+        PHY_SPECIFIC_STATUS_REG,\n+        &mut specific_reg,\n+    );\n+    if (ret != FT_SUCCESS) {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 450 to 451)\n-    if (specific_reg & (1 << 13)) != 0\n-    {\n+    if (specific_reg & (1 << 13)) != 0 {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 454 to 456)\n-    }\n-    else\n-    {\n+    } else {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 461 to 462)\n-    if (specific_reg & 0xC000) == PHY_SPECIFIC_STATUS_SPEED_100M\n-    {\n+    if (specific_reg & 0xC000) == PHY_SPECIFIC_STATUS_SPEED_100M {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/fxmac_phy.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 465 to 467)\n-    }\n-    else\n-    {\n+    } else {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/lib.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/lib.rs (original lines from 37 to 38)\n-mod utils;\n-mod fxmac_phy;\n+mod fxmac;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/lib.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/lib.rs (original lines from 41 to 41)\n-mod fxmac;\n+mod fxmac_phy;\n+mod utils;\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/lib.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/lib.rs (original lines from 52 to 52)\n-pub trait KernelFunc{\n+pub trait KernelFunc {\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/lib.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/lib.rs (original lines from 72 to 73)\n-    fn it_works() {\n-    }\n+    fn it_works() {}\n"
    },
    {
      "cmd_idx": 0,
      "file": "src/utils.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/utils.rs (original lines from 258 to 258)\n+\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this `else { if .. }` block can be collapsed\n   --> src/fxmac.rs:632:12\n    |\n632 |       } else {\n    |  ____________^\n633 | |         if direction == FXMAC_SEND {\n634 | |             write_reg(\n635 | |                 (FXMAC_IOBASE\n...   |\n648 | |     }\n    | |_____^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\n    = note: `#[warn(clippy::collapsible_else_if)]` on by default\nhelp: collapse nested if block\n    |\n632 ~     } else if direction == FXMAC_SEND {\n633 +         write_reg(\n634 +             (FXMAC_IOBASE\n635 +                 + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_TXQ1BASE_OFFSET, queue_num as u64))\n636 +                 as *mut u32,\n637 +             ((queue_p & ULONG64_LO_MASK) | flag_queue_p) as u32,\n638 +         );\n639 +     } else {\n640 +         write_reg(\n641 +             (FXMAC_IOBASE\n642 +                 + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_RXQ1BASE_OFFSET, queue_num as u64))\n643 +                 as *mut u32,\n644 +             ((queue_p & ULONG64_LO_MASK) | flag_queue_p) as u32,\n645 +         );\n646 +     }\n    |\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_const.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting integer literal to `u64` is unnecessary\n   --> src/fxmac_const.rs:538:7\n    |\n538 |     (!(0 as u64) - (1 << l) + 1) &\n    |       ^^^^^^^^^^ help: try: `0_u64`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n    = note: `#[warn(clippy::unnecessary_cast)]` on by default\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_const.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting integer literal to `u64` is unnecessary\n   --> src/fxmac_const.rs:539:8\n    |\n539 |      (!(0 as u64) >> (BITS_PER_LONG - 1 - h))\n    |        ^^^^^^^^^^ help: try: `0_u64`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/utils.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n  --> src/utils.rs:27:67\n   |\n27 |                 error!(\"Failed to get PhytiumPi CPU Id from mpidr={:#x}\", mpidr);\n   |                                                                   ^^^^^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n   = note: `#[warn(clippy::literal_string_with_formatting_args)]` on by default\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/utils.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: manual implementation of an assign operation\n  --> src/utils.rs:97:9\n   |\n97 |         adr = adr & (!CACHE_LINE_ADDR_MASK);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `adr &= (!CACHE_LINE_ADDR_MASK)`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\n   = note: `#[warn(clippy::assign_op_pattern)]` on by default\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/utils.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: manual implementation of an assign operation\n   --> src/utils.rs:116:9\n    |\n116 |         adr = adr & (!CACHE_LINE_ADDR_MASK);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `adr &= (!CACHE_LINE_ADDR_MASK)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/utils.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u64` -> `u64`)\n   --> src/utils.rs:139:9\n    |\n139 |         CNTFRQ_EL0.get() as u64\n    |         ^^^^^^^^^^^^^^^^^^^^^^^ help: try: `CNTFRQ_EL0.get()`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/utils.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/utils.rs:202:39\n    |\n202 |     debug!(\"fxmac: virt_to_phys_fxmac {:#x}\", addr);\n    |                                       ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/utils.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/utils.rs:210:39\n    |\n210 |     debug!(\"fxmac: phys_to_virt_fxmac {:#x}\", addr);\n    |                                       ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/utils.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/utils.rs:232:37\n    |\n232 |     debug!(\"fxmac: dma alloc paddr: {:#x}, len={}\", paddr, len);\n    |                                     ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/utils.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/utils.rs:241:36\n    |\n241 |     debug!(\"fxmac: dma free vaddr: {:#x}, pages={}\", vaddr, pages);\n    |                                    ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_phy.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: these look like formatting arguments but are not part of a formatting macro\n  --> src/fxmac_phy.rs:76:40\n   |\n76 |     debug!(\"FXmacPhyWrite, phy_address={:#x}, register_num={}, phy_data={:#x}\", phy_address, register_num, phy_data);\n   |                                        ^^^^^                            ^^^^^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_phy.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: these look like formatting arguments but are not part of a formatting macro\n  --> src/fxmac_phy.rs:76:40\n   |\n76 |     debug!(\"FXmacPhyWrite, phy_address={:#x}, register_num={}, phy_data={:#x}\", phy_address, register_num, phy_data);\n   |                                        ^^^^^                            ^^^^^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_phy.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_phy.rs:141:39\n    |\n141 |     debug!(\"FXmacPhyRead, phy_address={:#x}, register_num={}, phydat_aptr={:#x}\", phy_address, register_num, phydat_aptr);\n    |                                       ^^^^^                               ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_phy.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_phy.rs:141:39\n    |\n141 |     debug!(\"FXmacPhyRead, phy_address={:#x}, register_num={}, phydat_aptr={:#x}\", phy_address, register_num, phydat_aptr);\n    |                                       ^^^^^                               ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_phy.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_phy.rs:211:34\n    |\n211 |         info!(\"Phy status reg is {:#x}\", phy_reg);\n    |                                  ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_phy.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_phy.rs:217:35\n    |\n217 |             info!(\"Phy id1 reg is {:#x}, Phy id2 reg is {:#x}\", phy_id1_reg , phy_id2_reg);\n    |                                   ^^^^^                 ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_phy.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_phy.rs:217:35\n    |\n217 |             info!(\"Phy id1 reg is {:#x}, Phy id2 reg is {:#x}\", phy_id1_reg , phy_id2_reg);\n    |                                   ^^^^^                 ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_phy.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_phy.rs:223:36\n    |\n223 |                 info!(\"Phy addr is {:#x}\", phy_addr);\n    |                                    ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_phy.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_phy.rs:331:20\n    |\n331 |     info!(\"Temp is {:#x}\", temp);\n    |                    ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_phy.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_phy.rs:339:21\n    |\n339 |     info!(\"Temp2 is {:#x}\", temp2);\n    |                     ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_phy.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_phy.rs:377:40\n    |\n377 |     info!(\"Manual setting, phy_addr is {:#x},speed {}, duplex_mode is {}.\", phy_addr, speed, duplex_mode);\n    |                                        ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_phy.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_phy.rs:401:38\n    |\n401 |     info!(\"PHY_CONTROL_REG_OFFSET is {:#x}.\", control);\n    |                                      ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_phy.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_phy.rs:448:28\n    |\n448 |     info!(\"Specific reg is {:#x}\", specific_reg);\n    |                            ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: manually reimplementing `div_ceil`\n   --> src/fxmac_dma.rs:160:27\n    |\n160 |         let alloc_pages = (FXMAX_RX_BDSPACE_LENGTH + (PAGE_SIZE - 1)) / PAGE_SIZE;\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.div_ceil()`: `FXMAX_RX_BDSPACE_LENGTH.div_ceil(PAGE_SIZE)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_div_ceil\n    = note: `#[warn(clippy::manual_div_ceil)]` on by default\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: manually reimplementing `div_ceil`\n   --> src/fxmac_dma.rs:163:27\n    |\n163 |         let alloc_pages = (FXMAX_TX_BDSPACE_LENGTH + (PAGE_SIZE - 1)) / PAGE_SIZE;\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.div_ceil()`: `FXMAX_TX_BDSPACE_LENGTH.div_ceil(PAGE_SIZE)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_div_ceil\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:188:30\n    |\n188 |     trace!(\"fxmac_bd_read at {:#x}\", bd_ptr + offset as u64);\n    |                              ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:193:28\n    |\n193 |     debug!(\"fxmac_bd_write {:#x} to {:#x}\", data, bd_ptr + offset as u64);\n    |                            ^^^^^    ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:193:28\n    |\n193 |     debug!(\"fxmac_bd_write {:#x} to {:#x}\", data, bd_ptr + offset as u64);\n    |                            ^^^^^    ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:205:27\n    |\n205 |    info!(\"RX WRAP of BD @ {:#x} set {:#x} | FXMAC_RXBUF_WRAP_MASK\", bdptr, data_value_rx);\n    |                           ^^^^^     ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:205:27\n    |\n205 |    info!(\"RX WRAP of BD @ {:#x} set {:#x} | FXMAC_RXBUF_WRAP_MASK\", bdptr, data_value_rx);\n    |                           ^^^^^     ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:220:27\n    |\n220 |    info!(\"TX WRAP of BD @ {:#x} set {:#x} | TXBUF_WRAP\", bdptr, data_value_tx);\n    |                           ^^^^^     ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:220:27\n    |\n220 |    info!(\"TX WRAP of BD @ {:#x} set {:#x} | TXBUF_WRAP\", bdptr, data_value_tx);\n    |                           ^^^^^     ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:261:41\n    |\n261 |     trace!(\"FXMAC_RING_SEEKAHEAD, bdptr={:#x}\", *bdptr as u64);\n    |                                         ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:274:46\n    |\n274 |         trace!(\"FXMAC_RING_SEEKAHEAD, bdptr: {:#x}, addr: {:#x}\", *bdptr as u64, addr);\n    |                                              ^^^^^        ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:274:46\n    |\n274 |         trace!(\"FXMAC_RING_SEEKAHEAD, bdptr: {:#x}, addr: {:#x}\", *bdptr as u64, addr);\n    |                                              ^^^^^        ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: manually reimplementing `div_ceil`\n   --> src/fxmac_dma.rs:291:37\n    |\n291 |         let alloc_rx_buffer_pages = (max_frame_size as usize + (PAGE_SIZE - 1)) / PAGE_SIZE;\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.div_ceil()`: `(max_frame_size as usize).div_ceil(PAGE_SIZE)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_div_ceil\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: manually reimplementing `div_ceil`\n   --> src/fxmac_dma.rs:348:31\n    |\n348 |             let alloc_pages = (max_fr_size as usize + (PAGE_SIZE - 1)) / PAGE_SIZE;\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.div_ceil()`: `(max_fr_size as usize).div_ceil(PAGE_SIZE)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_div_ceil\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`usize` -> `usize`)\n   --> src/fxmac_dma.rs:352:57\n    |\n352 |             instance_p.lwipport.buffer.tx_pbufs_storage[index as usize] = tx_mbufs_vaddr as u64;\n    |                                                         ^^^^^^^^^^^^^^ help: try: `index`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:381:37\n    |\n381 |     info!(\"FXmacInitDma, rxringptr: {:p}\", rxringptr);\n    |                                     ^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:382:37\n    |\n382 |     info!(\"FXmacInitDma, txringptr: {:p}\", txringptr);\n    |                                     ^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:383:38\n    |\n383 |     info!(\"FXmacInitDma, rx_bdspace: {:#x}\", &instance_p.lwipport.buffer.rx_bdspace);\n    |                                      ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:384:38\n    |\n384 |     info!(\"FXmacInitDma, tx_bdspace: {:#x}\", &instance_p.lwipport.buffer.tx_bdspace);\n    |                                      ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this operation has no effect\n   --> src/fxmac_dma.rs:427:87\n    |\n427 |         write_reg((instance_p.config.base_address + FXMAC_TAIL_QUEUE(0)) as *mut u32, (1<<31) | 0);\n    |                                                                                       ^^^^^^^^^^^ help: consider reducing it to: `((1<<31))`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#identity_op\n    = note: `#[warn(clippy::identity_op)]` on by default\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u64` -> `u64`)\n   --> src/fxmac_dma.rs:434:16\n    |\n434 |     ( (bdptr - ringptr.base_bd_addr as u64) / ringptr.separation as u64 ) as u32\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ringptr.base_bd_addr`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:483:59\n    |\n483 |     info!(\"FXmacBdRingCreate BDs count={}, separation={}, {:#x}~{:#x}\", bd_count, ring_ptr.separation, virt_addr, bd_virt_addr);\n    |                                                           ^^^^^ ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:483:59\n    |\n483 |     info!(\"FXmacBdRingCreate BDs count={}, separation={}, {:#x}~{:#x}\", bd_count, ring_ptr.separation, virt_addr, bd_virt_addr);\n    |                                                           ^^^^^ ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac_dma.rs:502:26\n    |\n502 |     ring_ptr.run_state = FXMAC_DMA_SG_IS_STOPED as u32;\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FXMAC_DMA_SG_IS_STOPED`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:520:53\n    |\n520 |         trace!(\"FXmacBdRingClone, copy current bd @ {:#x}\", cur_bd);\n    |                                                     ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:560:27\n    |\n560 |         debug!(\"free_head {:#x} seekahead to {:#x}\", b as usize, ring_ptr.free_head as usize);\n    |                           ^^^^^              ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:560:27\n    |\n560 |         debug!(\"free_head {:#x} seekahead to {:#x}\", b as usize, ring_ptr.free_head as usize);\n    |                           ^^^^^              ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:799:38\n    |\n799 |          warn!(\">>>>>>>>> TX PKT {} @{:#x} - {}\", pbufs_len, pbufs_virt, bdindex);\n    |                                      ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:801:27\n    |\n801 |         debug!(\">>>>>>>>> {:x?}\", pbuf);\n    |                           ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:867:26\n    |\n867 |     debug!(\"TX DMA DESC: {:#010x?}\", unsafe{*(txbdset as *const macb_dma_desc)});\n    |                          ^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:912:46\n    |\n912 |                 debug!(\"FXMAC_RXBUF_LEN_MASK={:#x}\", FXMAC_RXBUF_LEN_MASK);\n    |                                              ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:919:32\n    |\n919 |             debug!(\"RX PKT {} @{:#x} <<<<<<<<< - {}\", rx_bytes, pbufs_virt, bdindex);\n    |                                ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:922:27\n    |\n922 |             debug!(\"pbuf: {:x?}\", mbuf);\n    |                           ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:936:35\n    |\n936 |             debug!(\"hash_match is {:#x}\", hash_match);\n    |                                   ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: length comparison to zero\n   --> src/fxmac_dma.rs:961:8\n    |\n961 |     if recv_packets.len() > 0 {\n    |        ^^^^^^^^^^^^^^^^^^^^^^ help: using `!is_empty` is clearer and more explicit: `!recv_packets.is_empty()`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#len_zero\n    = note: `#[warn(clippy::len_zero)]` on by default\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: manually reimplementing `div_ceil`\n   --> src/fxmac_dma.rs:987:44\n    |\n987 |         let alloc_rx_buffer_pages: usize = (max_frame_size as usize + (PAGE_SIZE - 1)) / PAGE_SIZE;\n    |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.div_ceil()`: `(max_frame_size as usize).div_ceil(PAGE_SIZE)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_div_ceil\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n    --> src/fxmac_dma.rs:1000:34\n     |\n1000 |         trace!(\"SetupRxBds - {}: {:#010x?}\", bdindex, rx_macb_dma_desc);\n     |                                  ^^^^^^^^^\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: manual implementation of an assign operation\n    --> src/fxmac_dma.rs:1080:5\n     |\n1080 |     netctrlreg = netctrlreg & !FXMAC_NWCTRL_TXEN_MASK;\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `netctrlreg &= !FXMAC_NWCTRL_TXEN_MASK`\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: manual implementation of an assign operation\n    --> src/fxmac_dma.rs:1086:5\n     |\n1086 |     netctrlreg = netctrlreg | FXMAC_NWCTRL_TXEN_MASK;\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `netctrlreg |= FXMAC_NWCTRL_TXEN_MASK`\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: manually reimplementing `div_ceil`\n    --> src/fxmac_dma.rs:1114:25\n     |\n1114 |             let pages = (FXMAC_MAX_FRAME_SIZE as usize + (PAGE_SIZE - 1)) / PAGE_SIZE;\n     |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.div_ceil()`: `(FXMAC_MAX_FRAME_SIZE as usize).div_ceil(PAGE_SIZE)`\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_div_ceil\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n    --> src/fxmac_dma.rs:1140:47\n     |\n1140 |             trace!(\"FXmacProcessSentBds - {}: {:#010x?}\", bdindex, unsafe{*(curbdpntr as *const macb_dma_desc)});\n     |                                               ^^^^^^^^^\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_dma.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n    --> src/fxmac_dma.rs:1214:42\n     |\n1214 |             error!(\"link status is error {:#x}\", link);\n     |                                          ^^^^^\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_intr.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n  --> src/fxmac_intr.rs:87:37\n   |\n87 |      assert!(instance_p.is_ready == FT_COMPONENT_IS_READY as u32);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FT_COMPONENT_IS_READY`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_intr.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_intr.rs:103:63\n    |\n103 |      info!(\"+++++++++ IRQ num vector={}, Interrupt Status ISR={:#x}, tx_queue_id={}, rx_queue_id={}\", vector, reg_isr, tx_queue_id, rx_qu...\n    |                                                               ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_intr.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac_intr.rs:181:93\n    |\n181 | ...32, (FXMAC_TXSR_TXCOMPL_MASK | FXMAC_TXSR_USEDREAD_MASK) as u32);\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `(FXMAC_TXSR_TXCOMPL_MASK | FXMAC_TXSR_USEDREAD_MASK)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_intr.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac_intr.rs:207:94\n    |\n207 | ... u32, (FXMAC_RXSR_FRAMERX_MASK | FXMAC_RXSR_BUFFNA_MASK) as u32);\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `(FXMAC_RXSR_FRAMERX_MASK | FXMAC_RXSR_BUFFNA_MASK)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_intr.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac_intr.rs:226:57\n    |\n226 |                      let mut reg_temp: u32 = reg_ctrl | FXMAC_NWCTRL_FLUSH_DPRAM_MASK as u32;\n    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FXMAC_NWCTRL_FLUSH_DPRAM_MASK`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_intr.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac_intr.rs:227:34\n    |\n227 |                      reg_temp &= (!FXMAC_NWCTRL_RXEN_MASK) as u32;\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ (!FXMAC_NWCTRL_RXEN_MASK) }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_intr.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac_intr.rs:231:44\n    |\n231 |                      reg_temp = reg_ctrl | FXMAC_NWCTRL_RXEN_MASK as u32;\n    |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FXMAC_NWCTRL_RXEN_MASK`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_intr.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac_intr.rs:271:31\n    |\n271 |                  reg_ctrl &= !(FXMAC_NWCTRL_RXEN_MASK as u32);\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCTRL_RXEN_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_intr.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac_intr.rs:310:37\n    |\n310 |      assert!(instance_p.is_ready == FT_COMPONENT_IS_READY as u32);\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FT_COMPONENT_IS_READY`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac_intr.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac_intr.rs:325:37\n    |\n325 |      assert!(instance_p.is_ready == FT_COMPONENT_IS_READY as u32);\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FT_COMPONENT_IS_READY`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: manual implementation of an assign operation\n   --> src/fxmac.rs:244:5\n    |\n244 |     dmacrreg = dmacrreg | FXMAC_DMACR_INCR16_AHB_AXI_BURST; /* Attempt to use bursts of up to 16. */\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `dmacrreg |= FXMAC_DMACR_INCR16_AHB_AXI_BURST`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this expression creates a reference which is immediately dereferenced by the compiler\n   --> src/fxmac.rs:260:34\n    |\n260 |         FXmac_SetHash(&mut xmac, &hwaddr);\n    |                                  ^^^^^^^ help: change this to: `hwaddr`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrow\n    = note: `#[warn(clippy::needless_borrow)]` on by default\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:304:52\n    |\n304 |     if (instance_p.config.network_default_config & FXMAC_TRANSMITTER_ENABLE_OPTION as u32) != 0 {\n    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FXMAC_TRANSMITTER_ENABLE_OPTION`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:310:27\n    |\n310 |                 reg_val | FXMAC_NWCTRL_TXEN_MASK as u32,\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FXMAC_NWCTRL_TXEN_MASK`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac.rs:319:55\n    |\n319 |         info!(\"Enable receiver, FXMAC_NWCTRL_OFFSET = {:#x}\", reg_val);\n    |                                                       ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:323:27\n    |\n323 |                 reg_val | FXMAC_NWCTRL_RXEN_MASK as u32,\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FXMAC_NWCTRL_RXEN_MASK`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac.rs:328:32\n    |\n328 |         \"FXMAC_NWCTRL_OFFSET = {:#x}\",\n    |                                ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac.rs:332:37\n    |\n332 |     info!(\"Enable TX and RX by Mask={:#x}\", instance_p.mask);\n    |                                     ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:361:17\n    |\n361 |     reg_val &= !(FXMAC_NWCTRL_RXEN_MASK as u32);\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCTRL_RXEN_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:362:17\n    |\n362 |     reg_val &= !(FXMAC_NWCTRL_TXEN_MASK as u32);\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCTRL_TXEN_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:411:49\n    |\n411 |     let netctrl = (FXMAC_NWCTRL_STATCLR_MASK & !(FXMAC_NWCTRL_LOOPBACK_LOCAL_MASK as u32))\n    |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCTRL_LOOPBACK_LOCAL_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:464:12\n    |\n464 |         & !((FXMAC_TRANSMITTER_ENABLE_OPTION | FXMAC_RECEIVER_ENABLE_OPTION) as u32);\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ (FXMAC_TRANSMITTER_ENABLE_OPTION | FXMAC_RECEIVER_ENABLE_OPTION) }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u64` -> `u64`)\n   --> src/fxmac.rs:550:46\n    |\n550 |     let read_regs = read_reg((FXMAC_IOBASE + FXMAC_DESIGNCFG_DEBUG1_OFFSET as u64) as *const u32);\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FXMAC_DESIGNCFG_DEBUG1_OFFSET`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac.rs:673:33\n    |\n673 |             \"Design ConfigReg1: {:#x} Has FXMAC_CAPS_ISR_CLEAR_ON_WRITE feature\",\n    |                                 ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:773:32\n    |\n773 |             reg_new_netcfg &= !(FXMAC_NWCFG_BCASTDI_MASK as u32);\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_BCASTDI_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:926:33\n    |\n926 |             reg_new_net_cfg &= !(FXMAC_NWCFG_1536RXEN_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_1536RXEN_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:931:33\n    |\n931 |             reg_new_net_cfg &= !(FXMAC_NWCFG_NVLANDISC_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_NVLANDISC_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:936:33\n    |\n936 |             reg_new_net_cfg &= !(FXMAC_NWCFG_FCS_REMOVE_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_FCS_REMOVE_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:941:33\n    |\n941 |             reg_new_net_cfg &= !(FXMAC_NWCFG_LENGTH_FIELD_ERROR_FRAME_DISCARD_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_LENGTH_FIELD_ERROR_FRAME_DISCARD_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:946:33\n    |\n946 |             reg_new_net_cfg &= !(FXMAC_NWCFG_PAUSE_ENABLE_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_PAUSE_ENABLE_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:951:33\n    |\n951 |             reg_new_net_cfg &= !(FXMAC_NWCFG_COPYALLEN_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_COPYALLEN_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:961:33\n    |\n961 |             reg_new_net_cfg &= !(FXMAC_NWCFG_UCASTHASHEN_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_UCASTHASHEN_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:966:33\n    |\n966 |             reg_new_net_cfg &= !(FXMAC_NWCFG_MCASTHASHEN_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_MCASTHASHEN_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:975:33\n    |\n975 |             reg_new_net_cfg &= !(FXMAC_NWCFG_RXCHKSUMEN_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_RXCHKSUMEN_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:985:33\n    |\n985 |             reg_new_net_cfg &= !(FXMAC_NWCFG_JUMBO_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_JUMBO_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n    --> src/fxmac.rs:1025:18\n     |\n1025 |                 !((FXMAC_NWCFG_SGMII_MODE_ENABLE_MASK | FXMAC_NWCFG_PCSSEL_MASK) as u32);\n     |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ (FXMAC_NWCFG_SGMII_MODE_ENABLE_MASK | FXMAC_NWCFG_PCSSEL_MASK) }`\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n    --> src/fxmac.rs:1108:22\n     |\n1108 |     if is_started == FT_COMPONENT_IS_STARTED as u32 {\n     |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FT_COMPONENT_IS_STARTED`\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n    --> src/fxmac.rs:1180:22\n     |\n1180 |     debug!(\"Set MAC: {:x?} in hash table\", mac_address);\n     |                      ^^^^^\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n    --> src/fxmac.rs:1591:31\n     |\n1591 |     info!(\"FXMAC_GEM_HSMAC is {:#x}\", reg_value);\n     |                               ^^^^^\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n    --> src/fxmac.rs:1601:39\n     |\n1601 |         \"FXmacInitInterface, PHY MODE:{:?}\",\n     |                                       ^^^^\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 1,
      "file": "src/fxmac.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: this looks like a formatting argument but it is not part of a formatting macro\n    --> src/fxmac.rs:1618:33\n     |\n1618 |         info!(\"usx interface is {:?}\", instance_p.config.interface);\n     |                                 ^^^^\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
    },
    {
      "cmd_idx": 2,
      "file": "[semver checks]",
      "kind": "Semver Violation",
      "raw": "pkg=fxmac_rs, checker=SemverChecks\ntoolchain=nightly-2025-01-18, target=aarch64-unknown-none-softfloat\nfeatures=\npkg_dir=/home/runner/check/batch_30/elliott10/fxmac_rs\ncmd=cargo +nightly-2025-01-26-x86_64-unknown-linux-gnu semver-checks --target aarch64-unknown-none-softfloat \ntimestamp=2025-02-21 22:11:38.475987148 +08:00:00\n\n\nstdout:\n\nstderr:\n    Building fxmac_rs v0.2.0 (current)\nerror: running cargo-doc on crate 'fxmac_rs' failed with output:\n-----\nwarning: /home/runner/check/batch_30/elliott10/fxmac_rs/Cargo.toml: the cargo feature `edition2024` has been stabilized in the 1.85 release and is no longer necessary to be listed in the manifest\n  See https://doc.rust-lang.org/nightly/cargo/reference/manifest.html#the-edition-field for more information about using this feature.\n   Compiling proc-macro2 v1.0.93\n   Compiling unicode-ident v1.0.17\n    Checking tock-registers v0.9.0\n    Checking log v0.4.26\nerror[E0463]: can't find crate for `core`\n  |\n  = note: the `aarch64-unknown-none-softfloat` target may not be installed\n  = help: consider downloading the target with `rustup target add aarch64-unknown-none-softfloat`\n  = help: consider building the standard library from source with `cargo build -Zbuild-std`\n\nFor more information about this error, try `rustc --explain E0463`.\nerror: could not compile `tock-registers` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `log` (lib) due to 1 previous error\n\n-----\n\nerror: failed to build rustdoc for crate fxmac_rs v0.2.0\nnote: this is usually due to a compilation error in the crate,\n      and is unlikely to be a bug in cargo-semver-checks\nnote: the following command can be used to reproduce the compilation error:\n      cargo new --lib example &&\n          cd example &&\n          echo '[workspace]' >> Cargo.toml &&\n          cargo add --path /home/runner/check/batch_30/elliott10/fxmac_rs --features debug &&\n          cargo check\n\nerror: aborting due to failure to build rustdoc for crate fxmac_rs v0.2.0\n"
    },
    {
      "cmd_idx": 4,
      "file": "[rap] Not supported to display yet.",
      "kind": "Rapx",
      "raw": "pkg=fxmac_rs, checker=Rapx\ntoolchain=nightly-2025-01-18, target=aarch64-unknown-none-softfloat\nfeatures=\npkg_dir=/home/runner/check/batch_30/elliott10/fxmac_rs\ncmd=cargo +nightly-2024-10-12 rapx -F -M -- --target aarch64-unknown-none-softfloat \ntimestamp=2025-02-21 22:11:51.128970604 +08:00:00\n\nwarning: Memory Leak detected.\n   --> src/utils.rs:229:17\n    |\n217 | pub(crate) fn dma_alloc_coherent(pages: usize) -> (usize, usize) {\n218 |     let paddr: Box<[u32]> = if pages == 1 {\n219 |         Box::new([0; 1024]) // 4096\n220 |     } else if pages == 8 {\n221 |         Box::new([0; 1024 * 8]) // 4096\n222 |     } else {\n223 |         warn!(\"Alloc {} pages failed\", pages);\n224 |         Box::new([0; 1024])\n225 |     };\n226 |\n227 |     let len = paddr.len();\n228 |\n229 |     let paddr = Box::into_raw(paddr) as *const u32 as usize;\n    |                 -------------------- Memory Leak Candidates.\n230 |     //let vaddr = phys_to_virt(paddr);\n231 |     let vaddr = paddr;\n232 |     debug!(\"fxmac: dma alloc paddr: {:#x}, len={}\", paddr, len);\n233 |\n234 |     (vaddr, paddr)\n235 | }\n    |\nOver visited: DefId(0:659 ~ fxmac_rs[2976]::fxmac_intr::FXmacIntrHandler)\nOver visited: DefId(0:750 ~ fxmac_rs[2976]::fxmac::FXmacSetOptions)\nOver visited: DefId(0:751 ~ fxmac_rs[2976]::fxmac::FXmacClearOptions)\nOver visited: DefId(0:762 ~ fxmac_rs[2976]::fxmac::FXmacSelectClk)\nOver visited: DefId(0:765 ~ fxmac_rs[2976]::fxmac::FXmacInitInterface)\n"
    },
    {
      "cmd_idx": 5,
      "file": "[outdated direct dependencies]",
      "kind": "Outdated",
      "raw": "pkg=fxmac_rs, checker=Outdated\ntoolchain=nightly-2025-01-18, target=aarch64-unknown-none-softfloat\nfeatures=\npkg_dir=/home/runner/check/batch_30/elliott10/fxmac_rs\ncmd=cargo +nightly-2025-01-26-x86_64-unknown-linux-gnu outdated -R --exit-code=2\ntimestamp=2025-02-21 22:11:51.300412866 +08:00:00\n\nName  Project  Compat  Latest  Kind    Platform\n----  -------  ------  ------  ----    --------\nlog   0.4.22   0.4.26  0.4.26  Normal  ---\n"
    },
    {
      "cmd_idx": 6,
      "file": "(virtual) semver-checks",
      "kind": "Cargo",
      "raw": "// pkg_name=fxmac_rs, checker=SemverChecks\n// toolchain=nightly-2025-01-18, target=aarch64-unknown-none-softfloat\n// features=\n// pkg_dir=/home/runner/check/batch_30/elliott10/fxmac_rs\n// cmd=cargo +nightly-2025-01-26-x86_64-unknown-linux-gnu semver-checks --target aarch64-unknown-none-softfloat \n// timestamp=2025-02-21 22:11:37.989759378 +08:00:00\n    Building fxmac_rs v0.2.0 (current)\nerror: running cargo-doc on crate 'fxmac_rs' failed with output:\n-----\nwarning: /home/runner/check/batch_30/elliott10/fxmac_rs/Cargo.toml: the cargo feature `edition2024` has been stabilized in the 1.85 release and is no longer necessary to be listed in the manifest\n  See https://doc.rust-lang.org/nightly/cargo/reference/manifest.html#the-edition-field for more information about using this feature.\n   Compiling proc-macro2 v1.0.93\n   Compiling unicode-ident v1.0.17\n    Checking tock-registers v0.9.0\n    Checking log v0.4.26\nerror[E0463]: can't find crate for `core`\n  |\n  = note: the `aarch64-unknown-none-softfloat` target may not be installed\n  = help: consider downloading the target with `rustup target add aarch64-unknown-none-softfloat`\n  = help: consider building the standard library from source with `cargo build -Zbuild-std`\n\nFor more information about this error, try `rustc --explain E0463`.\nerror: could not compile `tock-registers` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\nerror: could not compile `log` (lib) due to 1 previous error\n\n-----\n\nerror: failed to build rustdoc for crate fxmac_rs v0.2.0\nnote: this is usually due to a compilation error in the crate,\n      and is unlikely to be a bug in cargo-semver-checks\nnote: the following command can be used to reproduce the compilation error:\n      cargo new --lib example &&\n          cd example &&\n          echo '[workspace]' >> Cargo.toml &&\n          cargo add --path /home/runner/check/batch_30/elliott10/fxmac_rs --features debug &&\n          cargo check\n\nerror: aborting due to failure to build rustdoc for crate fxmac_rs v0.2.0\n"
    },
    {
      "cmd_idx": 7,
      "file": "examples/src/boot/lang_items.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/lang_items.rs (original lines from 4 to 7)\n-fn panic(info: &PanicInfo) -> !{\n-\tprintln!(\"{}\", info);\n-\tcrate::boot::sbi::shutdown();\n-\tunreachable!()\n+fn panic(info: &PanicInfo) -> ! {\n+    println!(\"{}\", info);\n+    crate::boot::sbi::shutdown();\n+    unreachable!()\n"
    },
    {
      "cmd_idx": 7,
      "file": "examples/src/boot/lang_items.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/lang_items.rs (original lines from 11 to 12)\n-pub extern \"C\" fn abort() -> !{\n-\tpanic!(\"abort!\");\n+pub extern \"C\" fn abort() -> ! {\n+    panic!(\"abort!\");\n"
    },
    {
      "cmd_idx": 7,
      "file": "examples/src/boot/lang_items.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/lang_items.rs (original lines from 14 to 14)\n-\n"
    },
    {
      "cmd_idx": 7,
      "file": "examples/src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 3 to 4)\n-pub fn console_putchar(ch: usize){\n-\tsbi_call(SBI_CONSOLE_PUTCHAR, ch, 0, 0);\n+pub fn console_putchar(ch: usize) {\n+    sbi_call(SBI_CONSOLE_PUTCHAR, ch, 0, 0);\n"
    },
    {
      "cmd_idx": 7,
      "file": "examples/src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 8 to 8)\n-\treturn sbi_call(SBI_CONSOLE_GETCHAR, 0, 0, 0);\n+    return sbi_call(SBI_CONSOLE_GETCHAR, 0, 0, 0);\n"
    },
    {
      "cmd_idx": 7,
      "file": "examples/src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 11 to 23)\n-pub fn console_putchar_u8(ch: u8){\n-\tlet ret: isize;\n-\t//let arg0: char = ch as char;\n-\tlet arg0: u8 = ch;\n-\tlet arg1: usize = 0;\n-\tlet arg2: usize = 0;\n-\tlet which: usize = 1; //SBI_ECALL_CONSOLE_PUTCHAR\n-\tunsafe{\n-\t\tasm!(\"ecall\",\n-\t\t     lateout(\"x10\") ret,\n-\t\t     in(\"x10\") arg0, in(\"x11\") arg1, in(\"x12\") arg2, in(\"x17\") which\n-             );\n-\t}\n+pub fn console_putchar_u8(ch: u8) {\n+    let ret: isize;\n+    //let arg0: char = ch as char;\n+    let arg0: u8 = ch;\n+    let arg1: usize = 0;\n+    let arg2: usize = 0;\n+    let which: usize = 1; //SBI_ECALL_CONSOLE_PUTCHAR\n+    unsafe {\n+        asm!(\"ecall\",\n+        lateout(\"x10\") ret,\n+        in(\"x10\") arg0, in(\"x11\") arg1, in(\"x12\") arg2, in(\"x17\") which\n+        );\n+    }\n"
    },
    {
      "cmd_idx": 7,
      "file": "examples/src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 26 to 28)\n-fn sbi_call(which: usize, arg0: usize, arg1: usize, arg2: usize) -> isize{\n-\tlet ret: isize;\n-\tunsafe{\n+fn sbi_call(which: usize, arg0: usize, arg1: usize, arg2: usize) -> isize {\n+    let ret: isize;\n+    unsafe {\n"
    },
    {
      "cmd_idx": 7,
      "file": "examples/src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 30 to 34)\n-             lateout(\"x10\") ret,\n-             in(\"x10\") arg0, in(\"x11\") arg1, in(\"x12\") arg2, in(\"x17\") which\n-            );\n-\t}\n-\tret\n+         lateout(\"x10\") ret,\n+         in(\"x10\") arg0, in(\"x11\") arg1, in(\"x12\") arg2, in(\"x17\") which\n+        );\n+    }\n+    ret\n"
    },
    {
      "cmd_idx": 7,
      "file": "examples/src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 37 to 39)\n-pub fn set_timer(stime_value: u64){\n-\t#[cfg(target_pointer_width = \"32\")]\n-\tsbi_call(SBI_SET_TIMER, stime_value as usize, (stime_value >> 32), 0);\n+pub fn set_timer(stime_value: u64) {\n+    #[cfg(target_pointer_width = \"32\")]\n+    sbi_call(SBI_SET_TIMER, stime_value as usize, (stime_value >> 32), 0);\n"
    },
    {
      "cmd_idx": 7,
      "file": "examples/src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 41 to 42)\n-\t#[cfg(target_pointer_width = \"64\")]\n-\tsbi_call(SBI_SET_TIMER, stime_value as usize, 0, 0);\n+    #[cfg(target_pointer_width = \"64\")]\n+    sbi_call(SBI_SET_TIMER, stime_value as usize, 0, 0);\n"
    },
    {
      "cmd_idx": 7,
      "file": "examples/src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 44 to 45)\n-pub fn clear_ipi(){\n-\tsbi_call(SBI_CLEAR_IPI, 0, 0, 0);\n+pub fn clear_ipi() {\n+    sbi_call(SBI_CLEAR_IPI, 0, 0, 0);\n"
    },
    {
      "cmd_idx": 7,
      "file": "examples/src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 48 to 49)\n-pub fn send_ipi(sipi_value: usize){\n-\tsbi_call(SBI_SEND_IPI, sipi_value, 0, 0);\n+pub fn send_ipi(sipi_value: usize) {\n+    sbi_call(SBI_SEND_IPI, sipi_value, 0, 0);\n"
    },
    {
      "cmd_idx": 7,
      "file": "examples/src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 52 to 53)\n-pub fn set_s_insn(entry: usize){\n-\tsbi_call(SBI_SET_SINSN, entry, 0, 0);\n+pub fn set_s_insn(entry: usize) {\n+    sbi_call(SBI_SET_SINSN, entry, 0, 0);\n"
    },
    {
      "cmd_idx": 7,
      "file": "examples/src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 56 to 57)\n-pub fn shutdown(){\n-\tsbi_call(SBI_SHUTDOWN, 0, 0, 0);\n+pub fn shutdown() {\n+    sbi_call(SBI_SHUTDOWN, 0, 0, 0);\n"
    },
    {
      "cmd_idx": 7,
      "file": "examples/src/ext4fs.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/ext4fs.rs (original lines from 96 to 96)\n-\n"
    },
    {
      "cmd_idx": 7,
      "file": "examples/src/pci_impl.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/pci_impl.rs (original lines from 2 to 2)\n-use pci::{PortOps, CSpaceAccessMethod};\n+use pci::{CSpaceAccessMethod, PortOps};\n"
    },
    {
      "cmd_idx": 7,
      "file": "examples/src/pci_impl.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/pci_impl.rs (original lines from 9 to 9)\n-pub const PCI_COMMAND_INTX_DISABLE:u16 = 0x400;\n+pub const PCI_COMMAND_INTX_DISABLE: u16 = 0x400;\n"
    },
    {
      "cmd_idx": 7,
      "file": "src/lib.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/src/lib.rs (original lines from 5 to 5)\n-\n"
    },
    {
      "cmd_idx": 8,
      "file": "build.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: the borrowed expression implements the required traits\n  --> build.rs:16:19\n   |\n16 |             .args(&[\"submodule\", \"update\", \"--init\", \"--recursive\"])\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: change this to: `[\"submodule\", \"update\", \"--init\", \"--recursive\"]`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrows_for_generic_args\n   = note: `#[warn(clippy::needless_borrows_for_generic_args)]` on by default\n\n"
    },
    {
      "cmd_idx": 8,
      "file": "build.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: spawned process is never `wait()`ed on\n  --> build.rs:22:9\n   |\n22 | /         Command::new(\"git\")\n23 | |             .args(&[\"apply\", lwext4_patch.to_str().unwrap()])\n24 | |             .current_dir(c_path.clone())\n25 | |             .spawn()\n26 | |             .expect(\"failed to execute process: git apply patch\");\n   | |                                                                 ^- help: try: `.wait()`\n   | |_________________________________________________________________|\n   |\n   |\n   = note: not doing so might leave behind zombie processes\n   = note: see https://doc.rust-lang.org/stable/std/process/struct.Child.html#warning\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#zombie_processes\n   = note: `#[warn(clippy::zombie_processes)]` on by default\n\n"
    },
    {
      "cmd_idx": 8,
      "file": "build.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: the borrowed expression implements the required traits\n  --> build.rs:23:19\n   |\n23 |             .args(&[\"apply\", lwext4_patch.to_str().unwrap()])\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: change this to: `[\"apply\", lwext4_patch.to_str().unwrap()]`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrows_for_generic_args\n\n"
    },
    {
      "cmd_idx": 8,
      "file": "build.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: the borrowed expression implements the required traits\n  --> build.rs:40:19\n   |\n40 |               .args(&[\n   |  ___________________^\n41 | |                 \"musl-generic\",\n42 | |                 \"-C\",\n43 | |                 c_path.to_str().expect(\"invalid path of lwext4\"),\n44 | |             ])\n   | |_____________^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrows_for_generic_args\nhelp: change this to\n   |\n40 ~             .args([\n41 +                 \"musl-generic\",\n42 +                 \"-C\",\n43 +                 c_path.to_str().expect(\"invalid path of lwext4\"),\n44 ~             ])\n   |\n\n"
    },
    {
      "cmd_idx": 8,
      "file": "build.rs",
      "kind": "Clippy(Warn)",
      "raw": "warning: the borrowed expression implements the required traits\n  --> build.rs:45:18\n   |\n45 |             .arg(&format!(\"ARCH={}\", arch))\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ help: change this to: `format!(\"ARCH={}\", arch)`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrows_for_generic_args\n\n"
    },
    {
      "cmd_idx": 9,
      "file": "[semver checks]",
      "kind": "Semver Violation",
      "raw": "pkg=lwext4_rust, checker=SemverChecks\ntoolchain=nightly-2025-01-26-x86_64-unknown-linux-gnu, target=riscv64gc-unknown-none-elf\nfeatures=\npkg_dir=/home/runner/check/batch_29/elliott10/lwext4_rust\ncmd=cargo +nightly-2025-01-26-x86_64-unknown-linux-gnu semver-checks --target riscv64gc-unknown-none-elf \ntimestamp=2025-02-16 23:44:48.754861369 +08:00:00\n\n\nstdout:\n\nstderr:\n    Building lwext4_rust v0.2.0 (current)\nerror: running cargo-doc on crate 'lwext4_rust' failed with output:\n-----\n    Checking either v1.13.0\n    Checking cty v0.2.2\n    Checking memchr v2.7.4\n    Checking bitflags v1.3.2\n   Compiling lwext4_rust v0.2.0 (/home/runner/check/batch_29/elliott10/lwext4_rust)\n    Checking log v0.4.25\n    Checking itertools v0.9.0\n    Checking cstr_core v0.2.6\nerror: failed to run custom build command for `lwext4_rust v0.2.0 (/home/runner/check/batch_29/elliott10/lwext4_rust)`\n\nCaused by:\n  process didn't exit successfully: `/home/runner/check/batch_29/elliott10/lwext4_rust/target/semver-checks/local-lwext4_rust-0_2_0-e7bffb85b1077fd0/target/debug/build/lwext4_rust-c6d9a3f78d835c08/build-script-build` (exit status: 101)\n  --- stdout\n  make: Entering directory '/home/runner/check/batch_29/elliott10/lwext4_rust/c/lwext4'\n  rm -R -f build_musl-generic\n  mkdir build_musl-generic\n  cd build_musl-generic && cmake -G\"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release -DVERSION_MAJOR=1 -DVERSION_MINOR=0 -DVERSION_PATCH=0 -DVERSION=1.0.0-58bcf89 -DLWEXT4_BUILD_SHARED_LIB=OFF -DCMAKE_INSTALL_PREFIX=./install   -DCMAKE_TOOLCHAIN_FILE=../toolchain/musl-generic.cmake ..\n  -- The C compiler identification is unknown\n  -- Configuring incomplete, errors occurred!\n  make: Leaving directory '/home/runner/check/batch_29/elliott10/lwext4_rust/c/lwext4'\n\n  --- stderr\n  CMake Warning (dev) at CMakeLists.txt:1 (project):\n    cmake_minimum_required() should be called prior to this top-level project()\n    call.  Please see the cmake-commands(7) manual for usage documentation of\n    both commands.\n  This warning is for project developers.  Use -Wno-dev to suppress it.\n\n  CMake Error at CMakeLists.txt:1 (project):\n    The CMAKE_C_COMPILER:\n\n      riscv64-linux-musl-cc\n\n    is not a full path and was not found in the PATH.\n\n    Tell CMake where to find the compiler by setting either the environment\n    variable \"CC\" or the CMake cache entry CMAKE_C_COMPILER to the full path to\n    the compiler, or to the compiler name if it is in the PATH.\n\n\n  make: *** [Makefile:37: musl-generic] Error 1\n\n  thread 'main' panicked at /home/runner/check/batch_29/elliott10/lwext4_rust/build.rs:48:9:\n  assertion failed: status.success()\n  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nwarning: build failed, waiting for other jobs to finish...\n\n-----\n\nerror: failed to build rustdoc for crate lwext4_rust v0.2.0\nnote: this is usually due to a compilation error in the crate,\n      and is unlikely to be a bug in cargo-semver-checks\nnote: the following command can be used to reproduce the compilation error:\n      cargo new --lib example &&\n          cd example &&\n          echo '[workspace]' >> Cargo.toml &&\n          cargo add --path /home/runner/check/batch_29/elliott10/lwext4_rust --features default,print,printf-compat &&\n          cargo check\n\nerror: aborting due to failure to build rustdoc for crate lwext4_rust v0.2.0\n"
    },
    {
      "cmd_idx": 12,
      "file": "[outdated direct dependencies]",
      "kind": "Outdated",
      "raw": "pkg=lwext4_rust, checker=Outdated\ntoolchain=nightly-2025-01-26-x86_64-unknown-linux-gnu, target=riscv64gc-unknown-none-elf\nfeatures=\npkg_dir=/home/runner/check/batch_29/elliott10/lwext4_rust\ncmd=cargo +nightly-2025-01-26-x86_64-unknown-linux-gnu outdated -R --exit-code=2\ntimestamp=2025-02-16 23:44:57.334096084 +08:00:00\n\nName  Project  Compat  Latest  Kind    Platform\n----  -------  ------  ------  ----    --------\nlog   0.4.21   0.4.25  0.4.25  Normal  ---\n"
    },
    {
      "cmd_idx": 13,
      "file": "(virtual) clippy",
      "kind": "Cargo",
      "raw": "// pkg_name=lwext4_rust, checker=Clippy\n// toolchain=nightly-2025-01-26-x86_64-unknown-linux-gnu, target=riscv64gc-unknown-none-elf\n// features=\n// pkg_dir=/home/runner/check/batch_29/elliott10/lwext4_rust\n// cmd=cargo clippy --target riscv64gc-unknown-none-elf  --no-deps\n// timestamp=2025-02-16 23:44:47.149846047 +08:00:00\n    Checking cty v0.2.2\n    Checking memchr v2.7.2\n    Checking either v1.10.0\n   Compiling lwext4_rust v0.2.0 (/home/runner/check/batch_29/elliott10/lwext4_rust)\n    Checking bitflags v1.3.2\n    Checking log v0.4.21\n    Checking itertools v0.9.0\n    Checking cstr_core v0.2.6\n    Checking printf-compat v0.1.1\nerror: failed to run custom build command for `lwext4_rust v0.2.0 (/home/runner/check/batch_29/elliott10/lwext4_rust)`\n\nCaused by:\n  process didn't exit successfully: `/home/runner/check/batch_29/elliott10/lwext4_rust/target/debug/build/lwext4_rust-a514e9ae7e6af264/build-script-build` (exit status: 101)\n  --- stdout\n  Retrieve lwext4 source code\n  To patch lwext4 src\n  make: Entering directory '/home/runner/check/batch_29/elliott10/lwext4_rust/c/lwext4'\n  rm -R -f build_musl-generic\n  mkdir build_musl-generic\n  cd build_musl-generic && cmake -G\"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release -DVERSION_MAJOR=1 -DVERSION_MINOR=0 -DVERSION_PATCH=0 -DVERSION=1.0.0-58bcf89 -DLWEXT4_BUILD_SHARED_LIB=OFF -DCMAKE_INSTALL_PREFIX=./install   -DCMAKE_TOOLCHAIN_FILE=../toolchain/musl-generic.cmake ..\n  -- The C compiler identification is unknown\n  -- Configuring incomplete, errors occurred!\n  make: Leaving directory '/home/runner/check/batch_29/elliott10/lwext4_rust/c/lwext4'\n\n  --- stderr\n  CMake Warning (dev) at CMakeLists.txt:1 (project):\n    cmake_minimum_required() should be called prior to this top-level project()\n    call.  Please see the cmake-commands(7) manual for usage documentation of\n    both commands.\n  This warning is for project developers.  Use -Wno-dev to suppress it.\n\n  CMake Error at CMakeLists.txt:1 (project):\n    The CMAKE_C_COMPILER:\n\n      riscv64-linux-musl-cc\n\n    is not a full path and was not found in the PATH.\n\n    Tell CMake where to find the compiler by setting either the environment\n    variable \"CC\" or the CMake cache entry CMAKE_C_COMPILER to the full path to\n    the compiler, or to the compiler name if it is in the PATH.\n\n\n  make: *** [Makefile:37: musl-generic] Error 1\n\n  thread 'main' panicked at build.rs:48:9:\n  assertion failed: status.success()\n  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nwarning: build failed, waiting for other jobs to finish...\n"
    },
    {
      "cmd_idx": 14,
      "file": "(virtual) semver-checks",
      "kind": "Cargo",
      "raw": "// pkg_name=lwext4_rust, checker=SemverChecks\n// toolchain=nightly-2025-01-26-x86_64-unknown-linux-gnu, target=riscv64gc-unknown-none-elf\n// features=\n// pkg_dir=/home/runner/check/batch_29/elliott10/lwext4_rust\n// cmd=cargo +nightly-2025-01-26-x86_64-unknown-linux-gnu semver-checks --target riscv64gc-unknown-none-elf \n// timestamp=2025-02-16 23:44:47.964225741 +08:00:00\n    Building lwext4_rust v0.2.0 (current)\nerror: running cargo-doc on crate 'lwext4_rust' failed with output:\n-----\n    Checking either v1.13.0\n    Checking cty v0.2.2\n    Checking memchr v2.7.4\n    Checking bitflags v1.3.2\n   Compiling lwext4_rust v0.2.0 (/home/runner/check/batch_29/elliott10/lwext4_rust)\n    Checking log v0.4.25\n    Checking itertools v0.9.0\n    Checking cstr_core v0.2.6\nerror: failed to run custom build command for `lwext4_rust v0.2.0 (/home/runner/check/batch_29/elliott10/lwext4_rust)`\n\nCaused by:\n  process didn't exit successfully: `/home/runner/check/batch_29/elliott10/lwext4_rust/target/semver-checks/local-lwext4_rust-0_2_0-e7bffb85b1077fd0/target/debug/build/lwext4_rust-c6d9a3f78d835c08/build-script-build` (exit status: 101)\n  --- stdout\n  make: Entering directory '/home/runner/check/batch_29/elliott10/lwext4_rust/c/lwext4'\n  rm -R -f build_musl-generic\n  mkdir build_musl-generic\n  cd build_musl-generic && cmake -G\"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release -DVERSION_MAJOR=1 -DVERSION_MINOR=0 -DVERSION_PATCH=0 -DVERSION=1.0.0-58bcf89 -DLWEXT4_BUILD_SHARED_LIB=OFF -DCMAKE_INSTALL_PREFIX=./install   -DCMAKE_TOOLCHAIN_FILE=../toolchain/musl-generic.cmake ..\n  -- The C compiler identification is unknown\n  -- Configuring incomplete, errors occurred!\n  make: Leaving directory '/home/runner/check/batch_29/elliott10/lwext4_rust/c/lwext4'\n\n  --- stderr\n  CMake Warning (dev) at CMakeLists.txt:1 (project):\n    cmake_minimum_required() should be called prior to this top-level project()\n    call.  Please see the cmake-commands(7) manual for usage documentation of\n    both commands.\n  This warning is for project developers.  Use -Wno-dev to suppress it.\n\n  CMake Error at CMakeLists.txt:1 (project):\n    The CMAKE_C_COMPILER:\n\n      riscv64-linux-musl-cc\n\n    is not a full path and was not found in the PATH.\n\n    Tell CMake where to find the compiler by setting either the environment\n    variable \"CC\" or the CMake cache entry CMAKE_C_COMPILER to the full path to\n    the compiler, or to the compiler name if it is in the PATH.\n\n\n  make: *** [Makefile:37: musl-generic] Error 1\n\n  thread 'main' panicked at /home/runner/check/batch_29/elliott10/lwext4_rust/build.rs:48:9:\n  assertion failed: status.success()\n  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nwarning: build failed, waiting for other jobs to finish...\n\n-----\n\nerror: failed to build rustdoc for crate lwext4_rust v0.2.0\nnote: this is usually due to a compilation error in the crate,\n      and is unlikely to be a bug in cargo-semver-checks\nnote: the following command can be used to reproduce the compilation error:\n      cargo new --lib example &&\n          cd example &&\n          echo '[workspace]' >> Cargo.toml &&\n          cargo add --path /home/runner/check/batch_29/elliott10/lwext4_rust --features default,print,printf-compat &&\n          cargo check\n\nerror: aborting due to failure to build rustdoc for crate lwext4_rust v0.2.0\n"
    },
    {
      "cmd_idx": 15,
      "file": "(virtual) lockbud",
      "kind": "Cargo",
      "raw": "// pkg_name=lwext4_rust, checker=Lockbud\n// toolchain=nightly-2025-01-26-x86_64-unknown-linux-gnu, target=riscv64gc-unknown-none-elf\n// features=\n// pkg_dir=/home/runner/check/batch_29/elliott10/lwext4_rust\n// cmd=cargo +nightly-2024-12-01 lockbud -k all -- --target riscv64gc-unknown-none-elf \n// timestamp=2025-02-16 23:44:48.757006179 +08:00:00\n Downloading crates ...\n  Downloaded cstr_core v0.2.6\n  Downloaded either v1.10.0\n  Downloaded cty v0.2.2\n  Downloaded itertools v0.9.0\n  Downloaded printf-compat v0.1.1\n   Compiling memchr v2.7.2\n   Compiling either v1.10.0\n   Compiling cty v0.2.2\n   Compiling bitflags v1.3.2\n   Compiling lwext4_rust v0.2.0 (/home/runner/check/batch_29/elliott10/lwext4_rust)\n   Compiling log v0.4.21\n[2025-02-16T15:44:49Z WARN  lockbud::callbacks] [\n      {\n        \"AtomicityViolation\": {\n          \"bug_kind\": \"AtomicityViolation\",\n          \"possibility\": \"Possibly\",\n          \"diagnosis\": {\n            \"fn_name\": \"set_logger_racy\",\n            \"atomic_reader\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.21/src/lib.rs:1408:11: 1408:39 (#0)\",\n            \"atomic_writer\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.21/src/lib.rs:1411:13: 1411:55 (#0)\",\n            \"dep_kind\": \"Control\"\n          },\n          \"explanation\": \"atomic::store is data/control dependent on atomic::load\"\n        }\n      }\n    ]\n[2025-02-16T15:44:49Z WARN  lockbud::callbacks] crate log contains bugs: { probably: 0, possibly: 0 }, conflictlock: { probably: 0, possibly: 0 }, condvar_deadlock: { probably: 0, possibly: 0 }, atomicity_violation: { possibly: 1 }, invalid_free: { possibly: 0 }, use_after_free: { possibly: 0 }\n   Compiling itertools v0.9.0\n   Compiling cstr_core v0.2.6\nerror: failed to run custom build command for `lwext4_rust v0.2.0 (/home/runner/check/batch_29/elliott10/lwext4_rust)`\n\nCaused by:\n  process didn't exit successfully: `/home/runner/check/batch_29/elliott10/lwext4_rust/target/debug/build/lwext4_rust-909890d5bbd2200e/build-script-build` (exit status: 101)\n  --- stdout\n  make: Entering directory '/home/runner/check/batch_29/elliott10/lwext4_rust/c/lwext4'\n  rm -R -f build_musl-generic\n  mkdir build_musl-generic\n  cd build_musl-generic && cmake -G\"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release -DVERSION_MAJOR=1 -DVERSION_MINOR=0 -DVERSION_PATCH=0 -DVERSION=1.0.0-58bcf89 -DLWEXT4_BUILD_SHARED_LIB=OFF -DCMAKE_INSTALL_PREFIX=./install   -DCMAKE_TOOLCHAIN_FILE=../toolchain/musl-generic.cmake ..\n  -- The C compiler identification is unknown\n  -- Configuring incomplete, errors occurred!\n  make: Leaving directory '/home/runner/check/batch_29/elliott10/lwext4_rust/c/lwext4'\n\n  --- stderr\n  CMake Warning (dev) at CMakeLists.txt:1 (project):\n    cmake_minimum_required() should be called prior to this top-level project()\n    call.  Please see the cmake-commands(7) manual for usage documentation of\n    both commands.\n  This warning is for project developers.  Use -Wno-dev to suppress it.\n\n  CMake Error at CMakeLists.txt:1 (project):\n    The CMAKE_C_COMPILER:\n\n      riscv64-linux-musl-cc\n\n    is not a full path and was not found in the PATH.\n\n    Tell CMake where to find the compiler by setting either the environment\n    variable \"CC\" or the CMake cache entry CMAKE_C_COMPILER to the full path to\n    the compiler, or to the compiler name if it is in the PATH.\n\n\n  make: *** [Makefile:37: musl-generic] Error 1\n  thread 'main' panicked at build.rs:48:9:\n  assertion failed: status.success()\n  stack backtrace:\n     0:     0x556c1e9a9a5a - std::backtrace_rs::backtrace::libunwind::trace::h392ec3763e4ee520\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/../../backtrace/src/backtrace/libunwind.rs:116:5\n     1:     0x556c1e9a9a5a - std::backtrace_rs::backtrace::trace_unsynchronized::h52faccb7d9939779\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\n     2:     0x556c1e9a9a5a - std::sys::backtrace::_print_fmt::h4ca48f886ab6d023\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/sys/backtrace.rs:66:9\n     3:     0x556c1e9a9a5a - <std::sys::backtrace::BacktraceLock::print::DisplayBacktrace as core::fmt::Display>::fmt::h41650409cfcaa385\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/sys/backtrace.rs:39:26\n     4:     0x556c1e9ca993 - core::fmt::rt::Argument::fmt::h3a0dfc0e2b206c6c\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/core/src/fmt/rt.rs:177:76\n     5:     0x556c1e9ca993 - core::fmt::write::h124e50a41a614f35\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/core/src/fmt/mod.rs:1185:21\n     6:     0x556c1e9a6ce3 - std::io::Write::write_fmt::h152c770d77d8200b\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/io/mod.rs:1887:15\n     7:     0x556c1e9a98a2 - std::sys::backtrace::BacktraceLock::print::hb77a071b09f7b2d4\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/sys/backtrace.rs:42:9\n     8:     0x556c1e9aa86d - std::panicking::default_hook::{{closure}}::h2289b310e8f70172\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panicking.rs:284:22\n     9:     0x556c1e9aa6b2 - std::panicking::default_hook::h6b36901e2a542246\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panicking.rs:311:9\n    10:     0x556c1e9aae67 - std::panicking::rust_panic_with_hook::hd7b2147b933d3e5b\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panicking.rs:817:13\n    11:     0x556c1e9aacc6 - std::panicking::begin_panic_handler::{{closure}}::h529091dbfbeb0f88\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panicking.rs:683:13\n    12:     0x556c1e9a9f39 - std::sys::backtrace::__rust_end_short_backtrace::h560f3f6f1bef32f3\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/sys/backtrace.rs:170:18\n    13:     0x556c1e9aa98d - rust_begin_unwind\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panicking.rs:681:5\n    14:     0x556c1e9c9bb0 - core::panicking::panic_fmt::h0831c2ae5fe21ab8\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/core/src/panicking.rs:75:14\n    15:     0x556c1e9c9c3c - core::panicking::panic::h8345ebad421281bc\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/core/src/panicking.rs:145:5\n    16:     0x556c1e980f02 - build_script_build::main::h911ff25ed245b7e5\n                                 at /home/runner/check/batch_29/elliott10/lwext4_rust/build.rs:48:9\n    17:     0x556c1e98280b - core::ops::function::FnOnce::call_once::h12fa7baec91f3519\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/core/src/ops/function.rs:250:5\n    18:     0x556c1e9820ce - std::sys::backtrace::__rust_begin_short_backtrace::h440f5647edfc0770\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/sys/backtrace.rs:154:18\n    19:     0x556c1e982001 - std::rt::lang_start::{{closure}}::h89ca6bae058e1830\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/rt.rs:195:18\n    20:     0x556c1e9a3f27 - core::ops::function::impls::<impl core::ops::function::FnOnce<A> for &F>::call_once::h35ac998e8377d702\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/core/src/ops/function.rs:284:13\n    21:     0x556c1e9a3f27 - std::panicking::try::do_call::h375eb96a9ae157af\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panicking.rs:573:40\n    22:     0x556c1e9a3f27 - std::panicking::try::h004dd624c2163121\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panicking.rs:536:19\n    23:     0x556c1e9a3f27 - std::panic::catch_unwind::h86180637abc5e029\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panic.rs:358:14\n    24:     0x556c1e9a3f27 - std::rt::lang_start_internal::{{closure}}::h423349aec7014c22\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/rt.rs:174:48\n    25:     0x556c1e9a3f27 - std::panicking::try::do_call::h4e2bc89ab3a21ffc\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panicking.rs:573:40\n    26:     0x556c1e9a3f27 - std::panicking::try::hd6b79a96186c0cd0\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panicking.rs:536:19\n    27:     0x556c1e9a3f27 - std::panic::catch_unwind::h2450b06afb6527e0\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panic.rs:358:14\n    28:     0x556c1e9a3f27 - std::rt::lang_start_internal::he23058d2283a9650\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/rt.rs:174:20\n    29:     0x556c1e981fda - std::rt::lang_start::he1996f49bf799eed\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/rt.rs:194:17\n    30:     0x556c1e9817ae - main\n    31:     0x7f263ae2a1ca - <unknown>\n    32:     0x7f263ae2a28b - __libc_start_main\n    33:     0x556c1e97bbb5 - _start\n    34:                0x0 - <unknown>\nwarning: build failed, waiting for other jobs to finish...\n"
    },
    {
      "cmd_idx": 16,
      "file": "(virtual) rapx",
      "kind": "Cargo",
      "raw": "// pkg_name=lwext4_rust, checker=Rapx\n// toolchain=nightly-2025-01-26-x86_64-unknown-linux-gnu, target=riscv64gc-unknown-none-elf\n// features=\n// pkg_dir=/home/runner/check/batch_29/elliott10/lwext4_rust\n// cmd=cargo +nightly-2024-10-12 rapx -F -M -- --target riscv64gc-unknown-none-elf \n// timestamp=2025-02-16 23:44:52.930218647 +08:00:00\n    Checking cty v0.2.2\n    Checking memchr v2.7.2\n    Checking either v1.10.0\n   Compiling lwext4_rust v0.2.0 (/home/runner/check/batch_29/elliott10/lwext4_rust)\n    Checking bitflags v1.3.2\n    Checking itertools v0.9.0\n    Checking log v0.4.21\n    Checking cstr_core v0.2.6\nerror: failed to run custom build command for `lwext4_rust v0.2.0 (/home/runner/check/batch_29/elliott10/lwext4_rust)`\n\nCaused by:\n  process didn't exit successfully: `/home/runner/check/batch_29/elliott10/lwext4_rust/target/debug/build/lwext4_rust-909890d5bbd2200e/build-script-build` (exit status: 101)\n  --- stdout\n  make: Entering directory '/home/runner/check/batch_29/elliott10/lwext4_rust/c/lwext4'\n  rm -R -f build_musl-generic\n  mkdir build_musl-generic\n  cd build_musl-generic && cmake -G\"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release -DVERSION_MAJOR=1 -DVERSION_MINOR=0 -DVERSION_PATCH=0 -DVERSION=1.0.0-58bcf89 -DLWEXT4_BUILD_SHARED_LIB=OFF -DCMAKE_INSTALL_PREFIX=./install   -DCMAKE_TOOLCHAIN_FILE=../toolchain/musl-generic.cmake ..\n  -- The C compiler identification is unknown\n  -- Configuring incomplete, errors occurred!\n  make: Leaving directory '/home/runner/check/batch_29/elliott10/lwext4_rust/c/lwext4'\n\n  --- stderr\n  CMake Warning (dev) at CMakeLists.txt:1 (project):\n    cmake_minimum_required() should be called prior to this top-level project()\n    call.  Please see the cmake-commands(7) manual for usage documentation of\n    both commands.\n  This warning is for project developers.  Use -Wno-dev to suppress it.\n\n  CMake Error at CMakeLists.txt:1 (project):\n    The CMAKE_C_COMPILER:\n\n      riscv64-linux-musl-cc\n\n    is not a full path and was not found in the PATH.\n\n    Tell CMake where to find the compiler by setting either the environment\n    variable \"CC\" or the CMake cache entry CMAKE_C_COMPILER to the full path to\n    the compiler, or to the compiler name if it is in the PATH.\n\n\n  make: *** [Makefile:37: musl-generic] Error 1\n  thread 'main' panicked at build.rs:48:9:\n  assertion failed: status.success()\n  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nwarning: build failed, waiting for other jobs to finish...\n15:44:53|RAP|ERROR|: Finished with non-zero exit code.\n"
    },
    {
      "cmd_idx": 17,
      "file": "src/boot/lang_items.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/lang_items.rs (original lines from 4 to 7)\n-fn panic(info: &PanicInfo) -> !{\n-\tprintln!(\"{}\", info);\n-\tcrate::boot::sbi::shutdown();\n-\tunreachable!()\n+fn panic(info: &PanicInfo) -> ! {\n+    println!(\"{}\", info);\n+    crate::boot::sbi::shutdown();\n+    unreachable!()\n"
    },
    {
      "cmd_idx": 17,
      "file": "src/boot/lang_items.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/lang_items.rs (original lines from 11 to 12)\n-pub extern \"C\" fn abort() -> !{\n-\tpanic!(\"abort!\");\n+pub extern \"C\" fn abort() -> ! {\n+    panic!(\"abort!\");\n"
    },
    {
      "cmd_idx": 17,
      "file": "src/boot/lang_items.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/lang_items.rs (original lines from 14 to 14)\n-\n"
    },
    {
      "cmd_idx": 17,
      "file": "src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 3 to 4)\n-pub fn console_putchar(ch: usize){\n-\tsbi_call(SBI_CONSOLE_PUTCHAR, ch, 0, 0);\n+pub fn console_putchar(ch: usize) {\n+    sbi_call(SBI_CONSOLE_PUTCHAR, ch, 0, 0);\n"
    },
    {
      "cmd_idx": 17,
      "file": "src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 8 to 8)\n-\treturn sbi_call(SBI_CONSOLE_GETCHAR, 0, 0, 0);\n+    return sbi_call(SBI_CONSOLE_GETCHAR, 0, 0, 0);\n"
    },
    {
      "cmd_idx": 17,
      "file": "src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 11 to 23)\n-pub fn console_putchar_u8(ch: u8){\n-\tlet ret: isize;\n-\t//let arg0: char = ch as char;\n-\tlet arg0: u8 = ch;\n-\tlet arg1: usize = 0;\n-\tlet arg2: usize = 0;\n-\tlet which: usize = 1; //SBI_ECALL_CONSOLE_PUTCHAR\n-\tunsafe{\n-\t\tasm!(\"ecall\",\n-\t\t     lateout(\"x10\") ret,\n-\t\t     in(\"x10\") arg0, in(\"x11\") arg1, in(\"x12\") arg2, in(\"x17\") which\n-             );\n-\t}\n+pub fn console_putchar_u8(ch: u8) {\n+    let ret: isize;\n+    //let arg0: char = ch as char;\n+    let arg0: u8 = ch;\n+    let arg1: usize = 0;\n+    let arg2: usize = 0;\n+    let which: usize = 1; //SBI_ECALL_CONSOLE_PUTCHAR\n+    unsafe {\n+        asm!(\"ecall\",\n+        lateout(\"x10\") ret,\n+        in(\"x10\") arg0, in(\"x11\") arg1, in(\"x12\") arg2, in(\"x17\") which\n+        );\n+    }\n"
    },
    {
      "cmd_idx": 17,
      "file": "src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 26 to 28)\n-fn sbi_call(which: usize, arg0: usize, arg1: usize, arg2: usize) -> isize{\n-\tlet ret: isize;\n-\tunsafe{\n+fn sbi_call(which: usize, arg0: usize, arg1: usize, arg2: usize) -> isize {\n+    let ret: isize;\n+    unsafe {\n"
    },
    {
      "cmd_idx": 17,
      "file": "src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 30 to 34)\n-             lateout(\"x10\") ret,\n-             in(\"x10\") arg0, in(\"x11\") arg1, in(\"x12\") arg2, in(\"x17\") which\n-            );\n-\t}\n-\tret\n+         lateout(\"x10\") ret,\n+         in(\"x10\") arg0, in(\"x11\") arg1, in(\"x12\") arg2, in(\"x17\") which\n+        );\n+    }\n+    ret\n"
    },
    {
      "cmd_idx": 17,
      "file": "src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 37 to 39)\n-pub fn set_timer(stime_value: u64){\n-\t#[cfg(target_pointer_width = \"32\")]\n-\tsbi_call(SBI_SET_TIMER, stime_value as usize, (stime_value >> 32), 0);\n+pub fn set_timer(stime_value: u64) {\n+    #[cfg(target_pointer_width = \"32\")]\n+    sbi_call(SBI_SET_TIMER, stime_value as usize, (stime_value >> 32), 0);\n"
    },
    {
      "cmd_idx": 17,
      "file": "src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 41 to 42)\n-\t#[cfg(target_pointer_width = \"64\")]\n-\tsbi_call(SBI_SET_TIMER, stime_value as usize, 0, 0);\n+    #[cfg(target_pointer_width = \"64\")]\n+    sbi_call(SBI_SET_TIMER, stime_value as usize, 0, 0);\n"
    },
    {
      "cmd_idx": 17,
      "file": "src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 44 to 45)\n-pub fn clear_ipi(){\n-\tsbi_call(SBI_CLEAR_IPI, 0, 0, 0);\n+pub fn clear_ipi() {\n+    sbi_call(SBI_CLEAR_IPI, 0, 0, 0);\n"
    },
    {
      "cmd_idx": 17,
      "file": "src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 48 to 49)\n-pub fn send_ipi(sipi_value: usize){\n-\tsbi_call(SBI_SEND_IPI, sipi_value, 0, 0);\n+pub fn send_ipi(sipi_value: usize) {\n+    sbi_call(SBI_SEND_IPI, sipi_value, 0, 0);\n"
    },
    {
      "cmd_idx": 17,
      "file": "src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 52 to 53)\n-pub fn set_s_insn(entry: usize){\n-\tsbi_call(SBI_SET_SINSN, entry, 0, 0);\n+pub fn set_s_insn(entry: usize) {\n+    sbi_call(SBI_SET_SINSN, entry, 0, 0);\n"
    },
    {
      "cmd_idx": 17,
      "file": "src/boot/sbi.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/boot/sbi.rs (original lines from 56 to 57)\n-pub fn shutdown(){\n-\tsbi_call(SBI_SHUTDOWN, 0, 0, 0);\n+pub fn shutdown() {\n+    sbi_call(SBI_SHUTDOWN, 0, 0, 0);\n"
    },
    {
      "cmd_idx": 17,
      "file": "src/ext4fs.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/ext4fs.rs (original lines from 96 to 96)\n-\n"
    },
    {
      "cmd_idx": 17,
      "file": "src/pci_impl.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/pci_impl.rs (original lines from 2 to 2)\n-use pci::{PortOps, CSpaceAccessMethod};\n+use pci::{CSpaceAccessMethod, PortOps};\n"
    },
    {
      "cmd_idx": 17,
      "file": "src/pci_impl.rs",
      "kind": "Unformatted",
      "raw": "file: /home/runner/check/batch_29/elliott10/lwext4_rust/examples/src/pci_impl.rs (original lines from 9 to 9)\n-pub const PCI_COMMAND_INTX_DISABLE:u16 = 0x400;\n+pub const PCI_COMMAND_INTX_DISABLE: u16 = 0x400;\n"
    },
    {
      "cmd_idx": 21,
      "file": "[outdated direct dependencies]",
      "kind": "Outdated",
      "raw": "pkg=lwext4_rust_examples, checker=Outdated\ntoolchain=nightly-2024-01-31, target=riscv64gc-unknown-none-elf\nfeatures=\npkg_dir=/home/runner/check/batch_29/elliott10/lwext4_rust/examples\ncmd=cargo +nightly-2025-01-26-x86_64-unknown-linux-gnu outdated -R --exit-code=2\ntimestamp=2025-02-16 23:44:57.852218404 +08:00:00\n\nName   Project  Compat  Latest  Kind    Platform\n----   -------  ------  ------  ----    --------\nriscv  0.8.0    ---     0.12.1  Normal  ---\n"
    },
    {
      "cmd_idx": 22,
      "file": "(virtual) lockbud",
      "kind": "Cargo",
      "raw": "// pkg_name=lwext4_rust_examples, checker=Lockbud\n// toolchain=nightly-2024-01-31, target=riscv64gc-unknown-none-elf\n// features=\n// pkg_dir=/home/runner/check/batch_29/elliott10/lwext4_rust/examples\n// cmd=cargo +nightly-2024-12-01 lockbud -k all -- --target riscv64gc-unknown-none-elf \n// timestamp=2025-02-16 23:44:49.480975754 +08:00:00\nwarning: `/home/runner/check/batch_29/elliott10/lwext4_rust/examples/.cargo/config` is deprecated in favor of `config.toml`\nnote: if you need to support cargo 1.38 or earlier, you can symlink `config` to `config.toml`\nwarning: `/home/runner/check/batch_29/elliott10/lwext4_rust/examples/.cargo/config` is deprecated in favor of `config.toml`\nnote: if you need to support cargo 1.38 or earlier, you can symlink `config` to `config.toml`\nwarning: no edition set: defaulting to the 2015 edition while the latest is 2024\n Downloading crates ...\n  Downloaded linked_list_allocator v0.10.5\n  Downloaded spinning_top v0.2.5\n   Compiling proc-macro2 v1.0.93\n   Compiling unicode-ident v1.0.16\n   Compiling autocfg v1.4.0\n   Compiling log v0.4.25\n   Compiling either v1.13.0\n[2025-02-16T15:44:49Z WARN  lockbud::callbacks] [\n      {\n        \"AtomicityViolation\": {\n          \"bug_kind\": \"AtomicityViolation\",\n          \"possibility\": \"Possibly\",\n          \"diagnosis\": {\n            \"fn_name\": \"set_logger_racy\",\n            \"atomic_reader\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.25/src/lib.rs:1453:11: 1453:40 (#0)\",\n            \"atomic_writer\": \"/home/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/log-0.4.25/src/lib.rs:1456:13: 1456:56 (#0)\",\n            \"dep_kind\": \"Control\"\n          },\n          \"explanation\": \"atomic::store is data/control dependent on atomic::load\"\n        }\n      }\n    ]\n[2025-02-16T15:44:49Z WARN  lockbud::callbacks] crate log contains bugs: { probably: 0, possibly: 0 }, conflictlock: { probably: 0, possibly: 0 }, condvar_deadlock: { probably: 0, possibly: 0 }, atomicity_violation: { possibly: 1 }, invalid_free: { possibly: 0 }, use_after_free: { possibly: 0 }\n   Compiling scopeguard v1.2.0\n   Compiling nb v1.1.0\n   Compiling memchr v2.7.4\n   Compiling cty v0.2.2\n   Compiling bitflags v1.3.2\n   Compiling nb v0.1.3\n   Compiling itertools v0.9.0\n   Compiling lock_api v0.4.12\n   Compiling cstr_core v0.2.6\n   Compiling quote v1.0.38\n   Compiling byteorder v1.5.0\n   Compiling void v1.0.2\n   Compiling lwext4_rust v0.2.0 (/home/runner/check/batch_29/elliott10/lwext4_rust)\n   Compiling syn v2.0.98\n   Compiling riscv v0.8.0\n   Compiling embedded-hal v0.2.7\n   Compiling spinning_top v0.2.5\n   Compiling printf-compat v0.1.1\n   Compiling spin v0.9.8\n   Compiling bitflags v2.8.0\nerror: failed to run custom build command for `lwext4_rust v0.2.0 (/home/runner/check/batch_29/elliott10/lwext4_rust)`\n\nCaused by:\n  process didn't exit successfully: `/home/runner/check/batch_29/elliott10/lwext4_rust/examples/target/debug/build/lwext4_rust-f6d2545fa0e7dcc7/build-script-build` (exit status: 101)\n  --- stdout\n  make: Entering directory '/home/runner/check/batch_29/elliott10/lwext4_rust/c/lwext4'\n  rm -R -f build_musl-generic\n  mkdir build_musl-generic\n  cd build_musl-generic && cmake -G\"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release -DVERSION_MAJOR=1 -DVERSION_MINOR=0 -DVERSION_PATCH=0 -DVERSION=1.0.0-58bcf89 -DLWEXT4_BUILD_SHARED_LIB=OFF -DCMAKE_INSTALL_PREFIX=./install   -DCMAKE_TOOLCHAIN_FILE=../toolchain/musl-generic.cmake ..\n  -- The C compiler identification is unknown\n  -- Configuring incomplete, errors occurred!\n  make: Leaving directory '/home/runner/check/batch_29/elliott10/lwext4_rust/c/lwext4'\n\n  --- stderr\n  CMake Warning (dev) at CMakeLists.txt:1 (project):\n    cmake_minimum_required() should be called prior to this top-level project()\n    call.  Please see the cmake-commands(7) manual for usage documentation of\n    both commands.\n  This warning is for project developers.  Use -Wno-dev to suppress it.\n\n  CMake Error at CMakeLists.txt:1 (project):\n    The CMAKE_C_COMPILER:\n\n      riscv64-linux-musl-cc\n\n    is not a full path and was not found in the PATH.\n\n    Tell CMake where to find the compiler by setting either the environment\n    variable \"CC\" or the CMake cache entry CMAKE_C_COMPILER to the full path to\n    the compiler, or to the compiler name if it is in the PATH.\n\n\n  make: *** [Makefile:37: musl-generic] Error 1\n  thread 'main' panicked at /home/runner/check/batch_29/elliott10/lwext4_rust/build.rs:48:9:\n  assertion failed: status.success()\n  stack backtrace:\n     0:     0x5635ad83b9ea - std::backtrace_rs::backtrace::libunwind::trace::h392ec3763e4ee520\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/../../backtrace/src/backtrace/libunwind.rs:116:5\n     1:     0x5635ad83b9ea - std::backtrace_rs::backtrace::trace_unsynchronized::h52faccb7d9939779\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\n     2:     0x5635ad83b9ea - std::sys::backtrace::_print_fmt::h4ca48f886ab6d023\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/sys/backtrace.rs:66:9\n     3:     0x5635ad83b9ea - <std::sys::backtrace::BacktraceLock::print::DisplayBacktrace as core::fmt::Display>::fmt::h41650409cfcaa385\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/sys/backtrace.rs:39:26\n     4:     0x5635ad85c923 - core::fmt::rt::Argument::fmt::h3a0dfc0e2b206c6c\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/core/src/fmt/rt.rs:177:76\n     5:     0x5635ad85c923 - core::fmt::write::h124e50a41a614f35\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/core/src/fmt/mod.rs:1185:21\n     6:     0x5635ad838c73 - std::io::Write::write_fmt::h152c770d77d8200b\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/io/mod.rs:1887:15\n     7:     0x5635ad83b832 - std::sys::backtrace::BacktraceLock::print::hb77a071b09f7b2d4\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/sys/backtrace.rs:42:9\n     8:     0x5635ad83c7fd - std::panicking::default_hook::{{closure}}::h2289b310e8f70172\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panicking.rs:284:22\n     9:     0x5635ad83c642 - std::panicking::default_hook::h6b36901e2a542246\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panicking.rs:311:9\n    10:     0x5635ad83cdf7 - std::panicking::rust_panic_with_hook::hd7b2147b933d3e5b\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panicking.rs:817:13\n    11:     0x5635ad83cc56 - std::panicking::begin_panic_handler::{{closure}}::h529091dbfbeb0f88\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panicking.rs:683:13\n    12:     0x5635ad83bec9 - std::sys::backtrace::__rust_end_short_backtrace::h560f3f6f1bef32f3\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/sys/backtrace.rs:170:18\n    13:     0x5635ad83c91d - rust_begin_unwind\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panicking.rs:681:5\n    14:     0x5635ad85bb40 - core::panicking::panic_fmt::h0831c2ae5fe21ab8\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/core/src/panicking.rs:75:14\n    15:     0x5635ad85bbcc - core::panicking::panic::h8345ebad421281bc\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/core/src/panicking.rs:145:5\n    16:     0x5635ad812fb2 - build_script_build::main::h04097e89a6abc4ed\n                                 at /home/runner/check/batch_29/elliott10/lwext4_rust/build.rs:48:9\n    17:     0x5635ad80f59b - core::ops::function::FnOnce::call_once::h2f8a6764fd4f4518\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/core/src/ops/function.rs:250:5\n    18:     0x5635ad8144ee - std::sys::backtrace::__rust_begin_short_backtrace::h1bb50f93bb176fee\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/sys/backtrace.rs:154:18\n    19:     0x5635ad80eba1 - std::rt::lang_start::{{closure}}::h47e475a840d38e71\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/rt.rs:195:18\n    20:     0x5635ad835eb7 - core::ops::function::impls::<impl core::ops::function::FnOnce<A> for &F>::call_once::h35ac998e8377d702\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/core/src/ops/function.rs:284:13\n    21:     0x5635ad835eb7 - std::panicking::try::do_call::h375eb96a9ae157af\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panicking.rs:573:40\n    22:     0x5635ad835eb7 - std::panicking::try::h004dd624c2163121\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panicking.rs:536:19\n    23:     0x5635ad835eb7 - std::panic::catch_unwind::h86180637abc5e029\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panic.rs:358:14\n    24:     0x5635ad835eb7 - std::rt::lang_start_internal::{{closure}}::h423349aec7014c22\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/rt.rs:174:48\n    25:     0x5635ad835eb7 - std::panicking::try::do_call::h4e2bc89ab3a21ffc\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panicking.rs:573:40\n    26:     0x5635ad835eb7 - std::panicking::try::hd6b79a96186c0cd0\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panicking.rs:536:19\n    27:     0x5635ad835eb7 - std::panic::catch_unwind::h2450b06afb6527e0\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/panic.rs:358:14\n    28:     0x5635ad835eb7 - std::rt::lang_start_internal::he23058d2283a9650\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/rt.rs:174:20\n    29:     0x5635ad80eb7a - std::rt::lang_start::hd29483eca0b3edb3\n                                 at /rustc/7442931d49b199ad0a1cc0f8ca54e327b5139b66/library/std/src/rt.rs:194:17\n    30:     0x5635ad81385e - main\n    31:     0x7ff6c382a1ca - <unknown>\n    32:     0x7ff6c382a28b - __libc_start_main\n    33:     0x5635ad80db45 - _start\n    34:                0x0 - <unknown>\nwarning: build failed, waiting for other jobs to finish...\n"
    },
    {
      "cmd_idx": 23,
      "file": "(virtual) rapx",
      "kind": "Cargo",
      "raw": "// pkg_name=lwext4_rust_examples, checker=Rapx\n// toolchain=nightly-2024-01-31, target=riscv64gc-unknown-none-elf\n// features=\n// pkg_dir=/home/runner/check/batch_29/elliott10/lwext4_rust/examples\n// cmd=cargo +nightly-2024-10-12 rapx -F -M -- --target riscv64gc-unknown-none-elf \n// timestamp=2025-02-16 23:44:53.837693736 +08:00:00\nwarning: `/home/runner/check/batch_29/elliott10/lwext4_rust/examples/.cargo/config` is deprecated in favor of `config.toml`\nnote: if you need to support cargo 1.38 or earlier, you can symlink `config` to `config.toml`\nwarning: `/home/runner/check/batch_29/elliott10/lwext4_rust/examples/.cargo/config` is deprecated in favor of `config.toml`\nnote: if you need to support cargo 1.38 or earlier, you can symlink `config` to `config.toml`\nwarning: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.93\n   Compiling unicode-ident v1.0.16\n   Compiling autocfg v1.4.0\n    Checking memchr v2.7.4\n    Checking nb v1.1.0\n    Checking bitflags v1.3.2\n    Checking cty v0.2.2\n    Checking scopeguard v1.2.0\n    Checking log v0.4.25\n    Checking either v1.13.0\n    Checking cstr_core v0.2.6\n   Compiling lock_api v0.4.12\n    Checking itertools v0.9.0\n    Checking nb v0.1.3\n   Compiling lwext4_rust v0.2.0 (/home/runner/check/batch_29/elliott10/lwext4_rust)\n   Compiling quote v1.0.38\n   Compiling riscv v0.8.0\n   Compiling syn v2.0.98\n    Checking byteorder v1.5.0\n    Checking void v1.0.2\n    Checking spinning_top v0.2.5\n    Checking embedded-hal v0.2.7\n    Checking printf-compat v0.1.1\n    Checking bit_field v0.10.2\n    Checking spin v0.9.8\nerror: failed to run custom build command for `lwext4_rust v0.2.0 (/home/runner/check/batch_29/elliott10/lwext4_rust)`\n\nCaused by:\n  process didn't exit successfully: `/home/runner/check/batch_29/elliott10/lwext4_rust/examples/target/debug/build/lwext4_rust-f6d2545fa0e7dcc7/build-script-build` (exit status: 101)\n  --- stdout\n  make: Entering directory '/home/runner/check/batch_29/elliott10/lwext4_rust/c/lwext4'\n  rm -R -f build_musl-generic\n  mkdir build_musl-generic\n  cd build_musl-generic && cmake -G\"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release -DVERSION_MAJOR=1 -DVERSION_MINOR=0 -DVERSION_PATCH=0 -DVERSION=1.0.0-58bcf89 -DLWEXT4_BUILD_SHARED_LIB=OFF -DCMAKE_INSTALL_PREFIX=./install   -DCMAKE_TOOLCHAIN_FILE=../toolchain/musl-generic.cmake ..\n  -- The C compiler identification is unknown\n  -- Configuring incomplete, errors occurred!\n  make: Leaving directory '/home/runner/check/batch_29/elliott10/lwext4_rust/c/lwext4'\n\n  --- stderr\n  CMake Warning (dev) at CMakeLists.txt:1 (project):\n    cmake_minimum_required() should be called prior to this top-level project()\n    call.  Please see the cmake-commands(7) manual for usage documentation of\n    both commands.\n  This warning is for project developers.  Use -Wno-dev to suppress it.\n\n  CMake Error at CMakeLists.txt:1 (project):\n    The CMAKE_C_COMPILER:\n\n      riscv64-linux-musl-cc\n\n    is not a full path and was not found in the PATH.\n\n    Tell CMake where to find the compiler by setting either the environment\n    variable \"CC\" or the CMake cache entry CMAKE_C_COMPILER to the full path to\n    the compiler, or to the compiler name if it is in the PATH.\n\n\n  make: *** [Makefile:37: musl-generic] Error 1\n  thread 'main' panicked at /home/runner/check/batch_29/elliott10/lwext4_rust/build.rs:48:9:\n  assertion failed: status.success()\n  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nwarning: build failed, waiting for other jobs to finish...\n15:44:57|RAP|ERROR|: Finished with non-zero exit code.\n"
    }
  ]
}