{
  "repo": {
    "user": "elliott10",
    "repo": "fxmac_rs"
  },
  "data": [
    {
      "user": "elliott10",
      "repo": "fxmac_rs",
      "pkg": "fxmac_rs",
      "count": 493,
      "raw_reports": [
        {
          "file": "src/fxmac_dma.rs",
          "features": "",
          "count": 194,
          "kinds": {
            "Clippy(Warn)": [
              "warning: manually reimplementing `div_ceil`\n   --> src/fxmac_dma.rs:160:27\n    |\n160 |         let alloc_pages = (FXMAX_RX_BDSPACE_LENGTH + (PAGE_SIZE - 1)) / PAGE_SIZE;\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.div_ceil()`: `FXMAX_RX_BDSPACE_LENGTH.div_ceil(PAGE_SIZE)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_div_ceil\n    = note: `#[warn(clippy::manual_div_ceil)]` on by default\n\n",
              "warning: manually reimplementing `div_ceil`\n   --> src/fxmac_dma.rs:163:27\n    |\n163 |         let alloc_pages = (FXMAX_TX_BDSPACE_LENGTH + (PAGE_SIZE - 1)) / PAGE_SIZE;\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.div_ceil()`: `FXMAX_TX_BDSPACE_LENGTH.div_ceil(PAGE_SIZE)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_div_ceil\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:188:30\n    |\n188 |     trace!(\"fxmac_bd_read at {:#x}\", bd_ptr + offset as u64);\n    |                              ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:193:28\n    |\n193 |     debug!(\"fxmac_bd_write {:#x} to {:#x}\", data, bd_ptr + offset as u64);\n    |                            ^^^^^    ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:193:28\n    |\n193 |     debug!(\"fxmac_bd_write {:#x} to {:#x}\", data, bd_ptr + offset as u64);\n    |                            ^^^^^    ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:205:27\n    |\n205 |    info!(\"RX WRAP of BD @ {:#x} set {:#x} | FXMAC_RXBUF_WRAP_MASK\", bdptr, data_value_rx);\n    |                           ^^^^^     ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:205:27\n    |\n205 |    info!(\"RX WRAP of BD @ {:#x} set {:#x} | FXMAC_RXBUF_WRAP_MASK\", bdptr, data_value_rx);\n    |                           ^^^^^     ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:220:27\n    |\n220 |    info!(\"TX WRAP of BD @ {:#x} set {:#x} | TXBUF_WRAP\", bdptr, data_value_tx);\n    |                           ^^^^^     ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:220:27\n    |\n220 |    info!(\"TX WRAP of BD @ {:#x} set {:#x} | TXBUF_WRAP\", bdptr, data_value_tx);\n    |                           ^^^^^     ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:261:41\n    |\n261 |     trace!(\"FXMAC_RING_SEEKAHEAD, bdptr={:#x}\", *bdptr as u64);\n    |                                         ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:274:46\n    |\n274 |         trace!(\"FXMAC_RING_SEEKAHEAD, bdptr: {:#x}, addr: {:#x}\", *bdptr as u64, addr);\n    |                                              ^^^^^        ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:274:46\n    |\n274 |         trace!(\"FXMAC_RING_SEEKAHEAD, bdptr: {:#x}, addr: {:#x}\", *bdptr as u64, addr);\n    |                                              ^^^^^        ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: manually reimplementing `div_ceil`\n   --> src/fxmac_dma.rs:291:37\n    |\n291 |         let alloc_rx_buffer_pages = (max_frame_size as usize + (PAGE_SIZE - 1)) / PAGE_SIZE;\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.div_ceil()`: `(max_frame_size as usize).div_ceil(PAGE_SIZE)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_div_ceil\n\n",
              "warning: manually reimplementing `div_ceil`\n   --> src/fxmac_dma.rs:348:31\n    |\n348 |             let alloc_pages = (max_fr_size as usize + (PAGE_SIZE - 1)) / PAGE_SIZE;\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.div_ceil()`: `(max_fr_size as usize).div_ceil(PAGE_SIZE)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_div_ceil\n\n",
              "warning: casting to the same type is unnecessary (`usize` -> `usize`)\n   --> src/fxmac_dma.rs:352:57\n    |\n352 |             instance_p.lwipport.buffer.tx_pbufs_storage[index as usize] = tx_mbufs_vaddr as u64;\n    |                                                         ^^^^^^^^^^^^^^ help: try: `index`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:381:37\n    |\n381 |     info!(\"FXmacInitDma, rxringptr: {:p}\", rxringptr);\n    |                                     ^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:382:37\n    |\n382 |     info!(\"FXmacInitDma, txringptr: {:p}\", txringptr);\n    |                                     ^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:383:38\n    |\n383 |     info!(\"FXmacInitDma, rx_bdspace: {:#x}\", &instance_p.lwipport.buffer.rx_bdspace);\n    |                                      ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:384:38\n    |\n384 |     info!(\"FXmacInitDma, tx_bdspace: {:#x}\", &instance_p.lwipport.buffer.tx_bdspace);\n    |                                      ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this operation has no effect\n   --> src/fxmac_dma.rs:427:87\n    |\n427 |         write_reg((instance_p.config.base_address + FXMAC_TAIL_QUEUE(0)) as *mut u32, (1<<31) | 0);\n    |                                                                                       ^^^^^^^^^^^ help: consider reducing it to: `((1<<31))`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#identity_op\n    = note: `#[warn(clippy::identity_op)]` on by default\n\n",
              "warning: casting to the same type is unnecessary (`u64` -> `u64`)\n   --> src/fxmac_dma.rs:434:16\n    |\n434 |     ( (bdptr - ringptr.base_bd_addr as u64) / ringptr.separation as u64 ) as u32\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ringptr.base_bd_addr`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:483:59\n    |\n483 |     info!(\"FXmacBdRingCreate BDs count={}, separation={}, {:#x}~{:#x}\", bd_count, ring_ptr.separation, virt_addr, bd_virt_addr);\n    |                                                           ^^^^^ ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:483:59\n    |\n483 |     info!(\"FXmacBdRingCreate BDs count={}, separation={}, {:#x}~{:#x}\", bd_count, ring_ptr.separation, virt_addr, bd_virt_addr);\n    |                                                           ^^^^^ ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac_dma.rs:502:26\n    |\n502 |     ring_ptr.run_state = FXMAC_DMA_SG_IS_STOPED as u32;\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FXMAC_DMA_SG_IS_STOPED`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:520:53\n    |\n520 |         trace!(\"FXmacBdRingClone, copy current bd @ {:#x}\", cur_bd);\n    |                                                     ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:560:27\n    |\n560 |         debug!(\"free_head {:#x} seekahead to {:#x}\", b as usize, ring_ptr.free_head as usize);\n    |                           ^^^^^              ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_dma.rs:560:27\n    |\n560 |         debug!(\"free_head {:#x} seekahead to {:#x}\", b as usize, ring_ptr.free_head as usize);\n    |                           ^^^^^              ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:799:38\n    |\n799 |          warn!(\">>>>>>>>> TX PKT {} @{:#x} - {}\", pbufs_len, pbufs_virt, bdindex);\n    |                                      ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:801:27\n    |\n801 |         debug!(\">>>>>>>>> {:x?}\", pbuf);\n    |                           ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:867:26\n    |\n867 |     debug!(\"TX DMA DESC: {:#010x?}\", unsafe{*(txbdset as *const macb_dma_desc)});\n    |                          ^^^^^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:912:46\n    |\n912 |                 debug!(\"FXMAC_RXBUF_LEN_MASK={:#x}\", FXMAC_RXBUF_LEN_MASK);\n    |                                              ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:919:32\n    |\n919 |             debug!(\"RX PKT {} @{:#x} <<<<<<<<< - {}\", rx_bytes, pbufs_virt, bdindex);\n    |                                ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:922:27\n    |\n922 |             debug!(\"pbuf: {:x?}\", mbuf);\n    |                           ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_dma.rs:936:35\n    |\n936 |             debug!(\"hash_match is {:#x}\", hash_match);\n    |                                   ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: length comparison to zero\n   --> src/fxmac_dma.rs:961:8\n    |\n961 |     if recv_packets.len() > 0 {\n    |        ^^^^^^^^^^^^^^^^^^^^^^ help: using `!is_empty` is clearer and more explicit: `!recv_packets.is_empty()`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#len_zero\n    = note: `#[warn(clippy::len_zero)]` on by default\n\n",
              "warning: manually reimplementing `div_ceil`\n   --> src/fxmac_dma.rs:987:44\n    |\n987 |         let alloc_rx_buffer_pages: usize = (max_frame_size as usize + (PAGE_SIZE - 1)) / PAGE_SIZE;\n    |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.div_ceil()`: `(max_frame_size as usize).div_ceil(PAGE_SIZE)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_div_ceil\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n    --> src/fxmac_dma.rs:1000:34\n     |\n1000 |         trace!(\"SetupRxBds - {}: {:#010x?}\", bdindex, rx_macb_dma_desc);\n     |                                  ^^^^^^^^^\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: manual implementation of an assign operation\n    --> src/fxmac_dma.rs:1080:5\n     |\n1080 |     netctrlreg = netctrlreg & !FXMAC_NWCTRL_TXEN_MASK;\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `netctrlreg &= !FXMAC_NWCTRL_TXEN_MASK`\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\n\n",
              "warning: manual implementation of an assign operation\n    --> src/fxmac_dma.rs:1086:5\n     |\n1086 |     netctrlreg = netctrlreg | FXMAC_NWCTRL_TXEN_MASK;\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `netctrlreg |= FXMAC_NWCTRL_TXEN_MASK`\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\n\n",
              "warning: manually reimplementing `div_ceil`\n    --> src/fxmac_dma.rs:1114:25\n     |\n1114 |             let pages = (FXMAC_MAX_FRAME_SIZE as usize + (PAGE_SIZE - 1)) / PAGE_SIZE;\n     |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `.div_ceil()`: `(FXMAC_MAX_FRAME_SIZE as usize).div_ceil(PAGE_SIZE)`\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#manual_div_ceil\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n    --> src/fxmac_dma.rs:1140:47\n     |\n1140 |             trace!(\"FXmacProcessSentBds - {}: {:#010x?}\", bdindex, unsafe{*(curbdpntr as *const macb_dma_desc)});\n     |                                               ^^^^^^^^^\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n    --> src/fxmac_dma.rs:1214:42\n     |\n1214 |             error!(\"link status is error {:#x}\", link);\n     |                                          ^^^^^\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
            ],
            "Unformatted": [
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 2 to 2)\n-use core::ptr::{null_mut, null};\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 4 to 4)\n+use core::ptr::{null, null_mut};\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 6 to 7)\n-use alloc::boxed::Box;\n-use alloc::vec::Vec;\n+use crate::fxmac::*;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 10 to 10)\n-use crate::fxmac::*;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 12 to 12)\n+use alloc::boxed::Box;\n+use alloc::vec::Vec;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 20 to 20)\n-pub const FXMAX_MAX_HARDWARE_ADDRESS_LENGTH: usize =6;\n+pub const FXMAX_MAX_HARDWARE_ADDRESS_LENGTH: usize = 6;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 25 to 27)\n-pub const FXMAC_LWIP_PORT_CONFIG_COPY_ALL_FRAMES: u32 =BIT(2); /* enable copy all frames */\n-pub const FXMAC_LWIP_PORT_CONFIG_CLOSE_FCS_CHECK: u32 =BIT(3); /* close fcs check */\n-pub const FXMAC_LWIP_PORT_CONFIG_UNICAST_ADDRESS_FILITER: u32 =BIT(5); /* Allow unicast address filtering  */\n+pub const FXMAC_LWIP_PORT_CONFIG_COPY_ALL_FRAMES: u32 = BIT(2); /* enable copy all frames */\n+pub const FXMAC_LWIP_PORT_CONFIG_CLOSE_FCS_CHECK: u32 = BIT(3); /* close fcs check */\n+pub const FXMAC_LWIP_PORT_CONFIG_UNICAST_ADDRESS_FILITER: u32 = BIT(5); /* Allow unicast address filtering  */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 30 to 33)\n-pub const FXMAC_PHY_SPEED_10M: u32 =   10;\n-pub const FXMAC_PHY_SPEED_100M: u32 =   100;\n-pub const FXMAC_PHY_SPEED_1000M: u32 =   1000;\n-pub const FXMAC_PHY_SPEED_10G: u32 =   10000;\n+pub const FXMAC_PHY_SPEED_10M: u32 = 10;\n+pub const FXMAC_PHY_SPEED_100M: u32 = 100;\n+pub const FXMAC_PHY_SPEED_1000M: u32 = 1000;\n+pub const FXMAC_PHY_SPEED_10G: u32 = 10000;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 35 to 35)\n+pub const FXMAC_PHY_HALF_DUPLEX: u32 = 0;\n+pub const FXMAC_PHY_FULL_DUPLEX: u32 = 1;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 36 to 37)\n-pub const FXMAC_PHY_HALF_DUPLEX: u32 =  0;\n-pub const FXMAC_PHY_FULL_DUPLEX: u32 =  1;\n+pub const FXMAC_RECV_MAX_COUNT: u32 = 10;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 39 to 40)\n-pub const FXMAC_RECV_MAX_COUNT: u32 =10;\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 42 to 42)\n-pub const PQ_QUEUE_SIZE: u32 =4096;\n+pub const PQ_QUEUE_SIZE: u32 = 4096;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 53 to 53)\n-pub const FXMAC_RXBUF_NEW_MASK: u32 = 1<<0;\n+pub const FXMAC_RXBUF_NEW_MASK: u32 = 1 << 0;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 55 to 55)\n-pub const FXMAC_RXBUF_WRAP_MASK: u32 = 1<<1;\n+pub const FXMAC_RXBUF_WRAP_MASK: u32 = 1 << 1;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 61 to 61)\n-pub const FXMAC_TXBUF_USED_MASK: u32 = 1<<31;\n+pub const FXMAC_TXBUF_USED_MASK: u32 = 1 << 31;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 63 to 63)\n-pub const FXMAC_TXBUF_WRAP_MASK: u32 = 1<<30;\n+pub const FXMAC_TXBUF_WRAP_MASK: u32 = 1 << 30;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 69 to 69)\n-pub const BD_ALIGNMENT: u64 = FXMAC_DMABD_MINIMUM_ALIGNMENT*2; // 128\n+pub const BD_ALIGNMENT: u64 = FXMAC_DMABD_MINIMUM_ALIGNMENT * 2; // 128\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 146 to 147)\n-pub struct FXmacNetifBuffer\n-{\n+pub struct FXmacNetifBuffer {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 159 to 159)\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 161 to 161)\n-        let (mut rx_vaddr, mut rx_dma) = crate_interface::call_interface!(crate::KernelFunc::dma_alloc_coherent(alloc_pages));\n+        let (mut rx_vaddr, mut rx_dma) =\n+            crate_interface::call_interface!(crate::KernelFunc::dma_alloc_coherent(alloc_pages));\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 164 to 164)\n-        let (mut tx_vaddr, mut tx_dma) = crate_interface::call_interface!(crate::KernelFunc::dma_alloc_coherent(alloc_pages));\n+        let (mut tx_vaddr, mut tx_dma) =\n+            crate_interface::call_interface!(crate::KernelFunc::dma_alloc_coherent(alloc_pages));\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 177 to 178)\n-pub struct FXmacLwipPort\n-{\n+pub struct FXmacLwipPort {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 189 to 189)\n-    read_reg((crate_interface::call_interface!(crate::KernelFunc::virt_to_phys(bd_ptr as usize)) + offset as usize) as *const u32)\n+    read_reg(\n+        (crate_interface::call_interface!(crate::KernelFunc::virt_to_phys(bd_ptr as usize))\n+            + offset as usize) as *const u32,\n+    )\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 191 to 193)\n-pub fn fxmac_bd_write(bd_ptr: u64, offset: u32, data: u32)\n-{\n-    debug!(\"fxmac_bd_write {:#x} to {:#x}\", data, bd_ptr + offset as u64);\n+pub fn fxmac_bd_write(bd_ptr: u64, offset: u32, data: u32) {\n+    debug!(\n+        \"fxmac_bd_write {:#x} to {:#x}\",\n+        data,\n+        bd_ptr + offset as u64\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 195 to 195)\n-    write_reg((crate_interface::call_interface!(crate::KernelFunc::virt_to_phys(bd_ptr as usize)) + offset as usize) as *mut u32, data);\n+    write_reg(\n+        (crate_interface::call_interface!(crate::KernelFunc::virt_to_phys(bd_ptr as usize))\n+            + offset as usize) as *mut u32,\n+        data,\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 197 to 197)\n-    \n+\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 201 to 210)\n-   bdptr += FXMAC_BD_ADDR_OFFSET as u64;\n-   let temp_ptr = bdptr as *mut u32;\n-   if !temp_ptr.is_null() {\n-       let mut data_value_rx: u32 = unsafe{*temp_ptr};\n-   info!(\"RX WRAP of BD @ {:#x} set {:#x} | FXMAC_RXBUF_WRAP_MASK\", bdptr, data_value_rx);\n-       data_value_rx |= FXMAC_RXBUF_WRAP_MASK;\n-       unsafe {\n-        temp_ptr.write_volatile(data_value_rx);\n-       }\n-   }\n+    bdptr += FXMAC_BD_ADDR_OFFSET as u64;\n+    let temp_ptr = bdptr as *mut u32;\n+    if !temp_ptr.is_null() {\n+        let mut data_value_rx: u32 = unsafe { *temp_ptr };\n+        info!(\n+            \"RX WRAP of BD @ {:#x} set {:#x} | FXMAC_RXBUF_WRAP_MASK\",\n+            bdptr, data_value_rx\n+        );\n+        data_value_rx |= FXMAC_RXBUF_WRAP_MASK;\n+        unsafe {\n+            temp_ptr.write_volatile(data_value_rx);\n+        }\n+    }\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 216 to 225)\n-   bdptr += FXMAC_BD_STAT_OFFSET as u64;\n-   let temp_ptr = bdptr as *mut u32;\n-   if !temp_ptr.is_null() {\n-       let mut data_value_tx: u32 = unsafe{*temp_ptr};\n-   info!(\"TX WRAP of BD @ {:#x} set {:#x} | TXBUF_WRAP\", bdptr, data_value_tx);\n-       data_value_tx |= FXMAC_TXBUF_WRAP_MASK;\n-       unsafe {\n-        temp_ptr.write_volatile(data_value_tx);\n-       }\n-   }\n+    bdptr += FXMAC_BD_STAT_OFFSET as u64;\n+    let temp_ptr = bdptr as *mut u32;\n+    if !temp_ptr.is_null() {\n+        let mut data_value_tx: u32 = unsafe { *temp_ptr };\n+        info!(\n+            \"TX WRAP of BD @ {:#x} set {:#x} | TXBUF_WRAP\",\n+            bdptr, data_value_tx\n+        );\n+        data_value_tx |= FXMAC_TXBUF_WRAP_MASK;\n+        unsafe {\n+            temp_ptr.write_volatile(data_value_tx);\n+        }\n+    }\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 229 to 235)\n-fn FXmacBdringPtrReset(ring_ptr: &mut FXmacBdRing, virtaddrloc: *mut FXmacBd)\n-{\n-   ring_ptr.free_head = virtaddrloc;\n-   ring_ptr.pre_head = virtaddrloc;\n-   ring_ptr.hw_head = virtaddrloc;\n-   ring_ptr.hw_tail = virtaddrloc;\n-   ring_ptr.post_head = virtaddrloc;\n+fn FXmacBdringPtrReset(ring_ptr: &mut FXmacBdRing, virtaddrloc: *mut FXmacBd) {\n+    ring_ptr.free_head = virtaddrloc;\n+    ring_ptr.pre_head = virtaddrloc;\n+    ring_ptr.hw_head = virtaddrloc;\n+    ring_ptr.hw_tail = virtaddrloc;\n+    ring_ptr.post_head = virtaddrloc;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 240 to 244)\n-    fxmac_bd_write((bd_ptr), FXMAC_BD_ADDR_OFFSET,\n-                   ((fxmac_bd_read(bd_ptr, FXMAC_BD_ADDR_OFFSET) & !FXMAC_RXBUF_ADD_MASK) |\n-                    (addr & ULONG64_LO_MASK) as u32));\n-                    \n-    fxmac_bd_write(bd_ptr, FXMAC_BD_ADDR_HI_OFFSET, ((addr & ULONG64_HI_MASK) >> 32) as u32);\n+    fxmac_bd_write(\n+        (bd_ptr),\n+        FXMAC_BD_ADDR_OFFSET,\n+        ((fxmac_bd_read(bd_ptr, FXMAC_BD_ADDR_OFFSET) & !FXMAC_RXBUF_ADD_MASK)\n+            | (addr & ULONG64_LO_MASK) as u32),\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 246 to 246)\n+    fxmac_bd_write(\n+        bd_ptr,\n+        FXMAC_BD_ADDR_HI_OFFSET,\n+        ((addr & ULONG64_HI_MASK) >> 32) as u32,\n+    );\n+\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 251 to 253)\n-    fxmac_bd_write(bd_ptr, FXMAC_BD_ADDR_OFFSET, (addr & ULONG64_LO_MASK) as u32);\n-                   \n-    fxmac_bd_write(bd_ptr, FXMAC_BD_ADDR_HI_OFFSET, ((addr & ULONG64_HI_MASK) >> 32) as u32);\n+    fxmac_bd_write(\n+        bd_ptr,\n+        FXMAC_BD_ADDR_OFFSET,\n+        (addr & ULONG64_LO_MASK) as u32,\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 255 to 255)\n+    fxmac_bd_write(\n+        bd_ptr,\n+        FXMAC_BD_ADDR_HI_OFFSET,\n+        ((addr & ULONG64_HI_MASK) >> 32) as u32,\n+    );\n+\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 259 to 260)\n-fn FXMAC_RING_SEEKAHEAD(ring_ptr: &mut FXmacBdRing, bdptr: &mut (*mut FXmacBd), num_bd: u32)\n-{\n+fn FXMAC_RING_SEEKAHEAD(ring_ptr: &mut FXmacBdRing, bdptr: &mut (*mut FXmacBd), num_bd: u32) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 263 to 266)\n-        // 第一个free BD\n-        // bdptr = free_head\n-        let mut addr: u64 = *bdptr as u64;\n-        addr += (ring_ptr.separation * num_bd) as u64;\n+    // 第一个free BD\n+    // bdptr = free_head\n+    let mut addr: u64 = *bdptr as u64;\n+    addr += (ring_ptr.separation * num_bd) as u64;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 268 to 274)\n-        if (addr > ring_ptr.high_bd_addr) || (*bdptr as u64 > addr)\n-        {\n-            addr -= ring_ptr.length as u64;\n-        }\n-        *bdptr = addr as *mut FXmacBd;\n-        \n-        trace!(\"FXMAC_RING_SEEKAHEAD, bdptr: {:#x}, addr: {:#x}\", *bdptr as u64, addr);\n+    if (addr > ring_ptr.high_bd_addr) || (*bdptr as u64 > addr) {\n+        addr -= ring_ptr.length as u64;\n+    }\n+    *bdptr = addr as *mut FXmacBd;\n+\n+    trace!(\n+        \"FXMAC_RING_SEEKAHEAD, bdptr: {:#x}, addr: {:#x}\",\n+        *bdptr as u64, addr\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 286 to 289)\n-    for i in 0..FXMAX_RX_PBUFS_LENGTH\n-    {\n-        let max_frame_size = if (instance_p.lwipport.feature & FXMAC_LWIP_PORT_CONFIG_JUMBO) != 0\n-        { info!(\"FXMAC_LWIP_PORT_CONFIG_JUMBO\"); FXMAC_MAX_FRAME_SIZE_JUMBO } else { info!(\"NO CONFIG_JUMBO\"); FXMAC_MAX_FRAME_SIZE };\n+    for i in 0..FXMAX_RX_PBUFS_LENGTH {\n+        let max_frame_size = if (instance_p.lwipport.feature & FXMAC_LWIP_PORT_CONFIG_JUMBO) != 0 {\n+            info!(\"FXMAC_LWIP_PORT_CONFIG_JUMBO\");\n+            FXMAC_MAX_FRAME_SIZE_JUMBO\n+        } else {\n+            info!(\"NO CONFIG_JUMBO\");\n+            FXMAC_MAX_FRAME_SIZE\n+        };\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 292 to 293)\n-        let (mut rx_mbufs_vaddr, mut rx_mbufs_dma) = \n-        crate_interface::call_interface!(crate::KernelFunc::dma_alloc_coherent(alloc_rx_buffer_pages));\n+        let (mut rx_mbufs_vaddr, mut rx_mbufs_dma) = crate_interface::call_interface!(\n+            crate::KernelFunc::dma_alloc_coherent(alloc_rx_buffer_pages)\n+        );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 295 to 295)\n-    let rxringptr: &mut FXmacBdRing = &mut instance_p.rx_bd_queue.bdring;\n+        let rxringptr: &mut FXmacBdRing = &mut instance_p.rx_bd_queue.bdring;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 297 to 301)\n-//let my_speed: Box<i32> = Box::new(88);\n-//rxbd = Box::into_raw(my_speed);\n-// OR\n-//let mut my_speed: i32 = 88;\n-//rxbd = &mut my_speed;\n+        //let my_speed: Box<i32> = Box::new(88);\n+        //rxbd = Box::into_raw(my_speed);\n+        // OR\n+        //let mut my_speed: i32 = 88;\n+        //rxbd = &mut my_speed;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 306 to 307)\n-        if (status != 0)\n-        {\n+        if (status != 0) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 324 to 327)\n-        unsafe{\n-        temp.write_volatile(v);\n-        // Clear word 1 in  descriptor\n-        temp.add(1).write_volatile(0);\n+        unsafe {\n+            temp.write_volatile(v);\n+            // Clear word 1 in  descriptor\n+            temp.add(1).write_volatile(0);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 341 to 349)\n-        for index in  0..FXMAX_TX_PBUFS_LENGTH {\n-            let max_fr_size = if (instance_p.lwipport.feature & FXMAC_LWIP_PORT_CONFIG_JUMBO) != 0\n-            {\n-               FXMAC_MAX_FRAME_SIZE_JUMBO\n-            } else {\n-                FXMAC_MAX_FRAME_SIZE\n-            };\n-            let alloc_pages = (max_fr_size as usize + (PAGE_SIZE - 1)) / PAGE_SIZE;\n-            let (mut tx_mbufs_vaddr, mut tx_mbufs_dma) = \n+    for index in 0..FXMAX_TX_PBUFS_LENGTH {\n+        let max_fr_size = if (instance_p.lwipport.feature & FXMAC_LWIP_PORT_CONFIG_JUMBO) != 0 {\n+            FXMAC_MAX_FRAME_SIZE_JUMBO\n+        } else {\n+            FXMAC_MAX_FRAME_SIZE\n+        };\n+        let alloc_pages = (max_fr_size as usize + (PAGE_SIZE - 1)) / PAGE_SIZE;\n+        let (mut tx_mbufs_vaddr, mut tx_mbufs_dma) =\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 351 to 352)\n-    \n-            instance_p.lwipport.buffer.tx_pbufs_storage[index as usize] = tx_mbufs_vaddr as u64;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 354 to 357)\n-            /*\n-            let txbd: *mut FXmacBd = null_mut();\n-            FXmacBdRingAlloc(txringptr, 1, txbd);\n-            FXmacBdRingToHw(txringptr, 1, txbd);\n+        instance_p.lwipport.buffer.tx_pbufs_storage[index as usize] = tx_mbufs_vaddr as u64;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 359 to 361)\n-            let bdindex = FXMAC_BD_TO_INDEX(txringptr, txbd as u64);\n-            assert!(index == bdindex as usize);\n-            */\n+        /*\n+        let txbd: *mut FXmacBd = null_mut();\n+        FXmacBdRingAlloc(txringptr, 1, txbd);\n+        FXmacBdRingToHw(txringptr, 1, txbd);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 363 to 364)\n-            // From index to BD\n-            let txbd = (txringptr.base_bd_addr + (index as u64 * txringptr.separation as u64)) as *mut FXmacBd;\n+        let bdindex = FXMAC_BD_TO_INDEX(txringptr, txbd as u64);\n+        assert!(index == bdindex as usize);\n+        */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 366 to 367)\n-            fxmac_bd_set_address_tx(txbd as u64, tx_mbufs_dma as u64);\n-            //debug!(\"TX DMA DESC {}: {:#010x?}\", index, unsafe{*(txbd as *const macb_dma_desc)});\n+        // From index to BD\n+        let txbd =\n+            (txringptr.base_bd_addr + (index as u64 * txringptr.separation as u64)) as *mut FXmacBd;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 369 to 371)\n-            //curbdpntr = FXMAC_BD_RING_NEXT(txring, curbdpntr);\n-            crate::utils::DSB();\n-        }\n+        fxmac_bd_set_address_tx(txbd as u64, tx_mbufs_dma as u64);\n+        //debug!(\"TX DMA DESC {}: {:#010x?}\", index, unsafe{*(txbd as *const macb_dma_desc)});\n+\n+        //curbdpntr = FXMAC_BD_RING_NEXT(txring, curbdpntr);\n+        crate::utils::DSB();\n+    }\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 375 to 376)\n-pub fn FXmacInitDma(instance_p: &mut FXmac) -> u32\n-{\n+pub fn FXmacInitDma(instance_p: &mut FXmac) -> u32 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 383 to 384)\n-    info!(\"FXmacInitDma, rx_bdspace: {:#x}\", &instance_p.lwipport.buffer.rx_bdspace);\n-    info!(\"FXmacInitDma, tx_bdspace: {:#x}\", &instance_p.lwipport.buffer.tx_bdspace);\n+    info!(\n+        \"FXmacInitDma, rx_bdspace: {:#x}\",\n+        &instance_p.lwipport.buffer.rx_bdspace\n+    );\n+    info!(\n+        \"FXmacInitDma, tx_bdspace: {:#x}\",\n+        &instance_p.lwipport.buffer.tx_bdspace\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 395 to 395)\n-    let mut status: u32 = FXmacBdRingCreate(rxringptr, instance_p.lwipport.buffer.rx_bdspace as u64, instance_p.lwipport.buffer.rx_bdspace as u64, BD_ALIGNMENT, FXMAX_RX_PBUFS_LENGTH as u32);\n+    let mut status: u32 = FXmacBdRingCreate(\n+        rxringptr,\n+        instance_p.lwipport.buffer.rx_bdspace as u64,\n+        instance_p.lwipport.buffer.rx_bdspace as u64,\n+        BD_ALIGNMENT,\n+        FXMAX_RX_PBUFS_LENGTH as u32,\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 409 to 410)\n-    fxmac_bd_write((&bdtemplate as *const _ as u64), FXMAC_BD_STAT_OFFSET, \n-        fxmac_bd_read((&mut bdtemplate as *mut _ as u64), FXMAC_BD_STAT_OFFSET) | (FXMAC_TXBUF_USED_MASK));\n+    fxmac_bd_write(\n+        (&bdtemplate as *const _ as u64),\n+        FXMAC_BD_STAT_OFFSET,\n+        fxmac_bd_read((&mut bdtemplate as *mut _ as u64), FXMAC_BD_STAT_OFFSET)\n+            | (FXMAC_TXBUF_USED_MASK),\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 413 to 413)\n-    status = FXmacBdRingCreate(txringptr, instance_p.lwipport.buffer.tx_bdspace as u64, instance_p.lwipport.buffer.tx_bdspace as u64, BD_ALIGNMENT, FXMAX_TX_PBUFS_LENGTH as u32);\n+    status = FXmacBdRingCreate(\n+        txringptr,\n+        instance_p.lwipport.buffer.tx_bdspace as u64,\n+        instance_p.lwipport.buffer.tx_bdspace as u64,\n+        BD_ALIGNMENT,\n+        FXMAX_TX_PBUFS_LENGTH as u32,\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 423 to 423)\n-    \n+\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 425 to 427)\n-    if (instance_p.config.caps & FXMAC_CAPS_TAILPTR) != 0\n-    {   \n-        write_reg((instance_p.config.base_address + FXMAC_TAIL_QUEUE(0)) as *mut u32, (1<<31) | 0);\n+    if (instance_p.config.caps & FXMAC_CAPS_TAILPTR) != 0 {\n+        write_reg(\n+            (instance_p.config.base_address + FXMAC_TAIL_QUEUE(0)) as *mut u32,\n+            (1 << 31) | 0,\n+        );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 433 to 434)\n-fn FXMAC_BD_TO_INDEX (ringptr: &mut FXmacBdRing, bdptr: u64) -> u32 {\n-    ( (bdptr - ringptr.base_bd_addr as u64) / ringptr.separation as u64 ) as u32\n+fn FXMAC_BD_TO_INDEX(ringptr: &mut FXmacBdRing, bdptr: u64) -> u32 {\n+    ((bdptr - ringptr.base_bd_addr as u64) / ringptr.separation as u64) as u32\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 439 to 443)\n-        if bd_ptr as u64 >= ring_ptr.high_bd_addr {\n-            ring_ptr.base_bd_addr as *mut FXmacBd\n-        }else{\n-            (bd_ptr as u64 + ring_ptr.separation as u64) as *mut FXmacBd\n-        }\n+    if bd_ptr as u64 >= ring_ptr.high_bd_addr {\n+        ring_ptr.base_bd_addr as *mut FXmacBd\n+    } else {\n+        (bd_ptr as u64 + ring_ptr.separation as u64) as *mut FXmacBd\n+    }\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 448 to 449)\n-pub fn FXmacBdRingCreate(ring_ptr: &mut FXmacBdRing, phys_addr: u64, virt_addr: u64, alignment: u64, bd_count: u32) -> u32\n-    {\n+pub fn FXmacBdRingCreate(\n+    ring_ptr: &mut FXmacBdRing,\n+    phys_addr: u64,\n+    virt_addr: u64,\n+    alignment: u64,\n+    bd_count: u32,\n+) -> u32 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 452 to 454)\n-        // alignment=128, bd_count=128\n-       //let alignment = BD_ALIGNMENT;\n-       //let bd_count = FXMAX_RX_PBUFS_LENGTH;\n+    // alignment=128, bd_count=128\n+    //let alignment = BD_ALIGNMENT;\n+    //let bd_count = FXMAX_RX_PBUFS_LENGTH;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 456 to 457)\n-       //let virt_addr_loc = instance_p.buffer.rx_bdspace;\n-       let virt_addr_loc: u64 = virt_addr;\n+    //let virt_addr_loc = instance_p.buffer.rx_bdspace;\n+    let virt_addr_loc: u64 = virt_addr;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 459 to 463)\n- ring_ptr.all_cnt = 0;\n- ring_ptr.free_cnt = 0;\n- ring_ptr.hw_cnt = 0;\n- ring_ptr.pre_cnt = 0;\n- ring_ptr.post_cnt = 0;\n+    ring_ptr.all_cnt = 0;\n+    ring_ptr.free_cnt = 0;\n+    ring_ptr.hw_cnt = 0;\n+    ring_ptr.pre_cnt = 0;\n+    ring_ptr.post_cnt = 0;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 465 to 467)\n-       // 该地址必须对齐alignment=128\n-       assert!((virt_addr_loc % alignment) == 0);\n-       assert!(bd_count > 0);\n+    // 该地址必须对齐alignment=128\n+    assert!((virt_addr_loc % alignment) == 0);\n+    assert!(bd_count > 0);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 469 to 470)\n-       // 相邻BD之间隔多少bytes\n-       ring_ptr.separation = size_of::<FXmacBd>() as u32;\n+    // 相邻BD之间隔多少bytes\n+    ring_ptr.separation = size_of::<FXmacBd>() as u32;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 472 to 474)\n-// Initial ring setup:\n-//  - Clear the entire space\n-//  - Setup each BD's BDA field with the physical address of the next BD\n+    // Initial ring setup:\n+    //  - Clear the entire space\n+    //  - Setup each BD's BDA field with the physical address of the next BD\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 483 to 483)\n-    info!(\"FXmacBdRingCreate BDs count={}, separation={}, {:#x}~{:#x}\", bd_count, ring_ptr.separation, virt_addr, bd_virt_addr);\n+    info!(\n+        \"FXmacBdRingCreate BDs count={}, separation={}, {:#x}~{:#x}\",\n+        bd_count, ring_ptr.separation, virt_addr, bd_virt_addr\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 510 to 510)\n-    }\n+}\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 513 to 514)\n-pub fn FXmacBdRingClone(ring_ptr: &mut FXmacBdRing, src_bd_ptr: & FXmacBd, direction: u32) -> u32\n-{\n+pub fn FXmacBdRingClone(ring_ptr: &mut FXmacBdRing, src_bd_ptr: &FXmacBd, direction: u32) -> u32 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 540 to 540)\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 542 to 546)\n-pub fn FXmacBdRingAlloc(ring_ptr: &mut FXmacBdRing, num_bd: u32, bd_set_ptr: &mut(*mut FXmacBd)) -> u32 {\n-/*\n-let num_bd = 1;\n-let bd_set_ptr = &rxbd;\n-*/\n+pub fn FXmacBdRingAlloc(\n+    ring_ptr: &mut FXmacBdRing,\n+    num_bd: u32,\n+    bd_set_ptr: &mut (*mut FXmacBd),\n+) -> u32 {\n+    /*\n+    let num_bd = 1;\n+    let bd_set_ptr = &rxbd;\n+    */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 554 to 554)\n-        \n+\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 560 to 560)\n-        debug!(\"free_head {:#x} seekahead to {:#x}\", b as usize, ring_ptr.free_head as usize);\n+        debug!(\n+            \"free_head {:#x} seekahead to {:#x}\",\n+            b as usize, ring_ptr.free_head as usize\n+        );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 570 to 570)\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 591 to 592)\n-pub fn FXmacBdRingFromHwRx(ring_ptr: &mut FXmacBdRing, bd_limit: usize, bd_set_ptr: &mut (*mut FXmacBd)) -> u32 {\n-\n+pub fn FXmacBdRingFromHwRx(\n+    ring_ptr: &mut FXmacBdRing,\n+    bd_limit: usize,\n+    bd_set_ptr: &mut (*mut FXmacBd),\n+) -> u32 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 603 to 603)\n-        \n+\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 605 to 606)\n-    }else{\n-         /* Starting at hw_head, keep moving forward in the list until:\n+    } else {\n+        /* Starting at hw_head, keep moving forward in the list until:\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 612 to 612)\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 618 to 618)\n-            let bd_rx_new = fxmac_bd_read(cur_bd_ptr as u64, FXMAC_BD_ADDR_OFFSET) & FXMAC_RXBUF_NEW_MASK;\n+            let bd_rx_new =\n+                fxmac_bd_read(cur_bd_ptr as u64, FXMAC_BD_ADDR_OFFSET) & FXMAC_RXBUF_NEW_MASK;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 632 to 632)\n+            } else {\n+                bd_partial_count += 1;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 633 to 636)\n-            else\n-            {\n-                bd_partial_count+=1;\n-            }\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 640 to 640)\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 655 to 655)\n-    let mut hw_head_t = ring_ptr.hw_head;\n+            let mut hw_head_t = ring_ptr.hw_head;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 671 to 671)\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 677 to 677)\n-pub fn FXmacBdRingFromHwTx(ring_ptr: &mut FXmacBdRing, bd_limit: usize, bd_set_ptr: &mut(*mut FXmacBd)) -> u32 {\n+pub fn FXmacBdRingFromHwTx(\n+    ring_ptr: &mut FXmacBdRing,\n+    bd_limit: usize,\n+    bd_set_ptr: &mut (*mut FXmacBd),\n+) -> u32 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 687 to 688)\n-    if ring_ptr.hw_cnt == 0\n-    {\n+    if ring_ptr.hw_cnt == 0 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 693 to 695)\n-\n-        if bd_limitLoc > ring_ptr.hw_cnt\n-        {\n+        if bd_limitLoc > ring_ptr.hw_cnt {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 706 to 706)\n-                bd_str = fxmac_bd_read(cur_bd_ptr as u64, FXMAC_BD_STAT_OFFSET);\n+            bd_str = fxmac_bd_read(cur_bd_ptr as u64, FXMAC_BD_STAT_OFFSET);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 710 to 711)\n-            if (bd_str & FXMAC_TXBUF_USED_MASK) != 0\n-            {\n+            if (bd_str & FXMAC_TXBUF_USED_MASK) != 0 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 721 to 722)\n-            if (bd_str & FXMAC_TXBUF_LAST_MASK) != 0\n-            {\n+            if (bd_str & FXMAC_TXBUF_LAST_MASK) != 0 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 784 to 786)\n-   \n-        if (instance_p.lwipport.feature & FXMAC_LWIP_PORT_CONFIG_JUMBO) != 0\n-        {\n+\n+        if (instance_p.lwipport.feature & FXMAC_LWIP_PORT_CONFIG_JUMBO) != 0 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 788 to 790)\n-        }\n-        else\n-        {\n+        } else {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 799 to 799)\n-         warn!(\">>>>>>>>> TX PKT {} @{:#x} - {}\", pbufs_len, pbufs_virt, bdindex);\n+        warn!(\n+            \">>>>>>>>> TX PKT {} @{:#x} - {}\",\n+            pbufs_len, pbufs_virt, bdindex\n+        );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 806 to 807)\n-        if q.len() > max_fr_size as usize\n-        {\n+        if q.len() > max_fr_size as usize {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 811 to 812)\n-            fxmac_bd_write(txbd as u64, FXMAC_BD_STAT_OFFSET,\n-                ((fxmac_bd_read(txbd as u64, FXMAC_BD_STAT_OFFSET) & !FXMAC_TXBUF_LEN_MASK) | (max_fr_size & 0x3FFF)));\n+            fxmac_bd_write(\n+                txbd as u64,\n+                FXMAC_BD_STAT_OFFSET,\n+                ((fxmac_bd_read(txbd as u64, FXMAC_BD_STAT_OFFSET) & !FXMAC_TXBUF_LEN_MASK)\n+                    | (max_fr_size & 0x3FFF)),\n+            );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 814 to 815)\n-        fxmac_bd_write(txbd as u64, FXMAC_BD_STAT_OFFSET,\n-            ((fxmac_bd_read(txbd as u64, FXMAC_BD_STAT_OFFSET) & !FXMAC_TXBUF_LEN_MASK) | (q.len() as u32 & 0x3FFF)));\n+            fxmac_bd_write(\n+                txbd as u64,\n+                FXMAC_BD_STAT_OFFSET,\n+                ((fxmac_bd_read(txbd as u64, FXMAC_BD_STAT_OFFSET) & !FXMAC_TXBUF_LEN_MASK)\n+                    | (q.len() as u32 & 0x3FFF)),\n+            );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 827 to 828)\n-        fxmac_bd_write(t_txbd, FXMAC_BD_STAT_OFFSET,\n-            fxmac_bd_read(t_txbd, FXMAC_BD_STAT_OFFSET) & !FXMAC_TXBUF_LAST_MASK );\n+        fxmac_bd_write(\n+            t_txbd,\n+            FXMAC_BD_STAT_OFFSET,\n+            fxmac_bd_read(t_txbd, FXMAC_BD_STAT_OFFSET) & !FXMAC_TXBUF_LAST_MASK,\n+        );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 835 to 836)\n-    fxmac_bd_write(t_txbd, FXMAC_BD_STAT_OFFSET,\n-        fxmac_bd_read(t_txbd, FXMAC_BD_STAT_OFFSET) | FXMAC_TXBUF_LAST_MASK );\n+    fxmac_bd_write(\n+        t_txbd,\n+        FXMAC_BD_STAT_OFFSET,\n+        fxmac_bd_read(t_txbd, FXMAC_BD_STAT_OFFSET) | FXMAC_TXBUF_LAST_MASK,\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 841 to 843)\n-    if (instance_p.config.caps & FXMAC_CAPS_TAILPTR) != 0\n-    {\n-         bdindex = FXMAC_BD_TO_INDEX(txring, txbd as u64);\n+    if (instance_p.config.caps & FXMAC_CAPS_TAILPTR) != 0 {\n+        bdindex = FXMAC_BD_TO_INDEX(txring, txbd as u64);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 848 to 849)\n-    let FXMAC_BD_CLEAR_TX_USED = |bd_ptr: u64|\n-            fxmac_bd_write(bd_ptr, FXMAC_BD_STAT_OFFSET, fxmac_bd_read(bd_ptr, FXMAC_BD_STAT_OFFSET) & (!FXMAC_TXBUF_USED_MASK));\n+    let FXMAC_BD_CLEAR_TX_USED = |bd_ptr: u64| {\n+        fxmac_bd_write(\n+            bd_ptr,\n+            FXMAC_BD_STAT_OFFSET,\n+            fxmac_bd_read(bd_ptr, FXMAC_BD_STAT_OFFSET) & (!FXMAC_TXBUF_USED_MASK),\n+        )\n+    };\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 862 to 864)\n-    if (instance_p.config.caps & FXMAC_CAPS_TAILPTR) != 0\n-    {   \n-        write_reg((instance_p.config.base_address + FXMAC_TAIL_QUEUE(0)) as *mut u32, (1 << 31) | bdindex);\n+    if (instance_p.config.caps & FXMAC_CAPS_TAILPTR) != 0 {\n+        write_reg(\n+            (instance_p.config.base_address + FXMAC_TAIL_QUEUE(0)) as *mut u32,\n+            (1 << 31) | bdindex,\n+        );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 867 to 867)\n-    debug!(\"TX DMA DESC: {:#010x?}\", unsafe{*(txbdset as *const macb_dma_desc)});\n+    debug!(\"TX DMA DESC: {:#010x?}\", unsafe {\n+        *(txbdset as *const macb_dma_desc)\n+    });\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 870 to 871)\n-    let value = read_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32) | FXMAC_NWCTRL_STARTTX_MASK;\n-    write_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32, value);\n+    let value = read_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32)\n+        | FXMAC_NWCTRL_STARTTX_MASK;\n+    write_reg(\n+        (instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32,\n+        value,\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 885 to 885)\n-     to handle the processed BDs and then raise the according flag.*/\n+    to handle the processed BDs and then raise the according flag.*/\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 887 to 887)\n-    write_reg((instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *mut u32, regval);\n+    write_reg(\n+        (instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *mut u32,\n+        regval,\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 891 to 893)\n-        let bd_processed: u32 = FXmacBdRingFromHwRx(&mut instance_p.rx_bd_queue.bdring, FXMAX_RX_PBUFS_LENGTH, &mut rxbdset);\n-        if bd_processed == 0\n-        {\n+        let bd_processed: u32 = FXmacBdRingFromHwRx(\n+            &mut instance_p.rx_bd_queue.bdring,\n+            FXMAX_RX_PBUFS_LENGTH,\n+            &mut rxbdset,\n+        );\n+        if bd_processed == 0 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 901 to 901)\n+            let rxring: &mut FXmacBdRing = &mut instance_p.rx_bd_queue.bdring;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 902 to 903)\n-    let rxring: &mut FXmacBdRing = &mut instance_p.rx_bd_queue.bdring;\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 905 to 906)\n-            let rx_bytes: u32 =\n-            if (instance_p.lwipport.feature & FXMAC_LWIP_PORT_CONFIG_JUMBO) != 0\n+            let rx_bytes: u32 = if (instance_p.lwipport.feature & FXMAC_LWIP_PORT_CONFIG_JUMBO) != 0\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 910 to 910)\n-           \n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 919 to 919)\n-            debug!(\"RX PKT {} @{:#x} <<<<<<<<< - {}\", rx_bytes, pbufs_virt, bdindex);\n+            debug!(\n+                \"RX PKT {} @{:#x} <<<<<<<<< - {}\",\n+                rx_bytes, pbufs_virt, bdindex\n+            );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 927 to 935)\n-           /*  \n-            The value of hash_match indicates the hash result of the received packet \n-               0: No hash match \n-               1: Unicast hash match \n-               2: Multicast hash match\n-               3: Reserved, the value is not legal\n-           */\n-           // FXMAC_BD_GET_HASH_MATCH(bd_ptr)\n-            let mut hash_match: u32 = (fxmac_bd_read(curbdptr as u64, FXMAC_BD_STAT_OFFSET) & FXMAC_RXBUF_HASH_MASK) >> 29;\n+            /*\n+             The value of hash_match indicates the hash result of the received packet\n+                0: No hash match\n+                1: Unicast hash match\n+                2: Multicast hash match\n+                3: Reserved, the value is not legal\n+            */\n+            // FXMAC_BD_GET_HASH_MATCH(bd_ptr)\n+            let mut hash_match: u32 = (fxmac_bd_read(curbdptr as u64, FXMAC_BD_STAT_OFFSET)\n+                & FXMAC_RXBUF_HASH_MASK)\n+                >> 29;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 937 to 937)\n-    \n+\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 940 to 940)\n-            crate::utils::FCacheDCacheInvalidateRange(instance_p.lwipport.buffer.rx_pbufs_storage[bdindex as usize], rx_bytes as u64);\n+            crate::utils::FCacheDCacheInvalidateRange(\n+                instance_p.lwipport.buffer.rx_pbufs_storage[bdindex as usize],\n+                rx_bytes as u64,\n+            );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 999 to 999)\n-        let rx_macb_dma_desc = unsafe{(rxbd as *const macb_dma_desc).read_volatile()};\n+        let rx_macb_dma_desc = unsafe { (rxbd as *const macb_dma_desc).read_volatile() };\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1007 to 1007)\n-        \n+\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1010 to 1011)\n-        temp.add(1).write_volatile(0); // clear rx ctl\n-        temp.write_volatile(v); // set rx addr\n+            temp.add(1).write_volatile(0); // clear rx ctl\n+            temp.write_volatile(v); // set rx addr\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1025 to 1025)\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1037 to 1037)\n-        \n+\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1043 to 1044)\n-pub fn ResetDma(instance_p: &mut FXmac)\n-{\n+pub fn ResetDma(instance_p: &mut FXmac) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1050 to 1051)\n-    FXmacBdringPtrReset(txringptr, instance_p.lwipport.buffer.tx_bdspace as *mut FXmacBd);\n-    FXmacBdringPtrReset(rxringptr, instance_p.lwipport.buffer.rx_bdspace as *mut FXmacBd);\n+    FXmacBdringPtrReset(\n+        txringptr,\n+        instance_p.lwipport.buffer.tx_bdspace as *mut FXmacBd,\n+    );\n+    FXmacBdringPtrReset(\n+        rxringptr,\n+        instance_p.lwipport.buffer.rx_bdspace as *mut FXmacBd,\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1058 to 1059)\n-pub fn FXmacHandleDmaTxError(instance_p: &mut FXmac)\n-{\n+pub fn FXmacHandleDmaTxError(instance_p: &mut FXmac) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1077 to 1079)\n-pub fn FXmacHandleTxErrors(instance_p: &mut FXmac)\n-{\n-    let mut netctrlreg: u32 = read_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32);\n+pub fn FXmacHandleTxErrors(instance_p: &mut FXmac) {\n+    let mut netctrlreg: u32 =\n+        read_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1081 to 1081)\n-    write_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32, netctrlreg);\n+    write_reg(\n+        (instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32,\n+        netctrlreg,\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1087 to 1087)\n-    write_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32, netctrlreg);\n+    write_reg(\n+        (instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32,\n+        netctrlreg,\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1090 to 1091)\n-fn CleanDmaTxdescs(instance_p: &mut FXmac)\n-{\n+fn CleanDmaTxdescs(instance_p: &mut FXmac) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1098 to 1099)\n-    fxmac_bd_write((&mut bdtemplate as *mut _ as u64), FXMAC_BD_STAT_OFFSET, \n-        fxmac_bd_read((&mut bdtemplate as *mut _ as u64), FXMAC_BD_STAT_OFFSET) | (FXMAC_TXBUF_USED_MASK));\n+    fxmac_bd_write(\n+        (&mut bdtemplate as *mut _ as u64),\n+        FXMAC_BD_STAT_OFFSET,\n+        fxmac_bd_read((&mut bdtemplate as *mut _ as u64), FXMAC_BD_STAT_OFFSET)\n+            | (FXMAC_TXBUF_USED_MASK),\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1102 to 1102)\n-    FXmacBdRingCreate(txringptr, tx_bdspace_ptr, tx_bdspace_ptr, BD_ALIGNMENT, FXMAX_TX_BDSPACE_LENGTH as u32);\n+    FXmacBdRingCreate(\n+        txringptr,\n+        tx_bdspace_ptr,\n+        tx_bdspace_ptr,\n+        BD_ALIGNMENT,\n+        FXMAX_TX_BDSPACE_LENGTH as u32,\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1106 to 1107)\n-fn FreeOnlyTxPbufs(instance_p: &mut FXmac)\n-{\n+fn FreeOnlyTxPbufs(instance_p: &mut FXmac) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1109 to 1112)\n-    for index in  0..FXMAX_TX_PBUFS_LENGTH\n-    {\n-        if (instance_p.lwipport.buffer.tx_pbufs_storage[index] != 0)\n-        {\n+    for index in 0..FXMAX_TX_PBUFS_LENGTH {\n+        if (instance_p.lwipport.buffer.tx_pbufs_storage[index] != 0) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1115 to 1115)\n-            crate_interface::call_interface!(crate::KernelFunc::dma_free_coherent(pbuf as usize, pages));\n+            crate_interface::call_interface!(crate::KernelFunc::dma_free_coherent(\n+                pbuf as usize,\n+                pages\n+            ));\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1123 to 1124)\n-pub fn FXmacProcessSentBds(instance_p: &mut FXmac)\n-{\n+pub fn FXmacProcessSentBds(instance_p: &mut FXmac) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1140 to 1140)\n-            trace!(\"FXmacProcessSentBds - {}: {:#010x?}\", bdindex, unsafe{*(curbdpntr as *const macb_dma_desc)});\n+            trace!(\"FXmacProcessSentBds - {}: {:#010x?}\", bdindex, unsafe {\n+                *(curbdpntr as *const macb_dma_desc)\n+            });\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1150 to 1152)\n-            unsafe{\n-            //temp.write_volatile(0); // 这里不再对dma buffer地址清0\n-            temp.add(1).write_volatile(v); // 设置dma desc的ctrl\n+            unsafe {\n+                //temp.write_volatile(0); // 这里不再对dma buffer地址清0\n+                temp.add(1).write_volatile(v); // 设置dma desc的ctrl\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1178 to 1179)\n-pub fn FXmacSendHandler(instance: &mut FXmac)\n-{\n+pub fn FXmacSendHandler(instance: &mut FXmac) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1185 to 1185)\n-    write_reg((instance.config.base_address + FXMAC_TXSR_OFFSET) as *mut u32, regval);\n+    write_reg(\n+        (instance.config.base_address + FXMAC_TXSR_OFFSET) as *mut u32,\n+        regval,\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1192 to 1193)\n-pub fn FXmacLinkChange(instance: &mut FXmac)\n-{\n+pub fn FXmacLinkChange(instance: &mut FXmac) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1196 to 1197)\n-    if instance.config.interface == FXmacPhyInterface::FXMAC_PHY_INTERFACE_MODE_SGMII\n-    {\n+    if instance.config.interface == FXmacPhyInterface::FXMAC_PHY_INTERFACE_MODE_SGMII {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1201 to 1202)\n-        let ctrl: u32 = read_reg((instance.config.base_address + FXMAC_PCS_AN_LP_OFFSET) as *const u32);\n-        let link: u32 = (ctrl & FXMAC_PCS_LINK_PARTNER_NEXT_PAGE_STATUS) >> FXMAC_PCS_LINK_PARTNER_NEXT_PAGE_OFFSET;\n+        let ctrl: u32 =\n+            read_reg((instance.config.base_address + FXMAC_PCS_AN_LP_OFFSET) as *const u32);\n+        let link: u32 = (ctrl & FXMAC_PCS_LINK_PARTNER_NEXT_PAGE_STATUS)\n+            >> FXMAC_PCS_LINK_PARTNER_NEXT_PAGE_OFFSET;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1205 to 1207)\n-         0 => {\n-            info!(\"link status is down\");\n-            link_status = FXMAC_LINKDOWN;\n+            0 => {\n+                info!(\"link status is down\");\n+                link_status = FXMAC_LINKDOWN;\n+            }\n+            1 => {\n+                info!(\"link status is up\");\n+                link_status = FXMAC_LINKUP;\n+            }\n+            _ => {\n+                error!(\"link status is error {:#x}\", link);\n+            }\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1209 to 1216)\n-         1 => {\n-            info!(\"link status is up\");\n-            link_status = FXMAC_LINKUP;\n-        }\n-        _ => {\n-            error!(\"link status is error {:#x}\", link);\n-        }\n-    }\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1218 to 1221)\n-        if link_status == FXMAC_LINKUP\n-        {\n-            if link_status != instance.link_status\n-            {\n+        if link_status == FXMAC_LINKUP {\n+            if link_status != instance.link_status {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1225 to 1227)\n-        }\n-        else\n-        {\n+        } else {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1243 to 1244)\n-pub fn phy_link_detect(xmac_p: &mut FXmac, phy_addr: u32) -> u32\n-{\n+pub fn phy_link_detect(xmac_p: &mut FXmac, phy_addr: u32) -> u32 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1257 to 1258)\n-pub fn phy_autoneg_status(xmac_p: &mut FXmac, phy_addr: u32) -> u32\n-{\n+pub fn phy_autoneg_status(xmac_p: &mut FXmac, phy_addr: u32) -> u32 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1264 to 1264)\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1278 to 1278)\n-    if freecnt <= 4 { //5\n+    if freecnt <= 4 {\n+        //5\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1285 to 1285)\n-    }else{\n+    } else {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1291 to 1295)\n-pub fn ethernetif_input_to_recv_packets(instance_p: &mut FXmac)\n-{\n-    if(instance_p.lwipport.recv_flg > 0)\n-    {\n-      info!(\"ethernetif_input_to_recv_packets, fxmac_port->recv_flg={}\", instance_p.lwipport.recv_flg);\n+pub fn ethernetif_input_to_recv_packets(instance_p: &mut FXmac) {\n+    if (instance_p.lwipport.recv_flg > 0) {\n+        info!(\n+            \"ethernetif_input_to_recv_packets, fxmac_port->recv_flg={}\",\n+            instance_p.lwipport.recv_flg\n+        );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1297 to 1298)\n-      // 也许需要屏蔽中断的临界区来保护\n-      instance_p.lwipport.recv_flg -= 1;\n+        // 也许需要屏蔽中断的临界区来保护\n+        instance_p.lwipport.recv_flg -= 1;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1300 to 1301)\n-      // 开中断\n-      write_reg((instance_p.config.base_address + FXMAC_IER_OFFSET) as *mut u32, instance_p.mask);\n+        // 开中断\n+        write_reg(\n+            (instance_p.config.base_address + FXMAC_IER_OFFSET) as *mut u32,\n+            instance_p.mask,\n+        );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1303 to 1304)\n-      // 若需要中断处理函数中来接收包，可以这里解注释\n-      //FXmacRecvHandler(instance_p);\n+        // 若需要中断处理函数中来接收包，可以这里解注释\n+        //FXmacRecvHandler(instance_p);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_dma.rs (original lines from 1314 to 1314)\n+\n"
            ]
          }
        },
        {
          "file": "src/fxmac_const.rs",
          "features": "",
          "count": 114,
          "kinds": {
            "Clippy(Warn)": [
              "warning: casting integer literal to `u64` is unnecessary\n   --> src/fxmac_const.rs:538:7\n    |\n538 |     (!(0 as u64) - (1 << l) + 1) &\n    |       ^^^^^^^^^^ help: try: `0_u64`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n    = note: `#[warn(clippy::unnecessary_cast)]` on by default\n\n",
              "warning: casting integer literal to `u64` is unnecessary\n   --> src/fxmac_const.rs:539:8\n    |\n539 |      (!(0 as u64) >> (BITS_PER_LONG - 1 - h))\n    |        ^^^^^^^^^^ help: try: `0_u64`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
            ],
            "Unformatted": [
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 4 to 4)\n-pub(crate) const FXMAC_RX_BUF_UNIT:u32 = 64; /* Number of receive buffer bytes as a unit, this is HW setup */\n+pub(crate) const FXMAC_RX_BUF_UNIT: u32 = 64; /* Number of receive buffer bytes as a unit, this is HW setup */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 6 to 7)\n-pub(crate) const FXMAC_MAX_RXBD:u32 = 128;/* Size of RX buffer descriptor queues */\n-pub(crate) const FXMAC_MAX_TXBD:u32 = 128;/* Size of TX buffer descriptor queues */\n+pub(crate) const FXMAC_MAX_RXBD: u32 = 128; /* Size of RX buffer descriptor queues */\n+pub(crate) const FXMAC_MAX_TXBD: u32 = 128; /* Size of TX buffer descriptor queues */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 9 to 9)\n-pub(crate) const FXMAC_MAX_HASH_BITS:u32 = 64;/* Maximum value for hash bits. 2**6 */\n+pub(crate) const FXMAC_MAX_HASH_BITS: u32 = 64; /* Maximum value for hash bits. 2**6 */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 13 to 14)\n-pub(crate) const FXMAC_MAX_MAC_ADDR:u32 = 4;/* Maxmum number of mac address supported */\n-pub(crate) const FXMAC_MAX_TYPE_ID:u32 = 4; /* Maxmum number of type id supported */\n+pub(crate) const FXMAC_MAX_MAC_ADDR: u32 = 4; /* Maxmum number of mac address supported */\n+pub(crate) const FXMAC_MAX_TYPE_ID: u32 = 4; /* Maxmum number of type id supported */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 17 to 17)\n-pub(crate) const FXMAC_BD_ALIGNMENT:u32 = 64;/* Minimum buffer descriptor alignment on the local bus */\n+pub(crate) const FXMAC_BD_ALIGNMENT: u32 = 64; /* Minimum buffer descriptor alignment on the local bus */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 19 to 19)\n+pub(crate) const FXMAC_RX_BUF_ALIGNMENT: u32 = 4; /* Minimum buffer alignment when using options that impose \n+alignment  restrictions on the buffer data on the local bus */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 20 to 21)\n-pub(crate) const FXMAC_RX_BUF_ALIGNMENT:u32 = 4;/* Minimum buffer alignment when using options that impose \n-                                    alignment  restrictions on the buffer data on the local bus */\n+pub(crate) const FXMAC_NWCTRL_OFFSET: u64 = 0x00000000; /* Network Control reg */\n+pub(crate) const FXMAC_NWCFG_OFFSET: u64 = 0x00000004; /* Network Config reg */\n+pub(crate) const FXMAC_NWSR_OFFSET: u64 = 0x00000008; /* Network Status reg */\n+pub(crate) const FXMAC_DMACR_OFFSET: u64 = 0x00000010; /* DMA Control reg */\n+pub(crate) const FXMAC_TXSR_OFFSET: u64 = 0x00000014; /* TX Status reg */\n+pub(crate) const FXMAC_RXQBASE_OFFSET: u64 = 0x00000018; /* RX Q Base address reg */\n+pub(crate) const FXMAC_TXQBASE_OFFSET: u64 = 0x0000001C; /* TX Q Base address reg */\n+pub(crate) const FXMAC_RXSR_OFFSET: u64 = 0x00000020; /* RX Status reg */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 23 to 30)\n-pub(crate) const FXMAC_NWCTRL_OFFSET:u64 = 0x00000000; /* Network Control reg */\n-pub(crate) const FXMAC_NWCFG_OFFSET:u64 = 0x00000004;  /* Network Config reg */\n-pub(crate) const FXMAC_NWSR_OFFSET:u64 = 0x00000008;   /* Network Status reg */\n-pub(crate) const FXMAC_DMACR_OFFSET:u64 = 0x00000010;  /* DMA Control reg */\n-pub(crate) const FXMAC_TXSR_OFFSET:u64 = 0x00000014;   /* TX Status reg */\n-pub(crate) const FXMAC_RXQBASE_OFFSET:u64 = 0x00000018;/* RX Q Base address reg */\n-pub(crate) const FXMAC_TXQBASE_OFFSET:u64 = 0x0000001C;/* TX Q Base address reg */\n-pub(crate) const FXMAC_RXSR_OFFSET:u64 = 0x00000020;   /* RX Status reg */\n+pub(crate) const FXMAC_ISR_OFFSET: u64 = 0x00000024; /* Interrupt Status reg */\n+pub(crate) const FXMAC_IER_OFFSET: u64 = 0x00000028; /* Interrupt Enable reg */\n+pub(crate) const FXMAC_IDR_OFFSET: u64 = 0x0000002C; /* Interrupt Disable reg */\n+pub(crate) const FXMAC_IMR_OFFSET: u64 = 0x00000030; /* Interrupt Mask reg */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 32 to 35)\n-pub(crate) const FXMAC_ISR_OFFSET:u64 = 0x00000024;/* Interrupt Status reg */\n-pub(crate) const FXMAC_IER_OFFSET:u64 = 0x00000028;/* Interrupt Enable reg */\n-pub(crate) const FXMAC_IDR_OFFSET:u64 = 0x0000002C;/* Interrupt Disable reg */\n-pub(crate) const FXMAC_IMR_OFFSET:u64 = 0x00000030;/* Interrupt Mask reg */\n+pub(crate) const FXMAC_PHYMNTNC_OFFSET: u64 = 0x00000034; /* Phy Maintaince reg */\n+pub(crate) const FXMAC_RXPAUSE_OFFSET: u64 = 0x00000038; /* RX Pause Time reg */\n+pub(crate) const FXMAC_TXPAUSE_OFFSET: u64 = 0x0000003C; /* TX Pause Time reg */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 37 to 39)\n-pub(crate) const FXMAC_PHYMNTNC_OFFSET:u64 = 0x00000034;/* Phy Maintaince reg */\n-pub(crate) const FXMAC_RXPAUSE_OFFSET:u64 = 0x00000038; /* RX Pause Time reg */\n-pub(crate) const FXMAC_TXPAUSE_OFFSET:u64 = 0x0000003C; /* TX Pause Time reg */\n+pub(crate) const FXMAC_JUMBOMAXLEN_OFFSET: u64 = 0x00000048; /* Jumbo max length reg */\n+pub(crate) const FXMAC_GEM_HSMAC: u32 = 0x0050; /* Hs mac config register*/\n+pub(crate) const FXMAC_RXWATERMARK_OFFSET: u64 = 0x0000007C; /* RX watermark reg */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 41 to 43)\n-pub(crate) const FXMAC_JUMBOMAXLEN_OFFSET:u64 = 0x00000048;/* Jumbo max length reg */\n-pub(crate) const FXMAC_GEM_HSMAC:u32 = 0x0050;               /* Hs mac config register*/\n-pub(crate) const FXMAC_RXWATERMARK_OFFSET:u64 = 0x0000007C;/* RX watermark reg */\n+pub(crate) const FXMAC_HASHL_OFFSET: u64 = 0x00000080; /* Hash Low address reg */\n+pub(crate) const FXMAC_HASHH_OFFSET: u64 = 0x00000084; /* Hash High address reg */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 45 to 46)\n-pub(crate) const FXMAC_HASHL_OFFSET:u64 = 0x00000080;/* Hash Low address reg */\n-pub(crate) const FXMAC_HASHH_OFFSET:u64 = 0x00000084;/* Hash High address reg */\n+pub(crate) const FXMAC_GEM_SA1B: u32 = 0x0088; /* Specific1 Bottom */\n+pub(crate) const FXMAC_GEM_SA1T: u32 = 0x008C; /* Specific1 Top */\n+pub(crate) const FXMAC_GEM_SA2B: u32 = 0x0090; /* Specific2 Bottom */\n+pub(crate) const FXMAC_GEM_SA2T: u32 = 0x0094; /* Specific2 Top */\n+pub(crate) const FXMAC_GEM_SA3B: u32 = 0x0098; /* Specific3 Bottom */\n+pub(crate) const FXMAC_GEM_SA3T: u32 = 0x009C; /* Specific3 Top */\n+pub(crate) const FXMAC_GEM_SA4B: u32 = 0x00A0; /* Specific4 Bottom */\n+pub(crate) const FXMAC_GEM_SA4T: u32 = 0x00A4; /* Specific4 Top */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 48 to 55)\n-pub(crate) const FXMAC_GEM_SA1B:u32 = 0x0088;          /* Specific1 Bottom */\n-pub(crate) const FXMAC_GEM_SA1T:u32 = 0x008C;          /* Specific1 Top */\n-pub(crate) const FXMAC_GEM_SA2B:u32 = 0x0090;          /* Specific2 Bottom */\n-pub(crate) const FXMAC_GEM_SA2T:u32 = 0x0094;          /* Specific2 Top */\n-pub(crate) const FXMAC_GEM_SA3B:u32 = 0x0098;          /* Specific3 Bottom */\n-pub(crate) const FXMAC_GEM_SA3T:u32 = 0x009C;          /* Specific3 Top */\n-pub(crate) const FXMAC_GEM_SA4B:u32 = 0x00A0;          /* Specific4 Bottom */\n-pub(crate) const FXMAC_GEM_SA4T:u32 = 0x00A4;          /* Specific4 Top */\n+pub(crate) const FXMAC_MATCH1_OFFSET: u64 = 0x000000A8; /* Type ID1 Match reg */\n+pub(crate) const FXMAC_MATCH2_OFFSET: u64 = 0x000000AC; /* Type ID2 Match reg */\n+pub(crate) const FXMAC_MATCH3_OFFSET: u64 = 0x000000B0; /* Type ID3 Match reg */\n+pub(crate) const FXMAC_MATCH4_OFFSET: u64 = 0x000000B4; /* Type ID4 Match reg */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 57 to 60)\n-pub(crate) const FXMAC_MATCH1_OFFSET:u64 = 0x000000A8;/* Type ID1 Match reg */\n-pub(crate) const FXMAC_MATCH2_OFFSET:u64 = 0x000000AC;/* Type ID2 Match reg */\n-pub(crate) const FXMAC_MATCH3_OFFSET:u64 = 0x000000B0;/* Type ID3 Match reg */\n-pub(crate) const FXMAC_MATCH4_OFFSET:u64 = 0x000000B4;/* Type ID4 Match reg */\n+pub(crate) const FXMAC_STRETCH_OFFSET: u64 = 0x000000BC; /* IPG Stretch reg */\n+pub(crate) const FXMAC_REVISION_REG_OFFSET: u64 = 0x000000FC; /*   identification number and module revision */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 62 to 63)\n-pub(crate) const FXMAC_STRETCH_OFFSET:u64 = 0x000000BC;     /* IPG Stretch reg */\n-pub(crate) const FXMAC_REVISION_REG_OFFSET:u64 = 0x000000FC;/*   identification number and module revision */\n+pub(crate) const FXMAC_OCTTXL_OFFSET: u64 = 0x00000100; /* Octects transmitted Low reg */\n+pub(crate) const FXMAC_OCTTXH_OFFSET: u64 = 0x00000104; /* Octects transmitted High reg */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 65 to 66)\n-pub(crate) const FXMAC_OCTTXL_OFFSET:u64 = 0x00000100;/* Octects transmitted Low reg */\n-pub(crate) const FXMAC_OCTTXH_OFFSET:u64 = 0x00000104;/* Octects transmitted High reg */\n+pub(crate) const FXMAC_TXCNT_OFFSET: u64 = 0x00000108; /* Error-free Frmaes transmitted counter */\n+pub(crate) const FXMAC_TXBCCNT_OFFSET: u64 = 0x0000010C; /* Error-free Broadcast Frames counter*/\n+pub(crate) const FXMAC_TXMCCNT_OFFSET: u64 = 0x00000110; /* Error-free Multicast Frame counter */\n+pub(crate) const FXMAC_TXPAUSECNT_OFFSET: u64 = 0x00000114; /* Pause Frames Transmitted Counter */\n+pub(crate) const FXMAC_TX64CNT_OFFSET: u64 = 0x00000118; /* Error-free 64 byte Frames Transmitted counter */\n+pub(crate) const FXMAC_TX65CNT_OFFSET: u64 = 0x0000011C; /* Error-free 65-127 byte Frames Transmitted counter */\n+pub(crate) const FXMAC_TX128CNT_OFFSET: u64 = 0x00000120; /* Error-free 128-255 byte Frames Transmitted counter*/\n+pub(crate) const FXMAC_TX256CNT_OFFSET: u64 = 0x00000124; /* Error-free 256-511 byte Frames transmitted counter */\n+pub(crate) const FXMAC_TX512CNT_OFFSET: u64 = 0x00000128; /* Error-free 512-1023 byte Frames transmitted counter */\n+pub(crate) const FXMAC_TX1024CNT_OFFSET: u64 = 0x0000012C; /* Error-free 1024-1518 byte Frames transmitted counter */\n+pub(crate) const FXMAC_TX1519CNT_OFFSET: u64 = 0x00000130; /* Error-free larger than 1519 byte Frames transmitted counter */\n+pub(crate) const FXMAC_TXURUNCNT_OFFSET: u64 = 0x00000134; /* TX under run error counter */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 68 to 79)\n-pub(crate) const FXMAC_TXCNT_OFFSET:u64 = 0x00000108;     /* Error-free Frmaes transmitted counter */\n-pub(crate) const FXMAC_TXBCCNT_OFFSET:u64 = 0x0000010C;   /* Error-free Broadcast Frames counter*/\n-pub(crate) const FXMAC_TXMCCNT_OFFSET:u64 = 0x00000110;   /* Error-free Multicast Frame counter */\n-pub(crate) const FXMAC_TXPAUSECNT_OFFSET:u64 = 0x00000114;/* Pause Frames Transmitted Counter */\n-pub(crate) const FXMAC_TX64CNT_OFFSET:u64 = 0x00000118;   /* Error-free 64 byte Frames Transmitted counter */\n-pub(crate) const FXMAC_TX65CNT_OFFSET:u64 = 0x0000011C;   /* Error-free 65-127 byte Frames Transmitted counter */\n-pub(crate) const FXMAC_TX128CNT_OFFSET:u64 = 0x00000120;  /* Error-free 128-255 byte Frames Transmitted counter*/\n-pub(crate) const FXMAC_TX256CNT_OFFSET:u64 = 0x00000124;  /* Error-free 256-511 byte Frames transmitted counter */\n-pub(crate) const FXMAC_TX512CNT_OFFSET:u64 = 0x00000128;  /* Error-free 512-1023 byte Frames transmitted counter */\n-pub(crate) const FXMAC_TX1024CNT_OFFSET:u64 = 0x0000012C; /* Error-free 1024-1518 byte Frames transmitted counter */\n-pub(crate) const FXMAC_TX1519CNT_OFFSET:u64 = 0x00000130; /* Error-free larger than 1519 byte Frames transmitted counter */\n-pub(crate) const FXMAC_TXURUNCNT_OFFSET:u64 = 0x00000134; /* TX under run error counter */\n+pub(crate) const FXMAC_SNGLCOLLCNT_OFFSET: u64 = 0x00000138; /* Single Collision Frame Counter */\n+pub(crate) const FXMAC_MULTICOLLCNT_OFFSET: u64 = 0x0000013C; /* Multiple Collision Frame Counter */\n+pub(crate) const FXMAC_EXCESSCOLLCNT_OFFSET: u64 = 0x00000140; /* Excessive Collision Frame Counter */\n+pub(crate) const FXMAC_LATECOLLCNT_OFFSET: u64 = 0x00000144; /* Late Collision Frame Counter */\n+pub(crate) const FXMAC_TXDEFERCNT_OFFSET: u64 = 0x00000148; /* Deferred Transmission Frame Counter */\n+pub(crate) const FXMAC_TXCSENSECNT_OFFSET: u64 = 0x0000014C; /* Transmit Carrier Sense Error Counter */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 81 to 86)\n-pub(crate) const FXMAC_SNGLCOLLCNT_OFFSET:u64 = 0x00000138;  /* Single Collision Frame Counter */\n-pub(crate) const FXMAC_MULTICOLLCNT_OFFSET:u64 = 0x0000013C; /* Multiple Collision Frame Counter */\n-pub(crate) const FXMAC_EXCESSCOLLCNT_OFFSET:u64 = 0x00000140;/* Excessive Collision Frame Counter */\n-pub(crate) const FXMAC_LATECOLLCNT_OFFSET:u64 = 0x00000144;  /* Late Collision Frame Counter */\n-pub(crate) const FXMAC_TXDEFERCNT_OFFSET:u64 = 0x00000148;   /* Deferred Transmission Frame Counter */\n-pub(crate) const FXMAC_TXCSENSECNT_OFFSET:u64 = 0x0000014C;  /* Transmit Carrier Sense Error Counter */\n+pub(crate) const FXMAC_OCTRXL_OFFSET: u64 = 0x00000150; /* Octects Received register Low */\n+pub(crate) const FXMAC_OCTRXH_OFFSET: u64 = 0x00000154; /* Octects Received register High */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 88 to 89)\n-pub(crate) const FXMAC_OCTRXL_OFFSET:u64 = 0x00000150;/* Octects Received register Low */\n-pub(crate) const FXMAC_OCTRXH_OFFSET:u64 = 0x00000154;/* Octects Received register High */\n+pub(crate) const FXMAC_RXCNT_OFFSET: u64 = 0x00000158; /* Error-free Frames Received Counter */\n+pub(crate) const FXMAC_RXBROADCNT_OFFSET: u64 = 0x0000015C; /* Error-free Broadcast Frames Received Counter */\n+pub(crate) const FXMAC_RXMULTICNT_OFFSET: u64 = 0x00000160; /* Error-free Multicast Frames Received Counter */\n+pub(crate) const FXMAC_RXPAUSECNT_OFFSET: u64 = 0x00000164; /* Pause Frames Received Counter */\n+pub(crate) const FXMAC_RX64CNT_OFFSET: u64 = 0x00000168; /* Error-free 64 byte Frames Received Counter */\n+pub(crate) const FXMAC_RX65CNT_OFFSET: u64 = 0x0000016C; /* Error-free 65-127 byte Frames Received Counter */\n+pub(crate) const FXMAC_RX128CNT_OFFSET: u64 = 0x00000170; /* Error-free 128-255 byte Frames Received Counter */\n+pub(crate) const FXMAC_RX256CNT_OFFSET: u64 = 0x00000174; /* Error-free 256-512 byte Frames Received Counter */\n+pub(crate) const FXMAC_RX512CNT_OFFSET: u64 = 0x00000178; /* Error-free 512-1023 byte Frames Received Counter */\n+pub(crate) const FXMAC_RX1024CNT_OFFSET: u64 = 0x0000017C; /* Error-free 1024-1518 byte Frames Received Counter */\n+pub(crate) const FXMAC_RX1519CNT_OFFSET: u64 = 0x00000180; /* Error-free 1519-max byte Frames Received Counter */\n+pub(crate) const FXMAC_RXUNDRCNT_OFFSET: u64 = 0x00000184; /* Undersize Frames Received Counter */\n+pub(crate) const FXMAC_RXOVRCNT_OFFSET: u64 = 0x00000188; /* Oversize Frames Received Counter */\n+pub(crate) const FXMAC_RXJABCNT_OFFSET: u64 = 0x0000018C; /* Jabbers Received Counter */\n+pub(crate) const FXMAC_RXFCSCNT_OFFSET: u64 = 0x00000190; /* Frame Check Sequence Error Counter */\n+pub(crate) const FXMAC_RXLENGTHCNT_OFFSET: u64 = 0x00000194; /* Length Field Error Counter */\n+pub(crate) const FXMAC_RXSYMBCNT_OFFSET: u64 = 0x00000198; /* Symbol Error Counter */\n+pub(crate) const FXMAC_RXALIGNCNT_OFFSET: u64 = 0x0000019C; /* Alignment Error Counter */\n+pub(crate) const FXMAC_RXRESERRCNT_OFFSET: u64 = 0x000001A0; /* Receive Resource Error Counter */\n+pub(crate) const FXMAC_RXORCNT_OFFSET: u64 = 0x000001A4; /* Receive Overrun Counter */\n+pub(crate) const FXMAC_RXIPCCNT_OFFSET: u64 = 0x000001A8; /* IP header Checksum Error Counter */\n+pub(crate) const FXMAC_RXTCPCCNT_OFFSET: u64 = 0x000001AC; /* TCP Checksum Error Counter */\n+pub(crate) const FXMAC_RXUDPCCNT_OFFSET: u64 = 0x000001B0; /* UDP Checksum Error Counter */\n+pub(crate) const FXMAC_LAST_OFFSET: u64 = 0x000001B4; /* Last statistic counter offset, for clearing */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 91 to 114)\n-pub(crate) const FXMAC_RXCNT_OFFSET:u64 = 0x00000158;      /* Error-free Frames Received Counter */\n-pub(crate) const FXMAC_RXBROADCNT_OFFSET:u64 = 0x0000015C; /* Error-free Broadcast Frames Received Counter */\n-pub(crate) const FXMAC_RXMULTICNT_OFFSET:u64 = 0x00000160; /* Error-free Multicast Frames Received Counter */\n-pub(crate) const FXMAC_RXPAUSECNT_OFFSET:u64 = 0x00000164; /* Pause Frames Received Counter */\n-pub(crate) const FXMAC_RX64CNT_OFFSET:u64 = 0x00000168;    /* Error-free 64 byte Frames Received Counter */\n-pub(crate) const FXMAC_RX65CNT_OFFSET:u64 = 0x0000016C;    /* Error-free 65-127 byte Frames Received Counter */\n-pub(crate) const FXMAC_RX128CNT_OFFSET:u64 = 0x00000170;   /* Error-free 128-255 byte Frames Received Counter */\n-pub(crate) const FXMAC_RX256CNT_OFFSET:u64 = 0x00000174;   /* Error-free 256-512 byte Frames Received Counter */\n-pub(crate) const FXMAC_RX512CNT_OFFSET:u64 = 0x00000178;   /* Error-free 512-1023 byte Frames Received Counter */\n-pub(crate) const FXMAC_RX1024CNT_OFFSET:u64 = 0x0000017C;  /* Error-free 1024-1518 byte Frames Received Counter */\n-pub(crate) const FXMAC_RX1519CNT_OFFSET:u64 = 0x00000180;  /* Error-free 1519-max byte Frames Received Counter */\n-pub(crate) const FXMAC_RXUNDRCNT_OFFSET:u64 = 0x00000184;  /* Undersize Frames Received Counter */\n-pub(crate) const FXMAC_RXOVRCNT_OFFSET:u64 = 0x00000188;   /* Oversize Frames Received Counter */\n-pub(crate) const FXMAC_RXJABCNT_OFFSET:u64 = 0x0000018C;   /* Jabbers Received Counter */\n-pub(crate) const FXMAC_RXFCSCNT_OFFSET:u64 = 0x00000190;   /* Frame Check Sequence Error Counter */\n-pub(crate) const FXMAC_RXLENGTHCNT_OFFSET:u64 = 0x00000194;/* Length Field Error Counter */\n-pub(crate) const FXMAC_RXSYMBCNT_OFFSET:u64 = 0x00000198;  /* Symbol Error Counter */\n-pub(crate) const FXMAC_RXALIGNCNT_OFFSET:u64 = 0x0000019C; /* Alignment Error Counter */\n-pub(crate) const FXMAC_RXRESERRCNT_OFFSET:u64 = 0x000001A0;/* Receive Resource Error Counter */\n-pub(crate) const FXMAC_RXORCNT_OFFSET:u64 = 0x000001A4;    /* Receive Overrun Counter */\n-pub(crate) const FXMAC_RXIPCCNT_OFFSET:u64 = 0x000001A8;   /* IP header Checksum Error Counter */\n-pub(crate) const FXMAC_RXTCPCCNT_OFFSET:u64 = 0x000001AC;  /* TCP Checksum Error Counter */\n-pub(crate) const FXMAC_RXUDPCCNT_OFFSET:u64 = 0x000001B0;  /* UDP Checksum Error Counter */\n-pub(crate) const FXMAC_LAST_OFFSET:u64 = 0x000001B4;       /* Last statistic counter offset, for clearing */\n+pub(crate) const FXMAC_1588_SEC_OFFSET: u64 = 0x000001D0; /* 1588 second counter */\n+pub(crate) const FXMAC_1588_NANOSEC_OFFSET: u64 = 0x000001D4; /* 1588 nanosecond counter */\n+pub(crate) const FXMAC_1588_ADJ_OFFSET: u64 = 0x000001D8; /* 1588 nanosecond adjustment counter */\n+pub(crate) const FXMAC_1588_INC_OFFSET: u64 = 0x000001DC; /* 1588 nanosecond increment counter */\n+pub(crate) const FXMAC_PTP_TXSEC_OFFSET: u64 = 0x000001E0; /* 1588 PTP transmit second counter */\n+pub(crate) const FXMAC_PTP_TXNANOSEC_OFFSET: u64 = 0x000001E4; /* 1588 PTP transmit nanosecond counter */\n+pub(crate) const FXMAC_PTP_RXSEC_OFFSET: u64 = 0x000001E8; /* 1588 PTP receive second counter */\n+pub(crate) const FXMAC_PTP_RXNANOSEC_OFFSET: u64 = 0x000001EC; /* 1588 PTP receive nanosecond counter */\n+pub(crate) const FXMAC_PTPP_TXSEC_OFFSET: u64 = 0x000001F0; /* 1588 PTP peer transmit second counter */\n+pub(crate) const FXMAC_PTPP_TXNANOSEC_OFFSET: u64 = 0x000001F4; /* 1588 PTP peer transmit nanosecond counter */\n+pub(crate) const FXMAC_PTPP_RXSEC_OFFSET: u64 = 0x000001F8; /* 1588 PTP peer receive second counter */\n+pub(crate) const FXMAC_PTPP_RXNANOSEC_OFFSET: u64 = 0x000001FC; /* 1588 PTP peer receive nanosecond counter */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 116 to 127)\n-pub(crate) const FXMAC_1588_SEC_OFFSET:u64 = 0x000001D0;      /* 1588 second counter */\n-pub(crate) const FXMAC_1588_NANOSEC_OFFSET:u64 = 0x000001D4;  /* 1588 nanosecond counter */\n-pub(crate) const FXMAC_1588_ADJ_OFFSET:u64 = 0x000001D8;      /* 1588 nanosecond adjustment counter */\n-pub(crate) const FXMAC_1588_INC_OFFSET:u64 = 0x000001DC;      /* 1588 nanosecond increment counter */\n-pub(crate) const FXMAC_PTP_TXSEC_OFFSET:u64 = 0x000001E0;     /* 1588 PTP transmit second counter */\n-pub(crate) const FXMAC_PTP_TXNANOSEC_OFFSET:u64 = 0x000001E4; /* 1588 PTP transmit nanosecond counter */\n-pub(crate) const FXMAC_PTP_RXSEC_OFFSET:u64 = 0x000001E8;     /* 1588 PTP receive second counter */\n-pub(crate) const FXMAC_PTP_RXNANOSEC_OFFSET:u64 = 0x000001EC; /* 1588 PTP receive nanosecond counter */\n-pub(crate) const FXMAC_PTPP_TXSEC_OFFSET:u64 = 0x000001F0;    /* 1588 PTP peer transmit second counter */\n-pub(crate) const FXMAC_PTPP_TXNANOSEC_OFFSET:u64 = 0x000001F4;/* 1588 PTP peer transmit nanosecond counter */\n-pub(crate) const FXMAC_PTPP_RXSEC_OFFSET:u64 = 0x000001F8;    /* 1588 PTP peer receive second counter */\n-pub(crate) const FXMAC_PTPP_RXNANOSEC_OFFSET:u64 = 0x000001FC;/* 1588 PTP peer receive nanosecond counter */\n+pub(crate) const FXMAC_PCS_CONTROL_OFFSET: u64 = 0x00000200; /* All PCS registers */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 129 to 129)\n-pub(crate) const FXMAC_PCS_CONTROL_OFFSET:u64 = 0x00000200;/* All PCS registers */\n+pub(crate) const FXMAC_PCS_STATUS_OFFSET: u64 = 0x00000204; /* All PCS status */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 131 to 131)\n-pub(crate) const FXMAC_PCS_STATUS_OFFSET:u64 =  0x00000204;/* All PCS status */\n+pub(crate) const FXMAC_PCS_AN_LP_OFFSET: u64 = 0x00000214; /* All PCS link partner's base page */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 133 to 133)\n-pub(crate) const FXMAC_PCS_AN_LP_OFFSET:u64 = 0x00000214; /* All PCS link partner's base page */\n+pub(crate) const FXMAC_DESIGNCFG_DEBUG1_OFFSET: u64 = 0x00000280; /* Design Configuration Register 1 */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 135 to 135)\n-pub(crate) const FXMAC_DESIGNCFG_DEBUG1_OFFSET:u64 = 0x00000280;/* Design Configuration Register 1 */\n+pub(crate) const FXMAC_DESIGNCFG_DEBUG2_OFFSET: u64 = 0x00000284; /* Design Configuration Register 2 */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 137 to 137)\n-pub(crate) const FXMAC_DESIGNCFG_DEBUG2_OFFSET:u64 = 0x00000284;/* Design Configuration Register 2 */\n+pub(crate) const FXMAC_INTQ1_STS_OFFSET: u64 = 0x00000400; /* Interrupt Q1 Status reg */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 139 to 139)\n-pub(crate) const FXMAC_INTQ1_STS_OFFSET:u64 = 0x00000400;/* Interrupt Q1 Status reg */\n+pub(crate) const FXMAC_TXQ1BASE_OFFSET: u64 = 0x00000440; /* TX Q1 Base address reg */\n+pub(crate) const FXMAC_RXQ1BASE_OFFSET: u64 = 0x00000480; /* RX Q1 Base address reg */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 141 to 144)\n-pub(crate) const FXMAC_TXQ1BASE_OFFSET:u64 = 0x00000440;/* TX Q1 Base address reg */\n-pub(crate) const FXMAC_RXQ1BASE_OFFSET:u64 = 0x00000480;/* RX Q1 Base address reg */\n-\n-pub(crate) const FXMAC_RXBUFQ1_SIZE_OFFSET:u64 = 0x000004a0;/* Receive Buffer Size */\n+pub(crate) const FXMAC_RXBUFQ1_SIZE_OFFSET: u64 = 0x000004a0; /* Receive Buffer Size */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 149 to 149)\n-pub(crate) const FXMAC_RXBUFQX_SIZE_MASK:u32 = GENMASK(7, 0);\n+pub(crate) const FXMAC_RXBUFQX_SIZE_MASK: u32 = GENMASK(7, 0);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 151 to 154)\n-pub(crate) const FXMAC_MSBBUF_TXQBASE_OFFSET:u64 = 0x000004C8;/* MSB Buffer TX Q Base reg */\n-pub(crate) const FXMAC_MSBBUF_RXQBASE_OFFSET:u64 = 0x000004D4;/* MSB Buffer RX Q Base reg */\n-pub(crate) const FXMAC_TXQSEGALLOC_QLOWER_OFFSET:u64 = 0x000005A0;/* Transmit SRAM segment distribution */\n-pub(crate) const FXMAC_INTQ1_IER_OFFSET:u64 = 0x00000600;     /* Interrupt Q1 Enable reg */\n+pub(crate) const FXMAC_MSBBUF_TXQBASE_OFFSET: u64 = 0x000004C8; /* MSB Buffer TX Q Base reg */\n+pub(crate) const FXMAC_MSBBUF_RXQBASE_OFFSET: u64 = 0x000004D4; /* MSB Buffer RX Q Base reg */\n+pub(crate) const FXMAC_TXQSEGALLOC_QLOWER_OFFSET: u64 = 0x000005A0; /* Transmit SRAM segment distribution */\n+pub(crate) const FXMAC_INTQ1_IER_OFFSET: u64 = 0x00000600; /* Interrupt Q1 Enable reg */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 159 to 159)\n-pub(crate) const FXMAC_INTQ1_IDR_OFFSET:u64 = 0x00000620;/* Interrupt Q1 Disable reg */\n+pub(crate) const FXMAC_INTQ1_IDR_OFFSET: u64 = 0x00000620; /* Interrupt Q1 Disable reg */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 164 to 164)\n-pub(crate) const FXMAC_INTQ1_IMR_OFFSET:u64 = 0x00000640;/* Interrupt Q1 Mask reg */\n+pub(crate) const FXMAC_INTQ1_IMR_OFFSET: u64 = 0x00000640; /* Interrupt Q1 Mask reg */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 166 to 168)\n-pub(crate) const FXMAC_GEM_USX_CONTROL_OFFSET:u64 = 0x0A80; /* High speed PCS control register */\n-pub(crate) const FXMAC_TEST_CONTROL_OFFSET:u64 = 0x0A84;    /* USXGMII Test Control Register */\n-pub(crate) const FXMAC_GEM_USX_STATUS_OFFSET:u64 = 0x0A88;    /* USXGMII Status Register */\n+pub(crate) const FXMAC_GEM_USX_CONTROL_OFFSET: u64 = 0x0A80; /* High speed PCS control register */\n+pub(crate) const FXMAC_TEST_CONTROL_OFFSET: u64 = 0x0A84; /* USXGMII Test Control Register */\n+pub(crate) const FXMAC_GEM_USX_STATUS_OFFSET: u64 = 0x0A88; /* USXGMII Status Register */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 170 to 195)\n-pub(crate) const FXMAC_GEM_SRC_SEL_LN:u32 = 0x1C04;\n-pub(crate) const FXMAC_GEM_DIV_SEL0_LN:u32 = 0x1C08;\n-pub(crate) const FXMAC_GEM_DIV_SEL1_LN:u32 = 0x1C0C;\n-pub(crate) const FXMAC_GEM_PMA_XCVR_POWER_STATE:u32 = 0x1C10;\n-pub(crate) const FXMAC_GEM_SPEED_MODE:u32 = 0x1C14;\n-pub(crate) const FXMAC_GEM_MII_SELECT:u32 = 0x1C18;\n-pub(crate) const FXMAC_GEM_SEL_MII_ON_RGMII:u32 = 0x1C1C;\n-pub(crate) const FXMAC_GEM_TX_CLK_SEL0:u32 = 0x1C20;\n-pub(crate) const FXMAC_GEM_TX_CLK_SEL1:u32 = 0x1C24;\n-pub(crate) const FXMAC_GEM_TX_CLK_SEL2:u32 = 0x1C28;\n-pub(crate) const FXMAC_GEM_TX_CLK_SEL3:u32 = 0x1C2C;\n-pub(crate) const FXMAC_GEM_RX_CLK_SEL0:u32 = 0x1C30;\n-pub(crate) const FXMAC_GEM_RX_CLK_SEL1:u32 = 0x1C34;\n-pub(crate) const FXMAC_GEM_CLK_250M_DIV10_DIV100_SEL:u32 = 0x1C38;\n-pub(crate) const FXMAC_GEM_TX_CLK_SEL5:u32 = 0x1C3C;\n-pub(crate) const FXMAC_GEM_TX_CLK_SEL6:u32 = 0x1C40;\n-pub(crate) const FXMAC_GEM_RX_CLK_SEL4:u32 = 0x1C44;\n-pub(crate) const FXMAC_GEM_RX_CLK_SEL5:u32 = 0x1C48;\n-pub(crate) const FXMAC_GEM_TX_CLK_SEL3_0:u32 = 0x1C70;\n-pub(crate) const FXMAC_GEM_TX_CLK_SEL4_0:u32 = 0x1C74;\n-pub(crate) const FXMAC_GEM_RX_CLK_SEL3_0:u32 = 0x1C78;\n-pub(crate) const FXMAC_GEM_RX_CLK_SEL4_0:u32 = 0x1C7C;\n-pub(crate) const FXMAC_GEM_RGMII_TX_CLK_SEL0:u32 = 0x1C80;\n-pub(crate) const FXMAC_GEM_RGMII_TX_CLK_SEL1:u32 = 0x1C84;\n-pub(crate) const FXMAC_GEM_MODE_SEL_OFFSET:u64 = 0xDC00;\n-pub(crate) const FXMAC_LOOPBACK_SEL_OFFSET:u64 = 0xDC04;\n+pub(crate) const FXMAC_GEM_SRC_SEL_LN: u32 = 0x1C04;\n+pub(crate) const FXMAC_GEM_DIV_SEL0_LN: u32 = 0x1C08;\n+pub(crate) const FXMAC_GEM_DIV_SEL1_LN: u32 = 0x1C0C;\n+pub(crate) const FXMAC_GEM_PMA_XCVR_POWER_STATE: u32 = 0x1C10;\n+pub(crate) const FXMAC_GEM_SPEED_MODE: u32 = 0x1C14;\n+pub(crate) const FXMAC_GEM_MII_SELECT: u32 = 0x1C18;\n+pub(crate) const FXMAC_GEM_SEL_MII_ON_RGMII: u32 = 0x1C1C;\n+pub(crate) const FXMAC_GEM_TX_CLK_SEL0: u32 = 0x1C20;\n+pub(crate) const FXMAC_GEM_TX_CLK_SEL1: u32 = 0x1C24;\n+pub(crate) const FXMAC_GEM_TX_CLK_SEL2: u32 = 0x1C28;\n+pub(crate) const FXMAC_GEM_TX_CLK_SEL3: u32 = 0x1C2C;\n+pub(crate) const FXMAC_GEM_RX_CLK_SEL0: u32 = 0x1C30;\n+pub(crate) const FXMAC_GEM_RX_CLK_SEL1: u32 = 0x1C34;\n+pub(crate) const FXMAC_GEM_CLK_250M_DIV10_DIV100_SEL: u32 = 0x1C38;\n+pub(crate) const FXMAC_GEM_TX_CLK_SEL5: u32 = 0x1C3C;\n+pub(crate) const FXMAC_GEM_TX_CLK_SEL6: u32 = 0x1C40;\n+pub(crate) const FXMAC_GEM_RX_CLK_SEL4: u32 = 0x1C44;\n+pub(crate) const FXMAC_GEM_RX_CLK_SEL5: u32 = 0x1C48;\n+pub(crate) const FXMAC_GEM_TX_CLK_SEL3_0: u32 = 0x1C70;\n+pub(crate) const FXMAC_GEM_TX_CLK_SEL4_0: u32 = 0x1C74;\n+pub(crate) const FXMAC_GEM_RX_CLK_SEL3_0: u32 = 0x1C78;\n+pub(crate) const FXMAC_GEM_RX_CLK_SEL4_0: u32 = 0x1C7C;\n+pub(crate) const FXMAC_GEM_RGMII_TX_CLK_SEL0: u32 = 0x1C80;\n+pub(crate) const FXMAC_GEM_RGMII_TX_CLK_SEL1: u32 = 0x1C84;\n+pub(crate) const FXMAC_GEM_MODE_SEL_OFFSET: u64 = 0xDC00;\n+pub(crate) const FXMAC_LOOPBACK_SEL_OFFSET: u64 = 0xDC04;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 197 to 197)\n-pub(crate) const FXMAC_TAIL_ENABLE:u64 = 0xe7c;  /*Enable tail Register*/ \n+pub(crate) const FXMAC_TAIL_ENABLE: u64 = 0xe7c; /*Enable tail Register*/\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 200 to 200)\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 207 to 210)\n-pub(crate) const FXMAC_IXR_PTPPSTX_MASK:u32 = BIT(25);  /* PTP Pdelay_resp TXed */\n-pub(crate) const FXMAC_IXR_PTPPDRTX_MASK:u32 = BIT(24); /* PTP Pdelay_req TXed */\n-pub(crate) const FXMAC_IXR_PTPPSRX_MASK:u32 = BIT(23);  /* PTP Pdelay_resp RXed */\n-pub(crate) const FXMAC_IXR_PTPPDRRX_MASK:u32 = BIT(22); /* PTP Pdelay_req RXed */\n+pub(crate) const FXMAC_IXR_PTPPSTX_MASK: u32 = BIT(25); /* PTP Pdelay_resp TXed */\n+pub(crate) const FXMAC_IXR_PTPPDRTX_MASK: u32 = BIT(24); /* PTP Pdelay_req TXed */\n+pub(crate) const FXMAC_IXR_PTPPSRX_MASK: u32 = BIT(23); /* PTP Pdelay_resp RXed */\n+pub(crate) const FXMAC_IXR_PTPPDRRX_MASK: u32 = BIT(22); /* PTP Pdelay_req RXed */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 212 to 215)\n-pub(crate) const FXMAC_IXR_PTPSTX_MASK:u32 = BIT(21);  /* PTP Sync TXed */\n-pub(crate) const FXMAC_IXR_PTPDRTX_MASK:u32 = BIT(20); /* PTP Delay_req TXed */\n-pub(crate) const FXMAC_IXR_PTPSRX_MASK:u32 = BIT(19);  /* PTP Sync RXed */\n-pub(crate) const FXMAC_IXR_PTPDRRX_MASK:u32 = BIT(18); /* PTP Delay_req RXed */\n+pub(crate) const FXMAC_IXR_PTPSTX_MASK: u32 = BIT(21); /* PTP Sync TXed */\n+pub(crate) const FXMAC_IXR_PTPDRTX_MASK: u32 = BIT(20); /* PTP Delay_req TXed */\n+pub(crate) const FXMAC_IXR_PTPSRX_MASK: u32 = BIT(19); /* PTP Sync RXed */\n+pub(crate) const FXMAC_IXR_PTPDRRX_MASK: u32 = BIT(18); /* PTP Delay_req RXed */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 217 to 231)\n-pub(crate) const FXMAC_IXR_PAUSETX_MASK:u32 = BIT(14);    /* Pause frame transmitted */\n-pub(crate) const FXMAC_IXR_PAUSEZERO_MASK:u32 = BIT(13);  /* Pause time has reached zero */\n-pub(crate) const FXMAC_IXR_PAUSENZERO_MASK:u32 = BIT(12); /* Pause frame received */\n-pub(crate) const FXMAC_IXR_HRESPNOK_MASK:u32 = BIT(11);   /* hresp not ok */\n-pub(crate) const FXMAC_IXR_RXOVR_MASK:u32 = BIT(10);      /* Receive overrun occurred */\n-pub(crate) const FXMAC_IXR_LINKCHANGE_MASK:u32 = BIT(9);   /* link status change */\n-pub(crate) const FXMAC_IXR_TXCOMPL_MASK:u32 = BIT(7);     /* Frame transmitted ok */\n-pub(crate) const FXMAC_IXR_TXEXH_MASK:u32 = BIT(6);       /* Transmit err occurred or no buffers*/\n-pub(crate) const FXMAC_IXR_RETRY_MASK:u32 = BIT(5);       /* Retry limit exceeded */\n-pub(crate) const FXMAC_IXR_URUN_MASK:u32 = BIT(4);        /* Transmit underrun */\n-pub(crate) const FXMAC_IXR_TXUSED_MASK:u32 = BIT(3);      /* Tx buffer used bit read */\n-pub(crate) const FXMAC_IXR_RXUSED_MASK:u32 = BIT(2);      /* Rx buffer used bit read */\n-pub(crate) const FXMAC_IXR_RXCOMPL_MASK:u32 = BIT(1);     /* Frame received ok */\n-pub(crate) const FXMAC_IXR_MGMNT_MASK:u32 = BIT(0);       /* PHY management complete */\n-pub(crate) const FXMAC_IXR_ALL_MASK:u32 = GENMASK(31, 0); /* Everything! */\n+pub(crate) const FXMAC_IXR_PAUSETX_MASK: u32 = BIT(14); /* Pause frame transmitted */\n+pub(crate) const FXMAC_IXR_PAUSEZERO_MASK: u32 = BIT(13); /* Pause time has reached zero */\n+pub(crate) const FXMAC_IXR_PAUSENZERO_MASK: u32 = BIT(12); /* Pause frame received */\n+pub(crate) const FXMAC_IXR_HRESPNOK_MASK: u32 = BIT(11); /* hresp not ok */\n+pub(crate) const FXMAC_IXR_RXOVR_MASK: u32 = BIT(10); /* Receive overrun occurred */\n+pub(crate) const FXMAC_IXR_LINKCHANGE_MASK: u32 = BIT(9); /* link status change */\n+pub(crate) const FXMAC_IXR_TXCOMPL_MASK: u32 = BIT(7); /* Frame transmitted ok */\n+pub(crate) const FXMAC_IXR_TXEXH_MASK: u32 = BIT(6); /* Transmit err occurred or no buffers*/\n+pub(crate) const FXMAC_IXR_RETRY_MASK: u32 = BIT(5); /* Retry limit exceeded */\n+pub(crate) const FXMAC_IXR_URUN_MASK: u32 = BIT(4); /* Transmit underrun */\n+pub(crate) const FXMAC_IXR_TXUSED_MASK: u32 = BIT(3); /* Tx buffer used bit read */\n+pub(crate) const FXMAC_IXR_RXUSED_MASK: u32 = BIT(2); /* Rx buffer used bit read */\n+pub(crate) const FXMAC_IXR_RXCOMPL_MASK: u32 = BIT(1); /* Frame received ok */\n+pub(crate) const FXMAC_IXR_MGMNT_MASK: u32 = BIT(0); /* PHY management complete */\n+pub(crate) const FXMAC_IXR_ALL_MASK: u32 = GENMASK(31, 0); /* Everything! */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 233 to 233)\n-pub(crate) const FXMAC_IXR_TX_ERR_MASK:u32 = (FXMAC_IXR_TXEXH_MASK | FXMAC_IXR_RETRY_MASK | FXMAC_IXR_URUN_MASK);\n+pub(crate) const FXMAC_IXR_TX_ERR_MASK: u32 =\n+    (FXMAC_IXR_TXEXH_MASK | FXMAC_IXR_RETRY_MASK | FXMAC_IXR_URUN_MASK);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 235 to 235)\n-pub(crate) const FXMAC_IXR_RX_ERR_MASK:u32 = (FXMAC_IXR_HRESPNOK_MASK | FXMAC_IXR_RXUSED_MASK | FXMAC_IXR_RXOVR_MASK);\n+pub(crate) const FXMAC_IXR_RX_ERR_MASK: u32 =\n+    (FXMAC_IXR_HRESPNOK_MASK | FXMAC_IXR_RXUSED_MASK | FXMAC_IXR_RXOVR_MASK);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 237 to 237)\n-pub(crate) const FXMAC_INTR_MASK:u32 = (FXMAC_IXR_LINKCHANGE_MASK | FXMAC_IXR_TX_ERR_MASK | FXMAC_IXR_RX_ERR_MASK | FXMAC_IXR_RXCOMPL_MASK | FXMAC_IXR_TXCOMPL_MASK);\n+pub(crate) const FXMAC_INTR_MASK: u32 = (FXMAC_IXR_LINKCHANGE_MASK\n+    | FXMAC_IXR_TX_ERR_MASK\n+    | FXMAC_IXR_RX_ERR_MASK\n+    | FXMAC_IXR_RXCOMPL_MASK\n+    | FXMAC_IXR_TXCOMPL_MASK);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 242 to 242)\n-pub(crate) const FXMAC_NWCTRL_ENABLE_HS_MAC_MASK:u32 = BIT(31);\n+pub(crate) const FXMAC_NWCTRL_ENABLE_HS_MAC_MASK: u32 = BIT(31);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 244 to 244)\n-pub(crate) const FXMAC_NWCTRL_TWO_PT_FIVE_GIG_MASK:u32 = BIT(29); /* 2.5G operation selected */\n+pub(crate) const FXMAC_NWCTRL_TWO_PT_FIVE_GIG_MASK: u32 = BIT(29); /* 2.5G operation selected */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 246 to 250)\n-pub(crate) const FXMAC_NWCTRL_FLUSH_DPRAM_MASK:u32 = BIT(18); /* Flush a packet from Rx SRAM */\n-pub(crate) const FXMAC_NWCTRL_ZEROPAUSETX_MASK:u32 = BIT(11); /* Transmit zero quantum pause frame */\n-pub(crate) const FXMAC_NWCTRL_PAUSETX_MASK:u32 = BIT(11);     /* Transmit pause frame */\n-pub(crate) const FXMAC_NWCTRL_HALTTX_MASK:u32 = BIT(10);      /* Halt transmission after current frame */\n-pub(crate) const FXMAC_NWCTRL_STARTTX_MASK:u32 = BIT(9);      /* Start tx (tx_go) */\n+pub(crate) const FXMAC_NWCTRL_FLUSH_DPRAM_MASK: u32 = BIT(18); /* Flush a packet from Rx SRAM */\n+pub(crate) const FXMAC_NWCTRL_ZEROPAUSETX_MASK: u32 = BIT(11); /* Transmit zero quantum pause frame */\n+pub(crate) const FXMAC_NWCTRL_PAUSETX_MASK: u32 = BIT(11); /* Transmit pause frame */\n+pub(crate) const FXMAC_NWCTRL_HALTTX_MASK: u32 = BIT(10); /* Halt transmission after current frame */\n+pub(crate) const FXMAC_NWCTRL_STARTTX_MASK: u32 = BIT(9); /* Start tx (tx_go) */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 252 to 258)\n-pub(crate) const FXMAC_NWCTRL_STATWEN_MASK:u32 = BIT(7); /* Enable writing to stat counters */\n-pub(crate) const FXMAC_NWCTRL_STATINC_MASK:u32 = BIT(6); /* Increment statistic registers */\n-pub(crate) const FXMAC_NWCTRL_STATCLR_MASK:u32 = BIT(5); /* Clear statistic registers */\n-pub(crate) const FXMAC_NWCTRL_MDEN_MASK:u32 = BIT(4);    /* Enable MDIO port */\n-pub(crate) const FXMAC_NWCTRL_TXEN_MASK:u32 = BIT(3);    /* Enable transmit */\n-pub(crate) const FXMAC_NWCTRL_RXEN_MASK:u32 = BIT(2);    /* Enable receive */\n-pub(crate) const FXMAC_NWCTRL_LOOPBACK_LOCAL_MASK:u32 = BIT(1); /* Loopback local */\n+pub(crate) const FXMAC_NWCTRL_STATWEN_MASK: u32 = BIT(7); /* Enable writing to stat counters */\n+pub(crate) const FXMAC_NWCTRL_STATINC_MASK: u32 = BIT(6); /* Increment statistic registers */\n+pub(crate) const FXMAC_NWCTRL_STATCLR_MASK: u32 = BIT(5); /* Clear statistic registers */\n+pub(crate) const FXMAC_NWCTRL_MDEN_MASK: u32 = BIT(4); /* Enable MDIO port */\n+pub(crate) const FXMAC_NWCTRL_TXEN_MASK: u32 = BIT(3); /* Enable transmit */\n+pub(crate) const FXMAC_NWCTRL_RXEN_MASK: u32 = BIT(2); /* Enable receive */\n+pub(crate) const FXMAC_NWCTRL_LOOPBACK_LOCAL_MASK: u32 = BIT(1); /* Loopback local */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 260 to 261)\n-\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 265 to 271)\n-pub(crate) const FXMAC_NWCFG_BADPREAMBEN_MASK:u32 = BIT(29);       /* disable rejection of non-standard preamble */\n-pub(crate) const FXMAC_NWCFG_IPDSTRETCH_MASK:u32 = BIT(28);        /* enable transmit IPG */\n-pub(crate) const FXMAC_NWCFG_SGMII_MODE_ENABLE_MASK:u32 = BIT(27); /* SGMII mode enable */\n-pub(crate) const FXMAC_NWCFG_FCSIGNORE_MASK:u32 = BIT(26);         /* disable rejection of FCS error */\n-pub(crate) const FXMAC_NWCFG_HDRXEN_MASK:u32 = BIT(25);            /* RX half duplex */\n-pub(crate) const FXMAC_NWCFG_RXCHKSUMEN_MASK:u32 = BIT(24);        /* enable RX checksum offload */\n-pub(crate) const FXMAC_NWCFG_PAUSECOPYDI_MASK:u32 = BIT(23);       /* Do not copy pause Frames to memory */\n+pub(crate) const FXMAC_NWCFG_BADPREAMBEN_MASK: u32 = BIT(29); /* disable rejection of non-standard preamble */\n+pub(crate) const FXMAC_NWCFG_IPDSTRETCH_MASK: u32 = BIT(28); /* enable transmit IPG */\n+pub(crate) const FXMAC_NWCFG_SGMII_MODE_ENABLE_MASK: u32 = BIT(27); /* SGMII mode enable */\n+pub(crate) const FXMAC_NWCFG_FCSIGNORE_MASK: u32 = BIT(26); /* disable rejection of FCS error */\n+pub(crate) const FXMAC_NWCFG_HDRXEN_MASK: u32 = BIT(25); /* RX half duplex */\n+pub(crate) const FXMAC_NWCFG_RXCHKSUMEN_MASK: u32 = BIT(24); /* enable RX checksum offload */\n+pub(crate) const FXMAC_NWCFG_PAUSECOPYDI_MASK: u32 = BIT(23); /* Do not copy pause Frames to memory */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 273 to 276)\n-pub(crate) const FXMAC_NWCFG_DWIDTH_64_MASK:u32 = BIT(21);         /* 64 bit Data bus width */\n-pub(crate) const FXMAC_NWCFG_BUS_WIDTH_32_MASK:u32 = (0 << 21);\n-pub(crate) const FXMAC_NWCFG_BUS_WIDTH_64_MASK:u32 = (1 << 21);\n-pub(crate) const FXMAC_NWCFG_BUS_WIDTH_128_MASK:u32 = (2 << 21);\n+pub(crate) const FXMAC_NWCFG_DWIDTH_64_MASK: u32 = BIT(21); /* 64 bit Data bus width */\n+pub(crate) const FXMAC_NWCFG_BUS_WIDTH_32_MASK: u32 = (0 << 21);\n+pub(crate) const FXMAC_NWCFG_BUS_WIDTH_64_MASK: u32 = (1 << 21);\n+pub(crate) const FXMAC_NWCFG_BUS_WIDTH_128_MASK: u32 = (2 << 21);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 278 to 288)\n-pub(crate) const FXMAC_NWCFG_CLOCK_DIV224_MASK:u32 = (7 << 18);\n-pub(crate) const FXMAC_NWCFG_CLOCK_DIV128_MASK:u32 = (6 << 18);\n-pub(crate) const FXMAC_NWCFG_CLOCK_DIV96_MASK:u32 = (5 << 18);\n-pub(crate) const FXMAC_NWCFG_CLOCK_DIV64_MASK:u32 = (4 << 18);\n-pub(crate) const FXMAC_NWCFG_CLOCK_DIV48_MASK:u32 = (3 << 18);\n-pub(crate) const FXMAC_NWCFG_CLOCK_DIV32_MASK:u32 = (2 << 18);\n-pub(crate) const FXMAC_NWCFG_CLOCK_DIV16_MASK:u32 = (1 << 18);\n-pub(crate) const FXMAC_NWCFG_CLOCK_DIV8_MASK:u32 = (0 << 18);\n-pub(crate) const FXMAC_NWCFG_RESET_MASK:u32 = BIT(19);      /* reset value of mdc_clock_division*/\n-pub(crate) const FXMAC_NWCFG_MDC_SHIFT_MASK:u32 = 18;            /* shift bits for MDC */\n-pub(crate) const FXMAC_NWCFG_MDCCLKDIV_MASK:u32 = GENMASK(20, 18); /* MDC Mask PCLK divisor */\n+pub(crate) const FXMAC_NWCFG_CLOCK_DIV224_MASK: u32 = (7 << 18);\n+pub(crate) const FXMAC_NWCFG_CLOCK_DIV128_MASK: u32 = (6 << 18);\n+pub(crate) const FXMAC_NWCFG_CLOCK_DIV96_MASK: u32 = (5 << 18);\n+pub(crate) const FXMAC_NWCFG_CLOCK_DIV64_MASK: u32 = (4 << 18);\n+pub(crate) const FXMAC_NWCFG_CLOCK_DIV48_MASK: u32 = (3 << 18);\n+pub(crate) const FXMAC_NWCFG_CLOCK_DIV32_MASK: u32 = (2 << 18);\n+pub(crate) const FXMAC_NWCFG_CLOCK_DIV16_MASK: u32 = (1 << 18);\n+pub(crate) const FXMAC_NWCFG_CLOCK_DIV8_MASK: u32 = (0 << 18);\n+pub(crate) const FXMAC_NWCFG_RESET_MASK: u32 = BIT(19); /* reset value of mdc_clock_division*/\n+pub(crate) const FXMAC_NWCFG_MDC_SHIFT_MASK: u32 = 18; /* shift bits for MDC */\n+pub(crate) const FXMAC_NWCFG_MDCCLKDIV_MASK: u32 = GENMASK(20, 18); /* MDC Mask PCLK divisor */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 290 to 291)\n-pub(crate) const FXMAC_NWCFG_FCS_REMOVE_MASK:u32 = BIT(17);      /* FCS remove - setting this bit will cause received frames to be written to memory without their frame check sequence (last 4 bytes). */\n-pub(crate) const FXMAC_NWCFG_LENGTH_FIELD_ERROR_FRAME_DISCARD_MASK:u32 = BIT(16);    /* RX length error discard */\n+pub(crate) const FXMAC_NWCFG_FCS_REMOVE_MASK: u32 = BIT(17); /* FCS remove - setting this bit will cause received frames to be written to memory without their frame check sequence (last 4 bytes). */\n+pub(crate) const FXMAC_NWCFG_LENGTH_FIELD_ERROR_FRAME_DISCARD_MASK: u32 = BIT(16); /* RX length error discard */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 293 to 306)\n-pub(crate) const FXMAC_NWCFG_PAUSE_ENABLE_MASK:u32 = BIT(13);    /* Pause enable - when set, transmission will pause if a non-zero 802.3 classic pause frame is received and PFC has not been negotiated. */\n-pub(crate) const FXMAC_NWCFG_RETRYTESTEN_MASK:u32 = BIT(12); /* Retry test */\n-pub(crate) const FXMAC_NWCFG_PCSSEL_MASK:u32 = BIT(11);     /* PCS Select */\n-pub(crate) const FXMAC_NWCFG_1000_MASK:u32 = BIT(10);       /* Gigabit mode enable */\n-pub(crate) const FXMAC_NWCFG_XTADDMACHEN_MASK:u32 = BIT(9); /* External address match enable */\n-pub(crate) const FXMAC_NWCFG_1536RXEN_MASK:u32 = BIT(8);    /* Enable 1536 byte frames reception */\n-pub(crate) const FXMAC_NWCFG_UCASTHASHEN_MASK:u32 = BIT(7); /* Receive unicast hash frames */\n-pub(crate) const FXMAC_NWCFG_MCASTHASHEN_MASK:u32 = BIT(6); /* Receive multicast hash frames */\n-pub(crate) const FXMAC_NWCFG_BCASTDI_MASK:u32 = BIT(5);     /* Do not receive broadcast frames */\n-pub(crate) const FXMAC_NWCFG_COPYALLEN_MASK:u32 = BIT(4);   /* Copy all frames */\n-pub(crate) const FXMAC_NWCFG_JUMBO_MASK:u32 = BIT(3);       /* Jumbo frames */\n-pub(crate) const FXMAC_NWCFG_NVLANDISC_MASK:u32 = BIT(2);   /* Receive only VLAN frames */\n-pub(crate) const FXMAC_NWCFG_FDEN_MASK:u32 = BIT(1);        /* full duplex */\n-pub(crate) const FXMAC_NWCFG_100_MASK:u32 = BIT(0);         /* 100 Mbps */\n+pub(crate) const FXMAC_NWCFG_PAUSE_ENABLE_MASK: u32 = BIT(13); /* Pause enable - when set, transmission will pause if a non-zero 802.3 classic pause frame is received and PFC has not been negotiated. */\n+pub(crate) const FXMAC_NWCFG_RETRYTESTEN_MASK: u32 = BIT(12); /* Retry test */\n+pub(crate) const FXMAC_NWCFG_PCSSEL_MASK: u32 = BIT(11); /* PCS Select */\n+pub(crate) const FXMAC_NWCFG_1000_MASK: u32 = BIT(10); /* Gigabit mode enable */\n+pub(crate) const FXMAC_NWCFG_XTADDMACHEN_MASK: u32 = BIT(9); /* External address match enable */\n+pub(crate) const FXMAC_NWCFG_1536RXEN_MASK: u32 = BIT(8); /* Enable 1536 byte frames reception */\n+pub(crate) const FXMAC_NWCFG_UCASTHASHEN_MASK: u32 = BIT(7); /* Receive unicast hash frames */\n+pub(crate) const FXMAC_NWCFG_MCASTHASHEN_MASK: u32 = BIT(6); /* Receive multicast hash frames */\n+pub(crate) const FXMAC_NWCFG_BCASTDI_MASK: u32 = BIT(5); /* Do not receive broadcast frames */\n+pub(crate) const FXMAC_NWCFG_COPYALLEN_MASK: u32 = BIT(4); /* Copy all frames */\n+pub(crate) const FXMAC_NWCFG_JUMBO_MASK: u32 = BIT(3); /* Jumbo frames */\n+pub(crate) const FXMAC_NWCFG_NVLANDISC_MASK: u32 = BIT(2); /* Receive only VLAN frames */\n+pub(crate) const FXMAC_NWCFG_FDEN_MASK: u32 = BIT(1); /* full duplex */\n+pub(crate) const FXMAC_NWCFG_100_MASK: u32 = BIT(0); /* 100 Mbps */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 308 to 308)\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 320 to 325)\n-pub(crate) const FXMAC_RXBUF_BCAST_MASK:u32 = BIT(31);            /* Broadcast frame */\n-pub(crate) const FXMAC_RXBUF_HASH_MASK:u32 = GENMASK(30, 29);\n-pub(crate) const FXMAC_RXBUF_MULTIHASH_MASK:u32 = BIT(30);        /* Multicast hashed frame */\n-pub(crate) const FXMAC_RXBUF_UNIHASH_MASK:u32 = BIT(29);          /* Unicast hashed frame */\n-pub(crate) const FXMAC_RXBUF_EXH_MASK:u32 = BIT(27);              /* buffer exhausted */\n-pub(crate) const FXMAC_RXBUF_AMATCH_MASK:u32 = GENMASK(26, 25);   /* Specific address \\\n+pub(crate) const FXMAC_RXBUF_BCAST_MASK: u32 = BIT(31); /* Broadcast frame */\n+pub(crate) const FXMAC_RXBUF_HASH_MASK: u32 = GENMASK(30, 29);\n+pub(crate) const FXMAC_RXBUF_MULTIHASH_MASK: u32 = BIT(30); /* Multicast hashed frame */\n+pub(crate) const FXMAC_RXBUF_UNIHASH_MASK: u32 = BIT(29); /* Unicast hashed frame */\n+pub(crate) const FXMAC_RXBUF_EXH_MASK: u32 = BIT(27); /* buffer exhausted */\n+pub(crate) const FXMAC_RXBUF_AMATCH_MASK: u32 = GENMASK(26, 25); /* Specific address \\\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 327 to 337)\n-pub(crate) const FXMAC_RXBUF_IDFOUND_MASK:u32 = BIT(24);          /* Type ID matched */\n-pub(crate) const FXMAC_RXBUF_IDMATCH_MASK:u32 = GENMASK(23, 22);  /* ID matched mask */\n-pub(crate) const FXMAC_RXBUF_VLAN_MASK:u32 = BIT(21);             /* VLAN tagged */\n-pub(crate) const FXMAC_RXBUF_PRI_MASK:u32 = BIT(20);              /* Priority tagged */\n-pub(crate) const FXMAC_RXBUF_VPRI_MASK:u32 = GENMASK(19, 17);     /* Vlan priority */\n-pub(crate) const FXMAC_RXBUF_CFI_MASK:u32 = BIT(16);              /* CFI frame */\n-pub(crate) const FXMAC_RXBUF_EOF_MASK:u32 = BIT(15);              /* End of frame. */\n-pub(crate) const FXMAC_RXBUF_SOF_MASK:u32 = BIT(14);              /* Start of frame. */\n-pub(crate) const FXMAC_RXBUF_FCS_STATUS_MASK:u32 = BIT(13);       /* Status of fcs. */\n-pub(crate) const FXMAC_RXBUF_LEN_MASK:u32 = GENMASK(12, 0);       /* Mask for length field */\n-pub(crate) const FXMAC_RXBUF_LEN_JUMBO_MASK:u32 = GENMASK(13, 0); /* Mask for jumbo length */\n+pub(crate) const FXMAC_RXBUF_IDFOUND_MASK: u32 = BIT(24); /* Type ID matched */\n+pub(crate) const FXMAC_RXBUF_IDMATCH_MASK: u32 = GENMASK(23, 22); /* ID matched mask */\n+pub(crate) const FXMAC_RXBUF_VLAN_MASK: u32 = BIT(21); /* VLAN tagged */\n+pub(crate) const FXMAC_RXBUF_PRI_MASK: u32 = BIT(20); /* Priority tagged */\n+pub(crate) const FXMAC_RXBUF_VPRI_MASK: u32 = GENMASK(19, 17); /* Vlan priority */\n+pub(crate) const FXMAC_RXBUF_CFI_MASK: u32 = BIT(16); /* CFI frame */\n+pub(crate) const FXMAC_RXBUF_EOF_MASK: u32 = BIT(15); /* End of frame. */\n+pub(crate) const FXMAC_RXBUF_SOF_MASK: u32 = BIT(14); /* Start of frame. */\n+pub(crate) const FXMAC_RXBUF_FCS_STATUS_MASK: u32 = BIT(13); /* Status of fcs. */\n+pub(crate) const FXMAC_RXBUF_LEN_MASK: u32 = GENMASK(12, 0); /* Mask for length field */\n+pub(crate) const FXMAC_RXBUF_LEN_JUMBO_MASK: u32 = GENMASK(13, 0); /* Mask for jumbo length */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 339 to 341)\n-pub(crate) const FXMAC_RXBUF_WRAP_MASK:u32 = BIT(1);        /* Wrap bit, last BD */\n-pub(crate) const FXMAC_RXBUF_NEW_MASK:u32 = BIT(0);         /* Used bit.. */\n-pub(crate) const FXMAC_RXBUF_ADD_MASK:u32 = GENMASK(31, 2); /* Mask for address */\n+pub(crate) const FXMAC_RXBUF_WRAP_MASK: u32 = BIT(1); /* Wrap bit, last BD */\n+pub(crate) const FXMAC_RXBUF_NEW_MASK: u32 = BIT(0); /* Used bit.. */\n+pub(crate) const FXMAC_RXBUF_ADD_MASK: u32 = GENMASK(31, 2); /* Mask for address */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 356 to 364)\n-pub(crate) const FXMAC_TXBUF_USED_MASK:u32 = BIT(31);       /* Used bit. */\n-pub(crate) const FXMAC_TXBUF_WRAP_MASK:u32 = BIT(30);       /* Wrap bit, last descriptor */\n-pub(crate) const FXMAC_TXBUF_RETRY_MASK:u32 = BIT(29);      /* Retry limit exceeded */\n-pub(crate) const FXMAC_TXBUF_URUN_MASK:u32 = BIT(28);       /* Transmit underrun occurred */\n-pub(crate) const FXMAC_TXBUF_EXH_MASK:u32 = BIT(27);        /* Buffers exhausted */\n-pub(crate) const FXMAC_TXBUF_TCP_MASK:u32 = BIT(26);        /* Late collision. */\n-pub(crate) const FXMAC_TXBUF_NOCRC_MASK:u32 = BIT(16);      /* No CRC */\n-pub(crate) const FXMAC_TXBUF_LAST_MASK:u32 = BIT(15);       /* Last buffer */\n-pub(crate) const FXMAC_TXBUF_LEN_MASK:u32 = GENMASK(13, 0); /* Mask for length field */\n+pub(crate) const FXMAC_TXBUF_USED_MASK: u32 = BIT(31); /* Used bit. */\n+pub(crate) const FXMAC_TXBUF_WRAP_MASK: u32 = BIT(30); /* Wrap bit, last descriptor */\n+pub(crate) const FXMAC_TXBUF_RETRY_MASK: u32 = BIT(29); /* Retry limit exceeded */\n+pub(crate) const FXMAC_TXBUF_URUN_MASK: u32 = BIT(28); /* Transmit underrun occurred */\n+pub(crate) const FXMAC_TXBUF_EXH_MASK: u32 = BIT(27); /* Buffers exhausted */\n+pub(crate) const FXMAC_TXBUF_TCP_MASK: u32 = BIT(26); /* Late collision. */\n+pub(crate) const FXMAC_TXBUF_NOCRC_MASK: u32 = BIT(16); /* No CRC */\n+pub(crate) const FXMAC_TXBUF_LAST_MASK: u32 = BIT(15); /* Last buffer */\n+pub(crate) const FXMAC_TXBUF_LEN_MASK: u32 = GENMASK(13, 0); /* Mask for length field */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 369 to 369)\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 374 to 377)\n-pub(crate) const FXMAC_RXSR_HRESPNOK_MASK:u32 = BIT(3); /* Receive hresp not OK */\n-pub(crate) const FXMAC_RXSR_RXOVR_MASK:u32 = BIT(2);    /* Receive overrun */\n-pub(crate) const FXMAC_RXSR_FRAMERX_MASK:u32 = BIT(1);  /* Frame received OK */\n-pub(crate) const FXMAC_RXSR_BUFFNA_MASK:u32 = BIT(0);   /* RX buffer used bit set */\n+pub(crate) const FXMAC_RXSR_HRESPNOK_MASK: u32 = BIT(3); /* Receive hresp not OK */\n+pub(crate) const FXMAC_RXSR_RXOVR_MASK: u32 = BIT(2); /* Receive overrun */\n+pub(crate) const FXMAC_RXSR_FRAMERX_MASK: u32 = BIT(1); /* Frame received OK */\n+pub(crate) const FXMAC_RXSR_BUFFNA_MASK: u32 = BIT(0); /* RX buffer used bit set */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 379 to 379)\n-pub(crate) const FXMAC_RXSR_ERROR_MASK:u32 = (FXMAC_RXSR_HRESPNOK_MASK | FXMAC_RXSR_RXOVR_MASK | FXMAC_RXSR_BUFFNA_MASK);\n+pub(crate) const FXMAC_RXSR_ERROR_MASK: u32 =\n+    (FXMAC_RXSR_HRESPNOK_MASK | FXMAC_RXSR_RXOVR_MASK | FXMAC_RXSR_BUFFNA_MASK);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 381 to 381)\n-pub(crate) const FXMAC_SR_ALL_MASK:u32 = GENMASK(31, 0); /* Mask for full register */\n+pub(crate) const FXMAC_SR_ALL_MASK: u32 = GENMASK(31, 0); /* Mask for full register */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 386 to 401)\n-pub(crate) const FXMAC_DMACR_ADDR_WIDTH_64:u32 = BIT(30);       /* 64 bit address bus */\n-pub(crate) const FXMAC_DMACR_TXEXTEND_MASK:u32 = BIT(29);       /* Tx Extended desc mode */\n-pub(crate) const FXMAC_DMACR_RXEXTEND_MASK:u32 = BIT(28);       /* Rx Extended desc mode */\n-pub(crate) const FXMAC_DMACR_ORCE_DISCARD_ON_ERR_MASK:u32 = BIT(24); /* Auto Discard RX frames during lack of resource. */\n-pub(crate) const FXMAC_DMACR_RXBUF_MASK:u32 = GENMASK(23, 16);  /* Mask bit for RX buffer size */\n-pub(crate) const FXMAC_DMACR_RXBUF_SHIFT:u32 = 16;            /* Shift bit for RX buffer size */\n-pub(crate) const FXMAC_DMACR_TCPCKSUM_MASK:u32 = BIT(11);       /* enable/disable TX checksum offload */\n-pub(crate) const FXMAC_DMACR_TXSIZE_MASK:u32 = BIT(10);         /* TX buffer memory size bit[10] */\n-pub(crate) const FXMAC_DMACR_RXSIZE_MASK:u32 = GENMASK(9, 8);   /* RX buffer memory size bit[9:8] */\n-pub(crate) const FXMAC_DMACR_ENDIAN_MASK:u32 = BIT(7);          /* endian configuration */\n-pub(crate) const FXMAC_DMACR_SWAP_MANAGEMENT_MASK:u32 = BIT(6); /*  When clear, selects little endian mode */\n-pub(crate) const FXMAC_DMACR_BLENGTH_MASK:u32 = GENMASK(4, 0);  /* buffer burst length */\n-pub(crate) const FXMAC_DMACR_SINGLE_AHB_AXI_BURST:u32 = BIT(0); /* single AHB_AXI bursts */\n-pub(crate) const FXMAC_DMACR_INCR4_AHB_AXI_BURST:u32 = BIT(2);  /* 4 bytes AHB_AXI bursts */\n-pub(crate) const FXMAC_DMACR_INCR8_AHB_AXI_BURST:u32 = BIT(3);  /* 8 bytes AHB_AXI bursts */\n-pub(crate) const FXMAC_DMACR_INCR16_AHB_AXI_BURST:u32 = BIT(4); /* 16 bytes AHB_AXI bursts */\n+pub(crate) const FXMAC_DMACR_ADDR_WIDTH_64: u32 = BIT(30); /* 64 bit address bus */\n+pub(crate) const FXMAC_DMACR_TXEXTEND_MASK: u32 = BIT(29); /* Tx Extended desc mode */\n+pub(crate) const FXMAC_DMACR_RXEXTEND_MASK: u32 = BIT(28); /* Rx Extended desc mode */\n+pub(crate) const FXMAC_DMACR_ORCE_DISCARD_ON_ERR_MASK: u32 = BIT(24); /* Auto Discard RX frames during lack of resource. */\n+pub(crate) const FXMAC_DMACR_RXBUF_MASK: u32 = GENMASK(23, 16); /* Mask bit for RX buffer size */\n+pub(crate) const FXMAC_DMACR_RXBUF_SHIFT: u32 = 16; /* Shift bit for RX buffer size */\n+pub(crate) const FXMAC_DMACR_TCPCKSUM_MASK: u32 = BIT(11); /* enable/disable TX checksum offload */\n+pub(crate) const FXMAC_DMACR_TXSIZE_MASK: u32 = BIT(10); /* TX buffer memory size bit[10] */\n+pub(crate) const FXMAC_DMACR_RXSIZE_MASK: u32 = GENMASK(9, 8); /* RX buffer memory size bit[9:8] */\n+pub(crate) const FXMAC_DMACR_ENDIAN_MASK: u32 = BIT(7); /* endian configuration */\n+pub(crate) const FXMAC_DMACR_SWAP_MANAGEMENT_MASK: u32 = BIT(6); /*  When clear, selects little endian mode */\n+pub(crate) const FXMAC_DMACR_BLENGTH_MASK: u32 = GENMASK(4, 0); /* buffer burst length */\n+pub(crate) const FXMAC_DMACR_SINGLE_AHB_AXI_BURST: u32 = BIT(0); /* single AHB_AXI bursts */\n+pub(crate) const FXMAC_DMACR_INCR4_AHB_AXI_BURST: u32 = BIT(2); /* 4 bytes AHB_AXI bursts */\n+pub(crate) const FXMAC_DMACR_INCR8_AHB_AXI_BURST: u32 = BIT(3); /* 8 bytes AHB_AXI bursts */\n+pub(crate) const FXMAC_DMACR_INCR16_AHB_AXI_BURST: u32 = BIT(4); /* 16 bytes AHB_AXI bursts */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 405 to 407)\n-pub(crate) const FXMAC_REVISION_MODULE_MASK:u32 = GENMASK(15, 0); /* Module revision */\n-pub(crate) const FXMAC_IDENTIFICATION_MASK:u32 = GENMASK(27, 16); /* Module identification number */\n-pub(crate) const FXMAC_FIX_NUM_MASK:u32 = GENMASK(31, 28);        /*  Fix number - incremented for fix releases */\n+pub(crate) const FXMAC_REVISION_MODULE_MASK: u32 = GENMASK(15, 0); /* Module revision */\n+pub(crate) const FXMAC_IDENTIFICATION_MASK: u32 = GENMASK(27, 16); /* Module identification number */\n+pub(crate) const FXMAC_FIX_NUM_MASK: u32 = GENMASK(31, 28); /*  Fix number - incremented for fix releases */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 412 to 414)\n-pub(crate) const FXMAC_NWSR_MDIOIDLE_MASK:u32 = BIT(2); /* PHY management idle */\n-pub(crate) const FXMAC_NWSR_MDIO_MASK:u32 = BIT(1);     /* Status of mdio_in */\n-pub(crate) const FXMAC_NWSR_PCS_LINK_STATE_MASK:u32 =  BIT(0);\n+pub(crate) const FXMAC_NWSR_MDIOIDLE_MASK: u32 = BIT(2); /* PHY management idle */\n+pub(crate) const FXMAC_NWSR_MDIO_MASK: u32 = BIT(1); /* Status of mdio_in */\n+pub(crate) const FXMAC_NWSR_PCS_LINK_STATE_MASK: u32 = BIT(0);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 419 to 426)\n-pub(crate) const FXMAC_PHYMNTNC_OP_MASK:u32 = (BIT(17) | BIT(30)); /* operation mask bits */\n-pub(crate) const FXMAC_PHYMNTNC_OP_R_MASK:u32 = BIT(29);           /* read operation */\n-pub(crate) const FXMAC_PHYMNTNC_OP_W_MASK:u32 = BIT(28);           /* write operation */\n-pub(crate) const FXMAC_PHYMNTNC_ADDR_MASK:u32 = GENMASK(27, 23);   /* Address bits */\n-pub(crate) const FXMAC_PHYMNTNC_REG_MASK:u32 = GENMASK(22, 18);    /* register bits */\n-pub(crate) const FXMAC_PHYMNTNC_DATA_MASK:u32 = GENMASK(11, 0);    /* data bits */\n-pub(crate) const FXMAC_PHYMNTNC_PHAD_SHFT_MSK:u32 = 23;          /* Shift bits for PHYAD */\n-pub(crate) const FXMAC_PHYMNTNC_PREG_SHFT_MSK:u32 = 18;          /* Shift bits for PHREG */\n+pub(crate) const FXMAC_PHYMNTNC_OP_MASK: u32 = (BIT(17) | BIT(30)); /* operation mask bits */\n+pub(crate) const FXMAC_PHYMNTNC_OP_R_MASK: u32 = BIT(29); /* read operation */\n+pub(crate) const FXMAC_PHYMNTNC_OP_W_MASK: u32 = BIT(28); /* write operation */\n+pub(crate) const FXMAC_PHYMNTNC_ADDR_MASK: u32 = GENMASK(27, 23); /* Address bits */\n+pub(crate) const FXMAC_PHYMNTNC_REG_MASK: u32 = GENMASK(22, 18); /* register bits */\n+pub(crate) const FXMAC_PHYMNTNC_DATA_MASK: u32 = GENMASK(11, 0); /* data bits */\n+pub(crate) const FXMAC_PHYMNTNC_PHAD_SHFT_MSK: u32 = 23; /* Shift bits for PHYAD */\n+pub(crate) const FXMAC_PHYMNTNC_PREG_SHFT_MSK: u32 = 18; /* Shift bits for PHREG */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 431 to 438)\n-pub(crate) const FXMAC_TXSR_HRESPNOK_MASK:u32 = BIT(8); /* Transmit hresp not OK */\n-pub(crate) const FXMAC_TXSR_URUN_MASK:u32 = BIT(6);     /* Transmit underrun */\n-pub(crate) const FXMAC_TXSR_TXCOMPL_MASK:u32 = BIT(5);  /* Transmit completed OK */\n-pub(crate) const FXMAC_TXSR_BUFEXH_MASK:u32 = BIT(4);   /* Transmit buffs exhausted mid frame */\n-pub(crate) const FXMAC_TXSR_TXGO_MASK:u32 = BIT(3);     /* Status of go flag */\n-pub(crate) const FXMAC_TXSR_RXOVR_MASK:u32 = BIT(2);    /* Retry limit exceeded */\n-pub(crate) const FXMAC_TXSR_FRAMERX_MASK:u32 = BIT(1);  /* Collision tx frame */\n-pub(crate) const FXMAC_TXSR_USEDREAD_MASK:u32 = BIT(0); /* TX buffer used bit set */\n+pub(crate) const FXMAC_TXSR_HRESPNOK_MASK: u32 = BIT(8); /* Transmit hresp not OK */\n+pub(crate) const FXMAC_TXSR_URUN_MASK: u32 = BIT(6); /* Transmit underrun */\n+pub(crate) const FXMAC_TXSR_TXCOMPL_MASK: u32 = BIT(5); /* Transmit completed OK */\n+pub(crate) const FXMAC_TXSR_BUFEXH_MASK: u32 = BIT(4); /* Transmit buffs exhausted mid frame */\n+pub(crate) const FXMAC_TXSR_TXGO_MASK: u32 = BIT(3); /* Status of go flag */\n+pub(crate) const FXMAC_TXSR_RXOVR_MASK: u32 = BIT(2); /* Retry limit exceeded */\n+pub(crate) const FXMAC_TXSR_FRAMERX_MASK: u32 = BIT(1); /* Collision tx frame */\n+pub(crate) const FXMAC_TXSR_USEDREAD_MASK: u32 = BIT(0); /* TX buffer used bit set */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 440 to 445)\n-pub(crate) const FXMAC_TXSR_ERROR_MASK:u32 = (FXMAC_TXSR_HRESPNOK_MASK |\n-                               FXMAC_TXSR_URUN_MASK |    \n-                               FXMAC_TXSR_BUFEXH_MASK |  \n-                               FXMAC_TXSR_RXOVR_MASK |   \n-                               FXMAC_TXSR_FRAMERX_MASK | \n-                               FXMAC_TXSR_USEDREAD_MASK);\n+pub(crate) const FXMAC_TXSR_ERROR_MASK: u32 = (FXMAC_TXSR_HRESPNOK_MASK\n+    | FXMAC_TXSR_URUN_MASK\n+    | FXMAC_TXSR_BUFEXH_MASK\n+    | FXMAC_TXSR_RXOVR_MASK\n+    | FXMAC_TXSR_FRAMERX_MASK\n+    | FXMAC_TXSR_USEDREAD_MASK);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 448 to 449)\n- */                                \n-pub(crate) const FXMAC_TXQSEGALLOC_QLOWER_JUMBO_MASK:u32 = BIT(2);  /* 16 segments are distributed to queue 0*/\n+ */\n+pub(crate) const FXMAC_TXQSEGALLOC_QLOWER_JUMBO_MASK: u32 = BIT(2); /* 16 segments are distributed to queue 0*/\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 454 to 455)\n-pub(crate) const FXMAC_INTQ1SR_TXCOMPL_MASK:u32 = BIT(7); /* Transmit completed OK */\n-pub(crate) const FXMAC_INTQ1SR_TXERR_MASK:u32 = BIT(6);   /* Transmit AMBA Error */\n+pub(crate) const FXMAC_INTQ1SR_TXCOMPL_MASK: u32 = BIT(7); /* Transmit completed OK */\n+pub(crate) const FXMAC_INTQ1SR_TXERR_MASK: u32 = BIT(6); /* Transmit AMBA Error */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 457 to 457)\n-pub(crate) const FXMAC_INTQ1_IXR_ALL_MASK:u32 = (FXMAC_INTQ1SR_TXCOMPL_MASK | FXMAC_INTQ1SR_TXERR_MASK);\n+pub(crate) const FXMAC_INTQ1_IXR_ALL_MASK: u32 =\n+    (FXMAC_INTQ1SR_TXCOMPL_MASK | FXMAC_INTQ1SR_TXERR_MASK);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 463 to 466)\n-pub(crate) const FXMAC_INTQUESR_TXCOMPL_MASK:u32 = BIT(7); /* Transmit completed OK */\n-pub(crate) const FXMAC_INTQUESR_TXERR_MASK:u32 = BIT(6);   /* Transmit AMBA Error */\n-pub(crate) const FXMAC_INTQUESR_RCOMP_MASK:u32 = BIT(1);\n-pub(crate) const FXMAC_INTQUESR_RXUBR_MASK:u32 = BIT(2);\n+pub(crate) const FXMAC_INTQUESR_TXCOMPL_MASK: u32 = BIT(7); /* Transmit completed OK */\n+pub(crate) const FXMAC_INTQUESR_TXERR_MASK: u32 = BIT(6); /* Transmit AMBA Error */\n+pub(crate) const FXMAC_INTQUESR_RCOMP_MASK: u32 = BIT(1);\n+pub(crate) const FXMAC_INTQUESR_RXUBR_MASK: u32 = BIT(2);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 468 to 468)\n-pub(crate) const FXMAC_INTQUE_IXR_ALL_MASK:u32 = (FXMAC_INTQUESR_TXCOMPL_MASK | FXMAC_INTQUESR_TXERR_MASK);\n+pub(crate) const FXMAC_INTQUE_IXR_ALL_MASK: u32 =\n+    (FXMAC_INTQUESR_TXCOMPL_MASK | FXMAC_INTQUESR_TXERR_MASK);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 476 to 477)\n-pub(crate) const FXMAC_DESIGNCFG_DEBUG1_BUS_WIDTH_MASK:u32 = GENMASK(27, 25);\n-pub(crate) const FXMAC_DESIGNCFG_DEBUG1_BUS_IRQCOR_MASK:u32 = BIT(23);\n+pub(crate) const FXMAC_DESIGNCFG_DEBUG1_BUS_WIDTH_MASK: u32 = GENMASK(27, 25);\n+pub(crate) const FXMAC_DESIGNCFG_DEBUG1_BUS_IRQCOR_MASK: u32 = BIT(23);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 480 to 482)\n-pub(crate) const FXMAC_GEM_HSMACSPEED_OFFSET:u64 = 0;\n-pub(crate) const FXMAC_GEM_HSMACSPEED_SIZE:u32 = 3;\n-pub(crate) const FXMAC_GEM_HSMACSPEED_MASK:u32 = 0x7;\n+pub(crate) const FXMAC_GEM_HSMACSPEED_OFFSET: u64 = 0;\n+pub(crate) const FXMAC_GEM_HSMACSPEED_SIZE: u32 = 3;\n+pub(crate) const FXMAC_GEM_HSMACSPEED_MASK: u32 = 0x7;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 487 to 489)\n-pub(crate) const FXMAC_BD_ADDR_OFFSET:u64 = 0x00000000;/* word 0/addr of BDs */\n-pub(crate) const FXMAC_BD_STAT_OFFSET:u64 = 4;           /* word 1/status of BDs, 4 bytes */\n-pub(crate) const FXMAC_BD_ADDR_HI_OFFSET:u32 = BIT(3);   /* word 2/addr of BDs */\n+pub(crate) const FXMAC_BD_ADDR_OFFSET: u64 = 0x00000000; /* word 0/addr of BDs */\n+pub(crate) const FXMAC_BD_STAT_OFFSET: u64 = 4; /* word 1/status of BDs, 4 bytes */\n+pub(crate) const FXMAC_BD_ADDR_HI_OFFSET: u32 = BIT(3); /* word 2/addr of BDs */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 494 to 494)\n-pub(crate) const FXMAC_GEM_SAB_MASK:u32 = GENMASK(15, 0); /* Address bits[47:32] bit[31:0] are in BOTTOM */\n+pub(crate) const FXMAC_GEM_SAB_MASK: u32 = GENMASK(15, 0); /* Address bits[47:32] bit[31:0] are in BOTTOM */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 497 to 508)\n-pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_100M:u32 = (0x0 << 14); /* 100M operation */\n-pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_1G:u32 = (0x1 << 14);   /* 1G operation */\n-pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_2_5G:u32 = (0x2 << 14); /* 2.5G operation */\n-pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_5G:u32 =  (0x3 << 14);  /* 5G operation */\n-pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_10G:u32 = (0x4 << 14);  /* 10G operation */\n-pub(crate) const FXMAC_GEM_USX_SERDES_RATE_5G:u32 =    (0x0 << 12);\n-pub(crate) const FXMAC_GEM_USX_SERDES_RATE_10G:u32 =    (0x1 << 12);\n-pub(crate) const FXMAC_GEM_USX_TX_SCR_BYPASS:u32 = BIT(8);          /* RX Scrambler Bypass. Set high to bypass the receive descrambler. */\n-pub(crate) const FXMAC_GEM_USX_RX_SCR_BYPASS:u32 = BIT(9);          /* TX Scrambler Bypass. Set high to bypass the transmit scrambler. */\n-pub(crate) const FXMAC_GEM_USX_RX_SYNC_RESET:u32 = BIT(2);          /* RX Reset. Set high to reset the receive datapath. When low the receive datapath is enabled. */\n-pub(crate) const FXMAC_GEM_USX_TX_DATAPATH_EN:u32 = BIT(1);         /* TX Datapath Enable. */\n-pub(crate) const FXMAC_GEM_USX_SIGNAL_OK:u32 = BIT(0);              /* Enable the USXGMII/BASE-R receive PCS. */\n+pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_100M: u32 = (0x0 << 14); /* 100M operation */\n+pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_1G: u32 = (0x1 << 14); /* 1G operation */\n+pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_2_5G: u32 = (0x2 << 14); /* 2.5G operation */\n+pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_5G: u32 = (0x3 << 14); /* 5G operation */\n+pub(crate) const FXMAC_GEM_USX_HS_MAC_SPEED_10G: u32 = (0x4 << 14); /* 10G operation */\n+pub(crate) const FXMAC_GEM_USX_SERDES_RATE_5G: u32 = (0x0 << 12);\n+pub(crate) const FXMAC_GEM_USX_SERDES_RATE_10G: u32 = (0x1 << 12);\n+pub(crate) const FXMAC_GEM_USX_TX_SCR_BYPASS: u32 = BIT(8); /* RX Scrambler Bypass. Set high to bypass the receive descrambler. */\n+pub(crate) const FXMAC_GEM_USX_RX_SCR_BYPASS: u32 = BIT(9); /* TX Scrambler Bypass. Set high to bypass the transmit scrambler. */\n+pub(crate) const FXMAC_GEM_USX_RX_SYNC_RESET: u32 = BIT(2); /* RX Reset. Set high to reset the receive datapath. When low the receive datapath is enabled. */\n+pub(crate) const FXMAC_GEM_USX_TX_DATAPATH_EN: u32 = BIT(1); /* TX Datapath Enable. */\n+pub(crate) const FXMAC_GEM_USX_SIGNAL_OK: u32 = BIT(0); /* Enable the USXGMII/BASE-R receive PCS. */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 511 to 511)\n-pub(crate) const FXMAC_PCS_CONTROL_ENABLE_AUTO_NEG:u32 = BIT(12); /* Enable auto-negotiation - when set active high, autonegotiation operation is enabled.  */\n+pub(crate) const FXMAC_PCS_CONTROL_ENABLE_AUTO_NEG: u32 = BIT(12); /* Enable auto-negotiation - when set active high, autonegotiation operation is enabled.  */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 513 to 513)\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 515 to 516)\n-pub(crate) const FXMAC_PCS_STATUS_LINK_STATUS_OFFSET:u32 = 2;\n-pub(crate) const FXMAC_PCS_STATUS_LINK_STATUS:u32 = BIT(FXMAC_PCS_STATUS_LINK_STATUS_OFFSET);   /* Link status - indicates the status of the physical connection to the link partner. When set to logic 1 the link is up, and when set to logic 0, the link is down. */\n+pub(crate) const FXMAC_PCS_STATUS_LINK_STATUS_OFFSET: u32 = 2;\n+pub(crate) const FXMAC_PCS_STATUS_LINK_STATUS: u32 = BIT(FXMAC_PCS_STATUS_LINK_STATUS_OFFSET); /* Link status - indicates the status of the physical connection to the link partner. When set to logic 1 the link is up, and when set to logic 0, the link is down. */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 519 to 524)\n-pub(crate) const FXMAC_PCS_AN_LP_SPEED_OFFSET:u64 =   10;\n-pub(crate) const FXMAC_PCS_AN_LP_SPEED:u32 =    (0x3 << FXMAC_PCS_AN_LP_SPEED_OFFSET); /* SGMII 11 : Reserved 10 : 1000 Mbps 01 : 100Mbps 00 : 10 Mbps */\n-pub(crate) const FXMAC_PCS_AN_LP_DUPLEX_OFFSET:u64 =  12;\n-pub(crate) const FXMAC_PCS_AN_LP_DUPLEX:u32 =   (0x3 << FXMAC_PCS_AN_LP_DUPLEX_OFFSET); /* SGMII Bit 13: Reserved. read as 0. Bit 12 : 0 : half-duplex. 1: Full Duplex.\" */\n-pub(crate) const FXMAC_PCS_LINK_PARTNER_NEXT_PAGE_STATUS:u32 = (1 << 15); /* In sgmii mode, 0 is link down . 1 is link up */\n-pub(crate) const FXMAC_PCS_LINK_PARTNER_NEXT_PAGE_OFFSET:u64 = 15;\n+pub(crate) const FXMAC_PCS_AN_LP_SPEED_OFFSET: u64 = 10;\n+pub(crate) const FXMAC_PCS_AN_LP_SPEED: u32 = (0x3 << FXMAC_PCS_AN_LP_SPEED_OFFSET); /* SGMII 11 : Reserved 10 : 1000 Mbps 01 : 100Mbps 00 : 10 Mbps */\n+pub(crate) const FXMAC_PCS_AN_LP_DUPLEX_OFFSET: u64 = 12;\n+pub(crate) const FXMAC_PCS_AN_LP_DUPLEX: u32 = (0x3 << FXMAC_PCS_AN_LP_DUPLEX_OFFSET); /* SGMII Bit 13: Reserved. read as 0. Bit 12 : 0 : half-duplex. 1: Full Duplex.\" */\n+pub(crate) const FXMAC_PCS_LINK_PARTNER_NEXT_PAGE_STATUS: u32 = (1 << 15); /* In sgmii mode, 0 is link down . 1 is link up */\n+pub(crate) const FXMAC_PCS_LINK_PARTNER_NEXT_PAGE_OFFSET: u64 = 15;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 526 to 526)\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 528 to 528)\n-pub(crate) const FXMAC_GEM_USX_STATUS_BLOCK_LOCK:u32 = BIT(0);  /* Block Lock. A value of one indicates that the PCS has achieved block synchronization. */\n+pub(crate) const FXMAC_GEM_USX_STATUS_BLOCK_LOCK: u32 = BIT(0); /* Block Lock. A value of one indicates that the PCS has achieved block synchronization. */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 536 to 540)\n-pub const fn GENMASK(h:u32, l: u32) -> u32 {\n-    (\n-    (!(0 as u64) - (1 << l) + 1) &\n-     (!(0 as u64) >> (BITS_PER_LONG - 1 - h))\n-    ) as u32\n+pub const fn GENMASK(h: u32, l: u32) -> u32 {\n+    ((!(0 as u64) - (1 << l) + 1) & (!(0 as u64) >> (BITS_PER_LONG - 1 - h))) as u32\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 546 to 546)\n-pub(crate) const FXMAC_PROMISC_OPTION:u32 = 0x00000001;\n+pub(crate) const FXMAC_PROMISC_OPTION: u32 = 0x00000001;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 550 to 550)\n-pub(crate) const FXMAC_FRAME1536_OPTION:u32 = 0x00000002;\n+pub(crate) const FXMAC_FRAME1536_OPTION: u32 = 0x00000002;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 554 to 554)\n-pub(crate) const FXMAC_VLAN_OPTION:u32 = 0x00000004;\n+pub(crate) const FXMAC_VLAN_OPTION: u32 = 0x00000004;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 558 to 558)\n-pub(crate) const FXMAC_FLOW_CONTROL_OPTION:u32 = 0x00000010;\n+pub(crate) const FXMAC_FLOW_CONTROL_OPTION: u32 = 0x00000010;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 562 to 562)\n-pub(crate) const FXMAC_FCS_STRIP_OPTION:u32 = 0x00000020;\n+pub(crate) const FXMAC_FCS_STRIP_OPTION: u32 = 0x00000020;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 567 to 567)\n-pub(crate) const FXMAC_FCS_INSERT_OPTION:u32 = 0x00000040;\n+pub(crate) const FXMAC_FCS_INSERT_OPTION: u32 = 0x00000040;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 571 to 571)\n-pub(crate) const FXMAC_LENTYPE_ERR_OPTION:u32 = 0x00000080;\n+pub(crate) const FXMAC_LENTYPE_ERR_OPTION: u32 = 0x00000080;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 580 to 580)\n-pub(crate) const FXMAC_TRANSMITTER_ENABLE_OPTION:u32 = 0x00000100;\n+pub(crate) const FXMAC_TRANSMITTER_ENABLE_OPTION: u32 = 0x00000100;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 584 to 584)\n-pub(crate) const FXMAC_RECEIVER_ENABLE_OPTION:u32 = 0x00000200;\n+pub(crate) const FXMAC_RECEIVER_ENABLE_OPTION: u32 = 0x00000200;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 588 to 588)\n-pub(crate) const FXMAC_BROADCAST_OPTION:u32 = 0x00000400;\n+pub(crate) const FXMAC_BROADCAST_OPTION: u32 = 0x00000400;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 592 to 592)\n-pub(crate) const FXMAC_MULTICAST_OPTION:u32 = 0x00000800;\n+pub(crate) const FXMAC_MULTICAST_OPTION: u32 = 0x00000800;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 596 to 596)\n-pub(crate) const FXMAC_RX_CHKSUM_ENABLE_OPTION:u32 = 0x00001000;\n+pub(crate) const FXMAC_RX_CHKSUM_ENABLE_OPTION: u32 = 0x00001000;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 600 to 600)\n-pub(crate) const FXMAC_TX_CHKSUM_ENABLE_OPTION:u32 = 0x00002000;\n+pub(crate) const FXMAC_TX_CHKSUM_ENABLE_OPTION: u32 = 0x00002000;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 604 to 605)\n-pub(crate) const FXMAC_JUMBO_ENABLE_OPTION:u32 = 0x00004000;\n-pub(crate) const FXMAC_SGMII_ENABLE_OPTION:u32 = 0x00008000;\n+pub(crate) const FXMAC_JUMBO_ENABLE_OPTION: u32 = 0x00004000;\n+pub(crate) const FXMAC_SGMII_ENABLE_OPTION: u32 = 0x00008000;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 607 to 608)\n-pub(crate) const FXMAC_LOOPBACK_NO_MII_OPTION:u32 = 0x00010000;\n-pub(crate) const FXMAC_LOOPBACK_USXGMII_OPTION:u32 = 0x00020000;\n+pub(crate) const FXMAC_LOOPBACK_NO_MII_OPTION: u32 = 0x00010000;\n+pub(crate) const FXMAC_LOOPBACK_USXGMII_OPTION: u32 = 0x00020000;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 610 to 610)\n-pub(crate) const FXMAC_UNICAST_OPTION:u32 = 0x00040000;\n+pub(crate) const FXMAC_UNICAST_OPTION: u32 = 0x00040000;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 612 to 612)\n-pub(crate) const FXMAC_TAIL_PTR_OPTION:u32 = 0x00080000;\n+pub(crate) const FXMAC_TAIL_PTR_OPTION: u32 = 0x00080000;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 614 to 614)\n+pub(crate) const FXMAC_DEFAULT_OPTIONS: u32 = (FXMAC_FLOW_CONTROL_OPTION\n+    | FXMAC_FCS_INSERT_OPTION\n+    | FXMAC_FCS_STRIP_OPTION\n+    | FXMAC_BROADCAST_OPTION\n+    | FXMAC_LENTYPE_ERR_OPTION\n+    | FXMAC_TRANSMITTER_ENABLE_OPTION\n+    | FXMAC_RECEIVER_ENABLE_OPTION\n+    | FXMAC_RX_CHKSUM_ENABLE_OPTION\n+    | FXMAC_TX_CHKSUM_ENABLE_OPTION);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 615 to 625)\n-pub(crate) const FXMAC_DEFAULT_OPTIONS:u32 =               \n-    (FXMAC_FLOW_CONTROL_OPTION |       \n-     FXMAC_FCS_INSERT_OPTION |         \n-     FXMAC_FCS_STRIP_OPTION |          \n-     FXMAC_BROADCAST_OPTION |          \n-     FXMAC_LENTYPE_ERR_OPTION |        \n-     FXMAC_TRANSMITTER_ENABLE_OPTION | \n-     FXMAC_RECEIVER_ENABLE_OPTION |    \n-     FXMAC_RX_CHKSUM_ENABLE_OPTION |   \n-     FXMAC_TX_CHKSUM_ENABLE_OPTION);\n-     \n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 629 to 629)\n-pub(crate) const FXMAC_MAC_ADDR_SIZE:u32 = 6; /* size of Ethernet header */\n+pub(crate) const FXMAC_MAC_ADDR_SIZE: u32 = 6; /* size of Ethernet header */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 631 to 635)\n-pub(crate) const FXMAC_MTU:u32 = 1500;         /* max MTU size of Ethernet frame */\n-pub(crate) const FXMAC_MTU_JUMBO:u32 = 10240;  /* max MTU size of jumbo frame including Ip header + IP payload */\n-pub(crate) const FXMAC_HDR_SIZE:u32 = 14;      /* size of Ethernet header  , DA + SA + TYPE*/\n-pub(crate) const FXMAC_HDR_VLAN_SIZE:u32 = 18; /* size of Ethernet header with VLAN */\n-pub(crate) const FXMAC_TRL_SIZE:u32 = 4;       /* size of Ethernet trailer (FCS) */\n+pub(crate) const FXMAC_MTU: u32 = 1500; /* max MTU size of Ethernet frame */\n+pub(crate) const FXMAC_MTU_JUMBO: u32 = 10240; /* max MTU size of jumbo frame including Ip header + IP payload */\n+pub(crate) const FXMAC_HDR_SIZE: u32 = 14; /* size of Ethernet header  , DA + SA + TYPE*/\n+pub(crate) const FXMAC_HDR_VLAN_SIZE: u32 = 18; /* size of Ethernet header with VLAN */\n+pub(crate) const FXMAC_TRL_SIZE: u32 = 4; /* size of Ethernet trailer (FCS) */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 637 to 638)\n-pub(crate) const FXMAC_MAX_FRAME_SIZE:u32 = (FXMAC_MTU + FXMAC_HDR_SIZE + FXMAC_TRL_SIZE);\n-pub(crate) const FXMAC_MAX_FRAME_SIZE_JUMBO:u32 = (FXMAC_MTU_JUMBO + FXMAC_HDR_SIZE + FXMAC_TRL_SIZE);\n+pub(crate) const FXMAC_MAX_FRAME_SIZE: u32 = (FXMAC_MTU + FXMAC_HDR_SIZE + FXMAC_TRL_SIZE);\n+pub(crate) const FXMAC_MAX_FRAME_SIZE_JUMBO: u32 =\n+    (FXMAC_MTU_JUMBO + FXMAC_HDR_SIZE + FXMAC_TRL_SIZE);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 640 to 641)\n-pub(crate) const FXMAC_MAX_VLAN_FRAME_SIZE:u32 = (FXMAC_MTU + FXMAC_HDR_SIZE + FXMAC_HDR_VLAN_SIZE + FXMAC_TRL_SIZE);\n-pub(crate) const FXMAC_MAX_VLAN_FRAME_SIZE_JUMBO:u32 = (FXMAC_MTU_JUMBO + FXMAC_HDR_SIZE + FXMAC_HDR_VLAN_SIZE + FXMAC_TRL_SIZE);\n+pub(crate) const FXMAC_MAX_VLAN_FRAME_SIZE: u32 =\n+    (FXMAC_MTU + FXMAC_HDR_SIZE + FXMAC_HDR_VLAN_SIZE + FXMAC_TRL_SIZE);\n+pub(crate) const FXMAC_MAX_VLAN_FRAME_SIZE_JUMBO: u32 =\n+    (FXMAC_MTU_JUMBO + FXMAC_HDR_SIZE + FXMAC_HDR_VLAN_SIZE + FXMAC_TRL_SIZE);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 648 to 652)\n-pub(crate) const FXMAC_HANDLER_DMASEND:u32 = 1;        /* 发送中断 */\n-pub(crate) const FXMAC_HANDLER_DMARECV:u32 = 2;        /* 接收中断 */\n-pub(crate) const FXMAC_HANDLER_ERROR:u32 = 3;          /* 异常中断 */\n-pub(crate) const FXMAC_HANDLER_LINKCHANGE:u32 = 4;     /* 连接状态 */\n-pub(crate) const FXMAC_HANDLER_RESTART:u32 = 5;        /* 发送描述符队列发生异常 */\n+pub(crate) const FXMAC_HANDLER_DMASEND: u32 = 1; /* 发送中断 */\n+pub(crate) const FXMAC_HANDLER_DMARECV: u32 = 2; /* 接收中断 */\n+pub(crate) const FXMAC_HANDLER_ERROR: u32 = 3; /* 异常中断 */\n+pub(crate) const FXMAC_HANDLER_LINKCHANGE: u32 = 4; /* 连接状态 */\n+pub(crate) const FXMAC_HANDLER_RESTART: u32 = 5; /* 发送描述符队列发生异常 */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 655 to 656)\n-pub(crate) const FXMAC_DMA_SG_IS_STARTED:u32 = 0;\n-pub(crate) const FXMAC_DMA_SG_IS_STOPED:u32 = 1;\n+pub(crate) const FXMAC_DMA_SG_IS_STARTED: u32 = 0;\n+pub(crate) const FXMAC_DMA_SG_IS_STOPED: u32 = 1;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 658 to 664)\n-pub(crate) const FXMAC_SPEED_10:u32 = 10;\n-pub(crate) const FXMAC_SPEED_100:u32 = 100;\n-pub(crate) const FXMAC_SPEED_1000:u32 = 1000;\n-pub(crate) const FXMAC_SPEED_2500:u32 = 2500;\n-pub(crate) const FXMAC_SPEED_5000:u32 = 5000;\n-pub(crate) const FXMAC_SPEED_10000:u32 = 10000;\n-pub(crate) const FXMAC_SPEED_25000:u32 = 25000;\n+pub(crate) const FXMAC_SPEED_10: u32 = 10;\n+pub(crate) const FXMAC_SPEED_100: u32 = 100;\n+pub(crate) const FXMAC_SPEED_1000: u32 = 1000;\n+pub(crate) const FXMAC_SPEED_2500: u32 = 2500;\n+pub(crate) const FXMAC_SPEED_5000: u32 = 5000;\n+pub(crate) const FXMAC_SPEED_10000: u32 = 10000;\n+pub(crate) const FXMAC_SPEED_25000: u32 = 25000;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 667 to 668)\n-pub(crate) const FXMAC_CAPS_ISR_CLEAR_ON_WRITE:u32 =   0x00000001; /* irq status parameters need to be written to clear after they have been read */\n-pub(crate) const FXMAC_CAPS_TAILPTR:u32 =              0x00000002; /* use tail ptr */\n+pub(crate) const FXMAC_CAPS_ISR_CLEAR_ON_WRITE: u32 = 0x00000001; /* irq status parameters need to be written to clear after they have been read */\n+pub(crate) const FXMAC_CAPS_TAILPTR: u32 = 0x00000002; /* use tail ptr */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_const.rs (original lines from 683 to 683)\n+\n"
            ]
          }
        },
        {
          "file": "src/fxmac_phy.rs",
          "features": "",
          "count": 81,
          "kinds": {
            "Unformatted": [
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 1 to 1)\n-use crate::fxmac_const::*;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 3 to 3)\n+use crate::fxmac_const::*;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 26 to 26)\n-pub const PHY_STAT_LINK_STATUS: u16 =              0x0004;\n+pub const PHY_STAT_LINK_STATUS: u16 = 0x0004;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 32 to 38)\n-pub const PHY_AUTOADVERTISE_10HALF: u16 = 0x0020;        /* Try for 10mbps half-duplex  */\n-pub const PHY_AUTOADVERTISE_1000XFULL: u16 = 0x0020;     /* Try for 1000BASE-X full-duplex */\n-pub const PHY_AUTOADVERTISE_10FULL: u16 = 0x0040;        /* Try for 10mbps full-duplex  */\n-pub const PHY_AUTOADVERTISE_1000XHALF: u16 = 0x0040;     /* Try for 1000BASE-X half-duplex */\n-pub const PHY_AUTOADVERTISE_100HALF: u16 = 0x0080;       /* Try for 100mbps half-duplex */\n-pub const PHY_AUTOADVERTISE_1000XPAUSE: u16 = 0x0080;    /* Try for 1000BASE-X pause    */\n-pub const PHY_AUTOADVERTISE_100FULL: u16 = 0x0100;       /* Try for 100mbps full-duplex */\n+pub const PHY_AUTOADVERTISE_10HALF: u16 = 0x0020; /* Try for 10mbps half-duplex  */\n+pub const PHY_AUTOADVERTISE_1000XFULL: u16 = 0x0020; /* Try for 1000BASE-X full-duplex */\n+pub const PHY_AUTOADVERTISE_10FULL: u16 = 0x0040; /* Try for 10mbps full-duplex  */\n+pub const PHY_AUTOADVERTISE_1000XHALF: u16 = 0x0040; /* Try for 1000BASE-X half-duplex */\n+pub const PHY_AUTOADVERTISE_100HALF: u16 = 0x0080; /* Try for 100mbps half-duplex */\n+pub const PHY_AUTOADVERTISE_1000XPAUSE: u16 = 0x0080; /* Try for 1000BASE-X pause    */\n+pub const PHY_AUTOADVERTISE_100FULL: u16 = 0x0100; /* Try for 100mbps full-duplex */\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 40 to 41)\n-pub const PHY_AUTOADVERTISE_100BASE4: u16 = 0x0200;      /* Try for 100mbps 4k packets  */\n-pub const PHY_AUTOADVERTISE_100_AND_10: u16 = (PHY_AUTOADVERTISE_10FULL | PHY_AUTOADVERTISE_100FULL | PHY_AUTOADVERTISE_10HALF | PHY_AUTOADVERTISE_100HALF);\n+pub const PHY_AUTOADVERTISE_100BASE4: u16 = 0x0200; /* Try for 100mbps 4k packets  */\n+pub const PHY_AUTOADVERTISE_100_AND_10: u16 = (PHY_AUTOADVERTISE_10FULL\n+    | PHY_AUTOADVERTISE_100FULL\n+    | PHY_AUTOADVERTISE_10HALF\n+    | PHY_AUTOADVERTISE_100HALF);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 56 to 56)\n-pub const FXMAC_PHY_MAX_NUM:u32 = 32;\n+pub const FXMAC_PHY_MAX_NUM: u32 = 32;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 69 to 70)\n-pub fn FXmacPhyWrite(instance_p: &mut FXmac, phy_address: u32, register_num: u32, phy_data: u16) -> u32\n-{\n+pub fn FXmacPhyWrite(\n+    instance_p: &mut FXmac,\n+    phy_address: u32,\n+    register_num: u32,\n+    phy_data: u16,\n+) -> u32 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 76 to 76)\n-    debug!(\"FXmacPhyWrite, phy_address={:#x}, register_num={}, phy_data={:#x}\", phy_address, register_num, phy_data);\n+    debug!(\n+        \"FXmacPhyWrite, phy_address={:#x}, register_num={}, phy_data={:#x}\",\n+        phy_address, register_num, phy_data\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 79 to 81)\n-    if (read_reg((instance_p.config.base_address + FXMAC_NWSR_OFFSET) as *const u32) &\n-           FXMAC_NWSR_MDIOIDLE_MASK) == 0\n-    {   \n+    if (read_reg((instance_p.config.base_address + FXMAC_NWSR_OFFSET) as *const u32)\n+        & FXMAC_NWSR_MDIOIDLE_MASK)\n+        == 0\n+    {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 84 to 84)\n-    }else{   \n+    } else {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 86 to 88)\n-        mgtcr = FXMAC_PHYMNTNC_OP_MASK | FXMAC_PHYMNTNC_OP_W_MASK |\n-                (phy_address << FXMAC_PHYMNTNC_PHAD_SHFT_MSK) |\n-                (register_num << FXMAC_PHYMNTNC_PREG_SHFT_MSK) | phy_data as u32;\n+        mgtcr = FXMAC_PHYMNTNC_OP_MASK\n+            | FXMAC_PHYMNTNC_OP_W_MASK\n+            | (phy_address << FXMAC_PHYMNTNC_PHAD_SHFT_MSK)\n+            | (register_num << FXMAC_PHYMNTNC_PREG_SHFT_MSK)\n+            | phy_data as u32;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 91 to 91)\n-        write_reg((instance_p.config.base_address + FXMAC_PHYMNTNC_OFFSET) as *mut u32, mgtcr);\n+        write_reg(\n+            (instance_p.config.base_address + FXMAC_PHYMNTNC_OFFSET) as *mut u32,\n+            mgtcr,\n+        );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 93 to 93)\n-        loop{\n+        loop {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 108 to 109)\n-pub fn FXmacPhyRead(instance_p: &mut FXmac, phy_address: u32, register_num: u32, phydat_aptr: &mut u16) -> u32\n-{\n+pub fn FXmacPhyRead(\n+    instance_p: &mut FXmac,\n+    phy_address: u32,\n+    register_num: u32,\n+    phydat_aptr: &mut u16,\n+) -> u32 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 116 to 117)\n-    if (read_reg((instance_p.config.base_address + FXMAC_NWSR_OFFSET) as *const u32) & FXMAC_NWSR_MDIOIDLE_MASK) == 0\n-    {   \n+    if (read_reg((instance_p.config.base_address + FXMAC_NWSR_OFFSET) as *const u32)\n+        & FXMAC_NWSR_MDIOIDLE_MASK)\n+        == 0\n+    {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 120 to 120)\n-    }else{   \n+    } else {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 122 to 124)\n-        mgtcr = FXMAC_PHYMNTNC_OP_MASK | FXMAC_PHYMNTNC_OP_R_MASK |\n-        (phy_address << FXMAC_PHYMNTNC_PHAD_SHFT_MSK) |\n-        (register_num << FXMAC_PHYMNTNC_PREG_SHFT_MSK);\n+        mgtcr = FXMAC_PHYMNTNC_OP_MASK\n+            | FXMAC_PHYMNTNC_OP_R_MASK\n+            | (phy_address << FXMAC_PHYMNTNC_PHAD_SHFT_MSK)\n+            | (register_num << FXMAC_PHYMNTNC_PREG_SHFT_MSK);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 127 to 127)\n-        write_reg((instance_p.config.base_address + FXMAC_PHYMNTNC_OFFSET) as *mut u32, mgtcr);\n+        write_reg(\n+            (instance_p.config.base_address + FXMAC_PHYMNTNC_OFFSET) as *mut u32,\n+            mgtcr,\n+        );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 129 to 129)\n-        loop{\n+        loop {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 139 to 139)\n-        *phydat_aptr = read_reg((instance_p.config.base_address + FXMAC_PHYMNTNC_OFFSET) as *const u32) as u16;\n+        *phydat_aptr =\n+            read_reg((instance_p.config.base_address + FXMAC_PHYMNTNC_OFFSET) as *const u32) as u16;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 141 to 141)\n-    debug!(\"FXmacPhyRead, phy_address={:#x}, register_num={}, phydat_aptr={:#x}\", phy_address, register_num, phydat_aptr);\n+        debug!(\n+            \"FXmacPhyRead, phy_address={:#x}, register_num={}, phydat_aptr={:#x}\",\n+            phy_address, register_num, phydat_aptr\n+        );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 145 to 145)\n-    \n+\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 149 to 149)\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 152 to 155)\n-pub fn FXmacPhyInit(\n-    instance_p: &mut FXmac,\n-    reset_flag: u32,\n-) -> u32 {\n+pub fn FXmacPhyInit(instance_p: &mut FXmac, reset_flag: u32) -> u32 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 159 to 163)\n-    info!(\"FXmacPhyInit, speed={}, duplex_mode={}, autonegotiation_en={}, reset_flag={}\",\n-    speed,\n-        duplex_mode,\n-        autonegotiation_en,\n-        reset_flag\n+    info!(\n+        \"FXmacPhyInit, speed={}, duplex_mode={}, autonegotiation_en={}, reset_flag={}\",\n+        speed, duplex_mode, autonegotiation_en, reset_flag\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 183 to 183)\n-    assert!(speed != FXMAC_SPEED_1000, \"The speed must be 100M or 10M!\");\n+        assert!(speed != FXMAC_SPEED_1000, \"The speed must be 100M or 10M!\");\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 196 to 197)\n-pub fn FXmacDetect(instance_p: &mut FXmac, phy_addr_p: &mut u32) -> u32\n-{\n+pub fn FXmacDetect(instance_p: &mut FXmac, phy_addr_p: &mut u32) -> u32 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 203 to 204)\n-    for phy_addr in 0..FXMAC_PHY_MAX_NUM\n-    {   \n+    for phy_addr in 0..FXMAC_PHY_MAX_NUM {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 206 to 207)\n-        if (ret != FT_SUCCESS)\n-        {\n+        if (ret != FT_SUCCESS) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 213 to 214)\n-        if (phy_reg != 0xffff)\n-        {\n+        if (phy_reg != 0xffff) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 217 to 217)\n-            info!(\"Phy id1 reg is {:#x}, Phy id2 reg is {:#x}\", phy_id1_reg , phy_id2_reg);\n+            info!(\n+                \"Phy id1 reg is {:#x}, Phy id2 reg is {:#x}\",\n+                phy_id1_reg, phy_id2_reg\n+            );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 219 to 219)\n-            if ((ret == FT_SUCCESS) && (phy_id2_reg != 0) && (phy_id2_reg != 0xffff) && (phy_id1_reg != 0xffff))\n+            if ((ret == FT_SUCCESS)\n+                && (phy_id2_reg != 0)\n+                && (phy_id2_reg != 0xffff)\n+                && (phy_id1_reg != 0xffff))\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 233 to 234)\n-pub fn FXmacPhyReset(instance_p: &mut FXmac, phy_addr: u32) -> u32\n- {\n+pub fn FXmacPhyReset(instance_p: &mut FXmac, phy_addr: u32) -> u32 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 236 to 261)\n- \n-     let mut ret: u32 = FXmacPhyRead(instance_p, phy_addr, PHY_CONTROL_REG_OFFSET, &mut control);\n-     if (ret != FT_SUCCESS)\n-     {\n-         error!(\"FXmacPhyReset, read PHY_CONTROL_REG_OFFSET is error\");\n-         return ret;\n-     }\n- \n-     control |= PHY_CONTROL_RESET_MASK;\n- \n-     ret = FXmacPhyWrite(instance_p, phy_addr, PHY_CONTROL_REG_OFFSET, control);\n-     if (ret != FT_SUCCESS)\n-     {\n-         error!(\"FXmacPhyReset, write PHY_CONTROL_REG_OFFSET is error\");\n-         return ret;\n-     }\n- \n-     loop\n-     {\n-         ret = FXmacPhyRead(instance_p, phy_addr, PHY_CONTROL_REG_OFFSET, &mut control);\n-         if (ret != FT_SUCCESS)\n-         {\n-             error!(\"FXmacPhyReset, read PHY_CONTROL_REG_OFFSET is error\");\n-             return ret;\n-         }\n-         if (control & PHY_CONTROL_RESET_MASK) == 0 {\n+\n+    let mut ret: u32 = FXmacPhyRead(instance_p, phy_addr, PHY_CONTROL_REG_OFFSET, &mut control);\n+    if (ret != FT_SUCCESS) {\n+        error!(\"FXmacPhyReset, read PHY_CONTROL_REG_OFFSET is error\");\n+        return ret;\n+    }\n+\n+    control |= PHY_CONTROL_RESET_MASK;\n+\n+    ret = FXmacPhyWrite(instance_p, phy_addr, PHY_CONTROL_REG_OFFSET, control);\n+    if (ret != FT_SUCCESS) {\n+        error!(\"FXmacPhyReset, write PHY_CONTROL_REG_OFFSET is error\");\n+        return ret;\n+    }\n+\n+    loop {\n+        ret = FXmacPhyRead(instance_p, phy_addr, PHY_CONTROL_REG_OFFSET, &mut control);\n+        if (ret != FT_SUCCESS) {\n+            error!(\"FXmacPhyReset, read PHY_CONTROL_REG_OFFSET is error\");\n+            return ret;\n+        }\n+        if (control & PHY_CONTROL_RESET_MASK) == 0 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 263 to 268)\n-         }\n-     }\n- \n-     info!(\"Phy reset end.\");\n-     ret\n- }\n+        }\n+    }\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 270 to 270)\n+    info!(\"Phy reset end.\");\n+    ret\n+}\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 271 to 272)\n-pub fn FXmacGetIeeePhySpeed(instance_p: &mut FXmac, phy_addr: u32) -> u32\n-{\n+pub fn FXmacGetIeeePhySpeed(instance_p: &mut FXmac, phy_addr: u32) -> u32 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 282 to 283)\n-    if (ret != FT_SUCCESS)\n-    {\n+    if (ret != FT_SUCCESS) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 291 to 292)\n-    if (ret != FT_SUCCESS)\n-    {\n+    if (ret != FT_SUCCESS) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 298 to 298)\n-    loop{\n+    loop {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 303 to 304)\n-        if (ret != FT_SUCCESS)\n-        {\n+        if (ret != FT_SUCCESS) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 309 to 309)\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 311 to 312)\n-        if (negotitation_timeout_cnt >= 0xff)\n-        {\n+        if (negotitation_timeout_cnt >= 0xff) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 314 to 314)\n-            return 8;//FXMAC_PHY_AUTO_AUTONEGOTIATION_FAILED;\n+            return 8; //FXMAC_PHY_AUTO_AUTONEGOTIATION_FAILED;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 318 to 318)\n-            break\n+            break;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 321 to 321)\n-    \n+\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 325 to 326)\n-    if (ret != FT_SUCCESS)\n-    {\n+    if (ret != FT_SUCCESS) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 333 to 334)\n-    if (ret != FT_SUCCESS)\n-    {\n+    if (ret != FT_SUCCESS) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 341 to 342)\n-    if (temp & (1 << 13)) != 0\n-    {\n+    if (temp & (1 << 13)) != 0 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 345 to 347)\n-    }\n-    else\n-    {\n+    } else {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 352 to 353)\n-    if (temp & 0xC000) == PHY_SPECIFIC_STATUS_SPEED_1000M\n-    {\n+    if (temp & 0xC000) == PHY_SPECIFIC_STATUS_SPEED_1000M {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 356 to 358)\n-    }\n-    else if (temp & 0xC000) == PHY_SPECIFIC_STATUS_SPEED_100M\n-    {\n+    } else if (temp & 0xC000) == PHY_SPECIFIC_STATUS_SPEED_100M {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 361 to 363)\n-    }\n-    else\n-    {\n+    } else {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 371 to 374)\n-pub fn FXmacConfigureIeeePhySpeed(instance_p: &mut FXmac, phy_addr: u32, speed: u32, duplex_mode: u32) -> u32\n-{\n-    let mut control: u16 = 0;;\n-    let mut autonereg: u16 = 0;;\n+pub fn FXmacConfigureIeeePhySpeed(\n+    instance_p: &mut FXmac,\n+    phy_addr: u32,\n+    speed: u32,\n+    duplex_mode: u32,\n+) -> u32 {\n+    let mut control: u16 = 0;\n+    let mut autonereg: u16 = 0;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 377 to 377)\n-    info!(\"Manual setting, phy_addr is {:#x},speed {}, duplex_mode is {}.\", phy_addr, speed, duplex_mode);\n+    info!(\n+        \"Manual setting, phy_addr is {:#x},speed {}, duplex_mode is {}.\",\n+        phy_addr, speed, duplex_mode\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 379 to 381)\n-    let mut ret: u32 = FXmacPhyRead(instance_p, phy_addr, PHY_AUTONEGO_ADVERTISE_REG, &mut autonereg);\n-    if (ret != FT_SUCCESS)\n-    {\n+    let mut ret: u32 = FXmacPhyRead(\n+        instance_p,\n+        phy_addr,\n+        PHY_AUTONEGO_ADVERTISE_REG,\n+        &mut autonereg,\n+    );\n+    if (ret != FT_SUCCESS) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 389 to 390)\n-    if (ret != FT_SUCCESS)\n-    {\n+    if (ret != FT_SUCCESS) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 396 to 397)\n-    if (ret != FT_SUCCESS)\n-    {\n+    if (ret != FT_SUCCESS) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 407 to 408)\n-    if speed == 100\n-    {\n+    if speed == 100 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 410 to 412)\n-    }\n-    else if speed == 10\n-    {\n+    } else if speed == 10 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 416 to 417)\n-    if duplex_mode == 1\n-    {\n+    if duplex_mode == 1 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 419 to 421)\n-    }\n-    else\n-    {\n+    } else {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 430 to 431)\n-    if (ret != FT_SUCCESS)\n-    {\n+    if (ret != FT_SUCCESS) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 441 to 443)\n-    ret = FXmacPhyRead(instance_p, phy_addr, PHY_SPECIFIC_STATUS_REG, &mut specific_reg);\n-    if (ret != FT_SUCCESS)\n-    {\n+    ret = FXmacPhyRead(\n+        instance_p,\n+        phy_addr,\n+        PHY_SPECIFIC_STATUS_REG,\n+        &mut specific_reg,\n+    );\n+    if (ret != FT_SUCCESS) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 450 to 451)\n-    if (specific_reg & (1 << 13)) != 0\n-    {\n+    if (specific_reg & (1 << 13)) != 0 {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 454 to 456)\n-    }\n-    else\n-    {\n+    } else {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 461 to 462)\n-    if (specific_reg & 0xC000) == PHY_SPECIFIC_STATUS_SPEED_100M\n-    {\n+    if (specific_reg & 0xC000) == PHY_SPECIFIC_STATUS_SPEED_100M {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_phy.rs (original lines from 465 to 467)\n-    }\n-    else\n-    {\n+    } else {\n"
            ],
            "Clippy(Warn)": [
              "warning: these look like formatting arguments but are not part of a formatting macro\n  --> src/fxmac_phy.rs:76:40\n   |\n76 |     debug!(\"FXmacPhyWrite, phy_address={:#x}, register_num={}, phy_data={:#x}\", phy_address, register_num, phy_data);\n   |                                        ^^^^^                            ^^^^^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: these look like formatting arguments but are not part of a formatting macro\n  --> src/fxmac_phy.rs:76:40\n   |\n76 |     debug!(\"FXmacPhyWrite, phy_address={:#x}, register_num={}, phy_data={:#x}\", phy_address, register_num, phy_data);\n   |                                        ^^^^^                            ^^^^^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_phy.rs:141:39\n    |\n141 |     debug!(\"FXmacPhyRead, phy_address={:#x}, register_num={}, phydat_aptr={:#x}\", phy_address, register_num, phydat_aptr);\n    |                                       ^^^^^                               ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_phy.rs:141:39\n    |\n141 |     debug!(\"FXmacPhyRead, phy_address={:#x}, register_num={}, phydat_aptr={:#x}\", phy_address, register_num, phydat_aptr);\n    |                                       ^^^^^                               ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_phy.rs:211:34\n    |\n211 |         info!(\"Phy status reg is {:#x}\", phy_reg);\n    |                                  ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_phy.rs:217:35\n    |\n217 |             info!(\"Phy id1 reg is {:#x}, Phy id2 reg is {:#x}\", phy_id1_reg , phy_id2_reg);\n    |                                   ^^^^^                 ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: these look like formatting arguments but are not part of a formatting macro\n   --> src/fxmac_phy.rs:217:35\n    |\n217 |             info!(\"Phy id1 reg is {:#x}, Phy id2 reg is {:#x}\", phy_id1_reg , phy_id2_reg);\n    |                                   ^^^^^                 ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_phy.rs:223:36\n    |\n223 |                 info!(\"Phy addr is {:#x}\", phy_addr);\n    |                                    ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_phy.rs:331:20\n    |\n331 |     info!(\"Temp is {:#x}\", temp);\n    |                    ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_phy.rs:339:21\n    |\n339 |     info!(\"Temp2 is {:#x}\", temp2);\n    |                     ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_phy.rs:377:40\n    |\n377 |     info!(\"Manual setting, phy_addr is {:#x},speed {}, duplex_mode is {}.\", phy_addr, speed, duplex_mode);\n    |                                        ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_phy.rs:401:38\n    |\n401 |     info!(\"PHY_CONTROL_REG_OFFSET is {:#x}.\", control);\n    |                                      ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_phy.rs:448:28\n    |\n448 |     info!(\"Specific reg is {:#x}\", specific_reg);\n    |                            ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
            ]
          }
        },
        {
          "file": "src/fxmac_intr.rs",
          "features": "",
          "count": 49,
          "kinds": {
            "Unformatted": [
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 6 to 6)\n-use crate::fxmac_const::*;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 8 to 8)\n+use crate::fxmac_const::*;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 11 to 56)\n-pub const FXMAC_NUM:u32 = 4;\n-pub const FXMAC0_ID:u32 = 0;\n-pub const FXMAC1_ID:u32 = 1;\n-pub const FXMAC2_ID:u32 = 2;\n-pub const FXMAC3_ID:u32 = 3;\n-pub const FXMAC0_BASE_ADDR:u32 =  0x3200C000;\n-pub const FXMAC1_BASE_ADDR:u32 =  0x3200E000;\n-pub const FXMAC2_BASE_ADDR:u32 =  0x32010000;\n-pub const FXMAC3_BASE_ADDR:u32 =  0x32012000;\n-pub const FXMAC0_MODE_SEL_BASE_ADDR:u32 =  0x3200DC00;\n-pub const FXMAC0_LOOPBACK_SEL_BASE_ADDR:u32 =  0x3200DC04;\n-pub const FXMAC1_MODE_SEL_BASE_ADDR:u32 =  0x3200FC00;\n-pub const FXMAC1_LOOPBACK_SEL_BASE_ADDR:u32 =  0x3200FC04;\n-pub const FXMAC2_MODE_SEL_BASE_ADDR:u32 =  0x32011C00;\n-pub const FXMAC2_LOOPBACK_SEL_BASE_ADDR:u32 =  0x32011C04;\n-pub const FXMAC3_MODE_SEL_BASE_ADDR:u32 =  0x32013C00;\n-pub const FXMAC3_LOOPBACK_SEL_BASE_ADDR:u32 =  0x32013C04;\n-pub const FXMAC0_PCLK:u32 = 50000000;\n-pub const FXMAC1_PCLK:u32 = 50000000;\n-pub const FXMAC2_PCLK:u32 = 50000000;\n-pub const FXMAC3_PCLK:u32 = 50000000;\n-pub const FXMAC0_HOTPLUG_IRQ_NUM:u32 = (53 + 30);\n-pub const FXMAC1_HOTPLUG_IRQ_NUM:u32 = (54 + 30);\n-pub const FXMAC2_HOTPLUG_IRQ_NUM:u32 = (55 + 30);\n-pub const FXMAC3_HOTPLUG_IRQ_NUM:u32 = (56 + 30);\n-pub const FXMAC_QUEUE_MAX_NUM:u32 = 16; // #define FXMAC_QUEUE_MAX_NUM 16U\n-pub const FXMAC0_QUEUE0_IRQ_NUM:u32 = (57 + 30);\n-pub const FXMAC0_QUEUE1_IRQ_NUM:u32 = (58 + 30);\n-pub const FXMAC0_QUEUE2_IRQ_NUM:u32 = (59 + 30);\n-pub const FXMAC0_QUEUE3_IRQ_NUM:u32 = (60 + 30);\n-pub const FXMAC0_QUEUE4_IRQ_NUM:u32 = (30 + 30);\n-pub const FXMAC0_QUEUE5_IRQ_NUM:u32 = (31 + 30);\n-pub const FXMAC0_QUEUE6_IRQ_NUM:u32 = (32 + 30);\n-pub const FXMAC0_QUEUE7_IRQ_NUM:u32 = (33 + 30);\n-pub const FXMAC1_QUEUE0_IRQ_NUM:u32 = (61 + 30);\n-pub const FXMAC1_QUEUE1_IRQ_NUM:u32 = (62 + 30);\n-pub const FXMAC1_QUEUE2_IRQ_NUM:u32 = (63 + 30);\n-pub const FXMAC1_QUEUE3_IRQ_NUM:u32 = (64 + 30);\n-pub const FXMAC2_QUEUE0_IRQ_NUM:u32 = (66 + 30);\n-pub const FXMAC2_QUEUE1_IRQ_NUM:u32 = (67 + 30);\n-pub const FXMAC2_QUEUE2_IRQ_NUM:u32 = (68 + 30);\n-pub const FXMAC2_QUEUE3_IRQ_NUM:u32 = (69 + 30);\n-pub const FXMAC3_QUEUE0_IRQ_NUM:u32 = (70 + 30);\n-pub const FXMAC3_QUEUE1_IRQ_NUM:u32 = (71 + 30);\n-pub const FXMAC3_QUEUE2_IRQ_NUM:u32 = (72 + 30);\n-pub const FXMAC3_QUEUE3_IRQ_NUM:u32 = (73 + 30);\n+pub const FXMAC_NUM: u32 = 4;\n+pub const FXMAC0_ID: u32 = 0;\n+pub const FXMAC1_ID: u32 = 1;\n+pub const FXMAC2_ID: u32 = 2;\n+pub const FXMAC3_ID: u32 = 3;\n+pub const FXMAC0_BASE_ADDR: u32 = 0x3200C000;\n+pub const FXMAC1_BASE_ADDR: u32 = 0x3200E000;\n+pub const FXMAC2_BASE_ADDR: u32 = 0x32010000;\n+pub const FXMAC3_BASE_ADDR: u32 = 0x32012000;\n+pub const FXMAC0_MODE_SEL_BASE_ADDR: u32 = 0x3200DC00;\n+pub const FXMAC0_LOOPBACK_SEL_BASE_ADDR: u32 = 0x3200DC04;\n+pub const FXMAC1_MODE_SEL_BASE_ADDR: u32 = 0x3200FC00;\n+pub const FXMAC1_LOOPBACK_SEL_BASE_ADDR: u32 = 0x3200FC04;\n+pub const FXMAC2_MODE_SEL_BASE_ADDR: u32 = 0x32011C00;\n+pub const FXMAC2_LOOPBACK_SEL_BASE_ADDR: u32 = 0x32011C04;\n+pub const FXMAC3_MODE_SEL_BASE_ADDR: u32 = 0x32013C00;\n+pub const FXMAC3_LOOPBACK_SEL_BASE_ADDR: u32 = 0x32013C04;\n+pub const FXMAC0_PCLK: u32 = 50000000;\n+pub const FXMAC1_PCLK: u32 = 50000000;\n+pub const FXMAC2_PCLK: u32 = 50000000;\n+pub const FXMAC3_PCLK: u32 = 50000000;\n+pub const FXMAC0_HOTPLUG_IRQ_NUM: u32 = (53 + 30);\n+pub const FXMAC1_HOTPLUG_IRQ_NUM: u32 = (54 + 30);\n+pub const FXMAC2_HOTPLUG_IRQ_NUM: u32 = (55 + 30);\n+pub const FXMAC3_HOTPLUG_IRQ_NUM: u32 = (56 + 30);\n+pub const FXMAC_QUEUE_MAX_NUM: u32 = 16; // #define FXMAC_QUEUE_MAX_NUM 16U\n+pub const FXMAC0_QUEUE0_IRQ_NUM: u32 = (57 + 30);\n+pub const FXMAC0_QUEUE1_IRQ_NUM: u32 = (58 + 30);\n+pub const FXMAC0_QUEUE2_IRQ_NUM: u32 = (59 + 30);\n+pub const FXMAC0_QUEUE3_IRQ_NUM: u32 = (60 + 30);\n+pub const FXMAC0_QUEUE4_IRQ_NUM: u32 = (30 + 30);\n+pub const FXMAC0_QUEUE5_IRQ_NUM: u32 = (31 + 30);\n+pub const FXMAC0_QUEUE6_IRQ_NUM: u32 = (32 + 30);\n+pub const FXMAC0_QUEUE7_IRQ_NUM: u32 = (33 + 30);\n+pub const FXMAC1_QUEUE0_IRQ_NUM: u32 = (61 + 30);\n+pub const FXMAC1_QUEUE1_IRQ_NUM: u32 = (62 + 30);\n+pub const FXMAC1_QUEUE2_IRQ_NUM: u32 = (63 + 30);\n+pub const FXMAC1_QUEUE3_IRQ_NUM: u32 = (64 + 30);\n+pub const FXMAC2_QUEUE0_IRQ_NUM: u32 = (66 + 30);\n+pub const FXMAC2_QUEUE1_IRQ_NUM: u32 = (67 + 30);\n+pub const FXMAC2_QUEUE2_IRQ_NUM: u32 = (68 + 30);\n+pub const FXMAC2_QUEUE3_IRQ_NUM: u32 = (69 + 30);\n+pub const FXMAC3_QUEUE0_IRQ_NUM: u32 = (70 + 30);\n+pub const FXMAC3_QUEUE1_IRQ_NUM: u32 = (71 + 30);\n+pub const FXMAC3_QUEUE2_IRQ_NUM: u32 = (72 + 30);\n+pub const FXMAC3_QUEUE3_IRQ_NUM: u32 = (73 + 30);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 67 to 67)\n-         let xmac_ptr = unsafe{ &mut (*xmac)};\n+        let xmac_ptr = unsafe { &mut (*xmac) };\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 69 to 71)\n-         // maybe irq num\n-         let vector = xmac_ptr.config.queue_irq_num[0] ;\n-         FXmacIntrHandler(vector as i32, xmac_ptr);\n+        // maybe irq num\n+        let vector = xmac_ptr.config.queue_irq_num[0];\n+        FXmacIntrHandler(vector as i32, xmac_ptr);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 73 to 75)\n-         info!(\"xmac intr is already handled\");\n-} else {\n-    error!(\"static FXmac has not been initialized\");\n+        info!(\"xmac intr is already handled\");\n+    } else {\n+        error!(\"static FXmac has not been initialized\");\n+    }\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 78 to 79)\n-}\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 85 to 85)\n-/// \n+///\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 87 to 87)\n-     assert!(instance_p.is_ready == FT_COMPONENT_IS_READY as u32);\n+    assert!(instance_p.is_ready == FT_COMPONENT_IS_READY as u32);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 89 to 92)\n-     // 0 ~ FXMAC_QUEUE_MAX_NUM ,Index queue number\n-     let tx_queue_id = instance_p.tx_bd_queue.queue_id;\n-     // 0 ~ FXMAC_QUEUE_MAX_NUM ,Index queue number\n-     let rx_queue_id = instance_p.rx_bd_queue.queue_id;\n+    // 0 ~ FXMAC_QUEUE_MAX_NUM ,Index queue number\n+    let tx_queue_id = instance_p.tx_bd_queue.queue_id;\n+    // 0 ~ FXMAC_QUEUE_MAX_NUM ,Index queue number\n+    let rx_queue_id = instance_p.rx_bd_queue.queue_id;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 94 to 101)\n-     assert!((rx_queue_id < FXMAC_QUEUE_MAX_NUM) && (tx_queue_id < FXMAC_QUEUE_MAX_NUM));\n- \n-     /* This ISR will try to handle as many interrupts as it can in a single\n-      * call. However, in most of the places where the user's error handler\n-      * is called, this ISR exits because it is expected that the user will\n-      * reset the device in nearly all instances.\n-      */\n-     let mut reg_isr: u32 = read_reg((instance_p.config.base_address + FXMAC_ISR_OFFSET) as *const u32);\n+    assert!((rx_queue_id < FXMAC_QUEUE_MAX_NUM) && (tx_queue_id < FXMAC_QUEUE_MAX_NUM));\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 103 to 118)\n-     info!(\"+++++++++ IRQ num vector={}, Interrupt Status ISR={:#x}, tx_queue_id={}, rx_queue_id={}\", vector, reg_isr, tx_queue_id, rx_queue_id);\n- \n-     if vector as u32 == instance_p.config.queue_irq_num[tx_queue_id as usize] {\n-         if tx_queue_id == 0\n-         {\n-             if (reg_isr & FXMAC_IXR_TXCOMPL_MASK) != 0\n-             {\n-                 // Clear TX status register TX complete indication but preserve error bits if there is any\n-        write_reg((instance_p.config.base_address + FXMAC_TXSR_OFFSET) as *mut u32, FXMAC_TXSR_TXCOMPL_MASK | FXMAC_TXSR_USEDREAD_MASK);\n-                \n-                     FXmacSendHandler(instance_p);\n- \n-                 /* add */\n-                 if(instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0\n-                 {\n-        write_reg((instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32, FXMAC_IXR_TXCOMPL_MASK);\n+    /* This ISR will try to handle as many interrupts as it can in a single\n+     * call. However, in most of the places where the user's error handler\n+     * is called, this ISR exits because it is expected that the user will\n+     * reset the device in nearly all instances.\n+     */\n+    let mut reg_isr: u32 =\n+        read_reg((instance_p.config.base_address + FXMAC_ISR_OFFSET) as *const u32);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 120 to 128)\n-                 }\n-             }\n- \n-             /* Transmit error conditions interrupt */\n-             if ((reg_isr & FXMAC_IXR_TX_ERR_MASK) != 0) &&\n-                 ((reg_isr & FXMAC_IXR_TXCOMPL_MASK) == 0)\n-             {\n-                 /* Clear TX status register */\n-                 let reg_txsr: u32 = read_reg((instance_p.config.base_address + FXMAC_TXSR_OFFSET) as *const u32);\n+    info!(\n+        \"+++++++++ IRQ num vector={}, Interrupt Status ISR={:#x}, tx_queue_id={}, rx_queue_id={}\",\n+        vector, reg_isr, tx_queue_id, rx_queue_id\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 130 to 130)\n-        write_reg((instance_p.config.base_address + FXMAC_TXSR_OFFSET) as *mut u32, reg_txsr);\n+    if vector as u32 == instance_p.config.queue_irq_num[tx_queue_id as usize] {\n+        if tx_queue_id == 0 {\n+            if (reg_isr & FXMAC_IXR_TXCOMPL_MASK) != 0 {\n+                // Clear TX status register TX complete indication but preserve error bits if there is any\n+                write_reg(\n+                    (instance_p.config.base_address + FXMAC_TXSR_OFFSET) as *mut u32,\n+                    FXMAC_TXSR_TXCOMPL_MASK | FXMAC_TXSR_USEDREAD_MASK,\n+                );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 132 to 132)\n-                    FXmacErrorHandler(instance_p, FXMAC_SEND as u8, reg_txsr);\n+                FXmacSendHandler(instance_p);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 134 to 147)\n-                 /* add */\n-                 if(instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0\n-                 {\n-        write_reg((instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32, FXMAC_IXR_TX_ERR_MASK);\n-                 }\n-             }\n- \n-             /* add restart */\n-             if (reg_isr & FXMAC_IXR_TXUSED_MASK) != 0\n-             {\n-                 /* add */\n-                 if(instance_p.caps& FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0\n-                 {\n-        write_reg((instance_p.config.base_address+FXMAC_ISR_OFFSET) as *mut u32, FXMAC_IXR_TXUSED_MASK);\n+                /* add */\n+                if (instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0 {\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32,\n+                        FXMAC_IXR_TXCOMPL_MASK,\n+                    );\n+                }\n+            }\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 149 to 181)\n-                 }\n- \n-                 /*\n-                 if (instance_p->restart_handler)\n-                 {\n-                     instance_p->restart_handler(instance_p->restart_args);\n-                 }\n-                 */\n-             }\n-             \n-             /* link changed */\n-             if (reg_isr & FXMAC_IXR_LINKCHANGE_MASK) != 0\n-             {\n-        \n-                    FXmacLinkChange(instance_p);\n- \n-                 if(instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0\n-                 {\n-                     write_reg((instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32, FXMAC_IXR_LINKCHANGE_MASK);\n-                 }\n-             }\n-         }\n-         else /* use queue number more than 0 */\n-         {\n-             reg_isr = read_reg((instance_p.config.base_address + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, tx_queue_id)) as *const u32);\n- \n-             /* Transmit Q1 complete interrupt */\n-             if ((reg_isr & FXMAC_INTQUESR_TXCOMPL_MASK) != 0)\n-             {\n-                 /* Clear TX status register TX complete indication but preserve\n-                  * error bits if there is any */\n-                write_reg((instance_p.config.base_address + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, tx_queue_id)) as *mut u32, FXMAC_INTQUESR_TXCOMPL_MASK);\n-                write_reg((instance_p.config.base_address + FXMAC_TXSR_OFFSET) as *mut u32, (FXMAC_TXSR_TXCOMPL_MASK | FXMAC_TXSR_USEDREAD_MASK) as u32);\n+            /* Transmit error conditions interrupt */\n+            if ((reg_isr & FXMAC_IXR_TX_ERR_MASK) != 0) && ((reg_isr & FXMAC_IXR_TXCOMPL_MASK) == 0)\n+            {\n+                /* Clear TX status register */\n+                let reg_txsr: u32 =\n+                    read_reg((instance_p.config.base_address + FXMAC_TXSR_OFFSET) as *const u32);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 183 to 183)\n+                write_reg(\n+                    (instance_p.config.base_address + FXMAC_TXSR_OFFSET) as *mut u32,\n+                    reg_txsr,\n+                );\n+\n+                FXmacErrorHandler(instance_p, FXMAC_SEND as u8, reg_txsr);\n+\n+                /* add */\n+                if (instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0 {\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32,\n+                        FXMAC_IXR_TX_ERR_MASK,\n+                    );\n+                }\n+            }\n+\n+            /* add restart */\n+            if (reg_isr & FXMAC_IXR_TXUSED_MASK) != 0 {\n+                /* add */\n+                if (instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0 {\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32,\n+                        FXMAC_IXR_TXUSED_MASK,\n+                    );\n+                }\n+\n+                /*\n+                if (instance_p->restart_handler)\n+                {\n+                    instance_p->restart_handler(instance_p->restart_args);\n+                }\n+                */\n+            }\n+\n+            /* link changed */\n+            if (reg_isr & FXMAC_IXR_LINKCHANGE_MASK) != 0 {\n+                FXmacLinkChange(instance_p);\n+\n+                if (instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0 {\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32,\n+                        FXMAC_IXR_LINKCHANGE_MASK,\n+                    );\n+                }\n+            }\n+        } else\n+        /* use queue number more than 0 */\n+        {\n+            reg_isr = read_reg(\n+                (instance_p.config.base_address\n+                    + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, tx_queue_id))\n+                    as *const u32,\n+            );\n+\n+            /* Transmit Q1 complete interrupt */\n+            if ((reg_isr & FXMAC_INTQUESR_TXCOMPL_MASK) != 0) {\n+                /* Clear TX status register TX complete indication but preserve\n+                 * error bits if there is any */\n+                write_reg(\n+                    (instance_p.config.base_address\n+                        + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, tx_queue_id))\n+                        as *mut u32,\n+                    FXMAC_INTQUESR_TXCOMPL_MASK,\n+                );\n+                write_reg(\n+                    (instance_p.config.base_address + FXMAC_TXSR_OFFSET) as *mut u32,\n+                    (FXMAC_TXSR_TXCOMPL_MASK | FXMAC_TXSR_USEDREAD_MASK) as u32,\n+                );\n+\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 184 to 191)\n-             }\n- \n-             /* Transmit Q1 error conditions interrupt */\n-             if (((reg_isr & FXMAC_INTQ1SR_TXERR_MASK) != 0) &&\n-                 ((reg_isr & FXMAC_INTQ1SR_TXCOMPL_MASK) != 0))\n-             {\n-                 /* Clear Interrupt Q1 status register */\n-                 write_reg((instance_p.config.base_address + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, tx_queue_id)) as *mut u32, reg_isr);\n+            }\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 193 to 193)\n+            /* Transmit Q1 error conditions interrupt */\n+            if (((reg_isr & FXMAC_INTQ1SR_TXERR_MASK) != 0)\n+                && ((reg_isr & FXMAC_INTQ1SR_TXCOMPL_MASK) != 0))\n+            {\n+                /* Clear Interrupt Q1 status register */\n+                write_reg(\n+                    (instance_p.config.base_address\n+                        + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, tx_queue_id))\n+                        as *mut u32,\n+                    reg_isr,\n+                );\n+\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 194 to 207)\n-             }\n-         }\n-     }\n- \n-     if vector as u32 == instance_p.config.queue_irq_num[rx_queue_id as usize]\n-     {\n-         if rx_queue_id == 0\n-         {\n-             /* Receive complete interrupt */\n-             if (reg_isr & FXMAC_IXR_RXCOMPL_MASK) != 0\n-             {\n-                 /* Clear RX status register RX complete indication but preserve\n-                  * error bits if there is any */\n-                 write_reg((instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *mut u32, (FXMAC_RXSR_FRAMERX_MASK | FXMAC_RXSR_BUFFNA_MASK) as u32);\n+            }\n+        }\n+    }\n+\n+    if vector as u32 == instance_p.config.queue_irq_num[rx_queue_id as usize] {\n+        if rx_queue_id == 0 {\n+            /* Receive complete interrupt */\n+            if (reg_isr & FXMAC_IXR_RXCOMPL_MASK) != 0 {\n+                /* Clear RX status register RX complete indication but preserve\n+                 * error bits if there is any */\n+                write_reg(\n+                    (instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *mut u32,\n+                    (FXMAC_RXSR_FRAMERX_MASK | FXMAC_RXSR_BUFFNA_MASK) as u32,\n+                );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 209 to 221)\n- \n-                 /* add */\n-                 if(instance_p.caps& FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0\n-                 {\n-                     write_reg((instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32, FXMAC_IXR_RXCOMPL_MASK);\n-                 }\n-             }\n- \n-             /* Receive error conditions interrupt */\n-             if (reg_isr & FXMAC_IXR_RX_ERR_MASK) != 0 {\n-                 /* Clear RX status register */\n-                 let mut reg_rxsr: u32 = read_reg((instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *const u32);\n-                 write_reg((instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *mut u32, reg_rxsr);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 223 to 224)\n-                 if (reg_isr & FXMAC_IXR_RXUSED_MASK) != 0 {\n-                     let reg_ctrl: u32 = read_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32);\n+                /* add */\n+                if (instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0 {\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32,\n+                        FXMAC_IXR_RXCOMPL_MASK,\n+                    );\n+                }\n+            }\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 226 to 314)\n-                     let mut reg_temp: u32 = reg_ctrl | FXMAC_NWCTRL_FLUSH_DPRAM_MASK as u32;\n-                     reg_temp &= (!FXMAC_NWCTRL_RXEN_MASK) as u32;\n-                     write_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32, reg_temp);\n- \n-                     /* add  */\n-                     reg_temp = reg_ctrl | FXMAC_NWCTRL_RXEN_MASK as u32;\n-                     write_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32, reg_temp);\n-                                     \n-                     if(instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0\n-                     {\n-                         write_reg((instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32, FXMAC_IXR_RXUSED_MASK);\n-                     }\n-                 }\n- \n-                 /* add */\n-                 if ((reg_isr & FXMAC_IXR_RXOVR_MASK) != 0) && ((instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0) {\n-                         write_reg((instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32, FXMAC_IXR_RXOVR_MASK);\n-                 }\n- \n-                 /* add */\n-                 if ((reg_isr & FXMAC_IXR_HRESPNOK_MASK) != 0) && ((instance_p.caps& FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0) {\n-                         write_reg((instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32, FXMAC_IXR_HRESPNOK_MASK);\n-                 }\n- \n-                 if reg_rxsr != 0 {\n-                    FXmacErrorHandler(instance_p, FXMAC_RECV as u8, reg_rxsr);\n-                 }\n-             }\n-         } else { /* use queue number more than 0 */\n-             reg_isr = read_reg((instance_p.config.base_address + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, rx_queue_id)) as *const u32);\n- \n-             /* Receive complete interrupt */\n-             if ((reg_isr & FXMAC_INTQUESR_RCOMP_MASK) != 0)\n-             {\n-                 /* Clear RX status register RX complete indication but preserve\n-                  * error bits if there is any */\n-                  write_reg((instance_p.config.base_address + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, rx_queue_id)) as *mut u32, FXMAC_INTQUESR_RCOMP_MASK);\n-                  FXmacRecvIsrHandler(instance_p);\n-             }\n- \n-             /* Receive error conditions interrupt */\n-             if (reg_isr & FXMAC_IXR_RX_ERR_MASK) != 0\n-             {\n- \n-                 let mut reg_ctrl: u32 = read_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32);\n-                 reg_ctrl &= !(FXMAC_NWCTRL_RXEN_MASK as u32);\n- \n-                 write_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32, reg_ctrl);\n- \n-                 /* Clear RX status register */\n-                 let mut reg_rxsr = read_reg((instance_p.config.base_address + FXMAC_RXSR_OFFSET)as *const u32);\n-                 write_reg((instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *mut u32, reg_rxsr);\n- \n-                 if ((reg_isr & FXMAC_IXR_RXUSED_MASK) != 0)\n-                 {\n-                     reg_ctrl = read_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32);\n-                     reg_ctrl |= FXMAC_NWCTRL_FLUSH_DPRAM_MASK;\n- \n-                     write_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32, reg_ctrl);\n-                 }\n- \n-                 /* Clear RX status register RX complete indication but preserve\n-                  * error bits if there is any */\n-                  write_reg((instance_p.config.base_address + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, rx_queue_id)) as *mut u32, FXMAC_INTQUESR_RXUBR_MASK);\n-                  FXmacRecvIsrHandler(instance_p);\n- \n-                 if reg_rxsr != 0\n-                 {\n-                    FXmacErrorHandler(instance_p, FXMAC_RECV as u8, reg_rxsr);\n-                 }\n-             }\n-         }\n-     }\n- }\n- \n- /**\n-  * @name: FXmacQueueIrqDisable\n-  * @msg:  Disable queue irq\n-  * @param {FXmac} *instance_p a pointer to the instance to be worked on.\n-  * @param {u32} queue_num queue number\n-  * @param {u32} mask is interrupt disable value mask\n-  */\n- pub fn FXmacQueueIrqDisable(instance_p: &mut FXmac, queue_num: u32, mask: u32)\n- {\n-     assert!(instance_p.is_ready == FT_COMPONENT_IS_READY as u32);\n-     assert!(instance_p.config.max_queue_num > queue_num);\n- \n-     if queue_num == 0 {\n-    write_reg((instance_p.config.base_address + FXMAC_IDR_OFFSET) as *mut u32, mask & FXMAC_IXR_ALL_MASK);\n+            /* Receive error conditions interrupt */\n+            if (reg_isr & FXMAC_IXR_RX_ERR_MASK) != 0 {\n+                /* Clear RX status register */\n+                let mut reg_rxsr: u32 =\n+                    read_reg((instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *const u32);\n+                write_reg(\n+                    (instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *mut u32,\n+                    reg_rxsr,\n+                );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 316 to 317)\n-     } else {\n-    write_reg((instance_p.config.base_address + FXMAC_INTQX_IDR_SIZE_OFFSET(queue_num as u64)) as *mut u32, mask & FXMAC_IXR_ALL_MASK);\n+                if (reg_isr & FXMAC_IXR_RXUSED_MASK) != 0 {\n+                    let reg_ctrl: u32 = read_reg(\n+                        (instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32,\n+                    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 319 to 329)\n-     }\n- }\n- \n- /// FXmacQueueIrqEnable, Enable queue irq\n- pub fn FXmacQueueIrqEnable(instance_p: &mut FXmac, queue_num: u32, mask: u32)\n- {\n-     assert!(instance_p.is_ready == FT_COMPONENT_IS_READY as u32);\n-     assert!(instance_p.config.max_queue_num > queue_num);\n- \n-     if queue_num == 0 {\n-    write_reg((instance_p.config.base_address + FXMAC_IER_OFFSET) as *mut u32, mask & FXMAC_IXR_ALL_MASK);\n+                    let mut reg_temp: u32 = reg_ctrl | FXMAC_NWCTRL_FLUSH_DPRAM_MASK as u32;\n+                    reg_temp &= (!FXMAC_NWCTRL_RXEN_MASK) as u32;\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32,\n+                        reg_temp,\n+                    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 331 to 332)\n-     } else {\n-    write_reg((instance_p.config.base_address + FXMAC_INTQX_IER_SIZE_OFFSET(queue_num as u64)) as *mut u32, mask & FXMAC_IXR_ALL_MASK);\n+                    /* add  */\n+                    reg_temp = reg_ctrl | FXMAC_NWCTRL_RXEN_MASK as u32;\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32,\n+                        reg_temp,\n+                    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 334 to 348)\n-     }\n- }\n- \n-pub fn FXmacErrorHandler(instance_p: &mut FXmac, direction: u8, error_word: u32)\n-{\n-    debug!(\"-> FXmacErrorHandler, direction={}, error_word={}\", direction, error_word);\n-    if error_word != 0\n-    {\n-        match direction as u32\n-        {\n-         FXMAC_RECV => {\n-            if (error_word & FXMAC_RXSR_HRESPNOK_MASK) != 0\n-            {\n-                error!(\"Receive DMA error\");\n-                FXmacHandleDmaTxError(instance_p);\n+                    if (instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0 {\n+                        write_reg(\n+                            (instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32,\n+                            FXMAC_IXR_RXUSED_MASK,\n+                        );\n+                    }\n+                }\n+\n+                /* add */\n+                if ((reg_isr & FXMAC_IXR_RXOVR_MASK) != 0)\n+                    && ((instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0)\n+                {\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32,\n+                        FXMAC_IXR_RXOVR_MASK,\n+                    );\n+                }\n+\n+                /* add */\n+                if ((reg_isr & FXMAC_IXR_HRESPNOK_MASK) != 0)\n+                    && ((instance_p.caps & FXMAC_CAPS_ISR_CLEAR_ON_WRITE) != 0)\n+                {\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_ISR_OFFSET) as *mut u32,\n+                        FXMAC_IXR_HRESPNOK_MASK,\n+                    );\n+                }\n+\n+                if reg_rxsr != 0 {\n+                    FXmacErrorHandler(instance_p, FXMAC_RECV as u8, reg_rxsr);\n+                }\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 350 to 353)\n-            if (error_word & FXMAC_RXSR_RXOVR_MASK) != 0\n-            {\n-                error!(\"Receive over run\");\n-                //FXmacRecvHandler(instance_p);\n+        } else {\n+            /* use queue number more than 0 */\n+            reg_isr = read_reg(\n+                (instance_p.config.base_address\n+                    + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, rx_queue_id))\n+                    as *const u32,\n+            );\n+\n+            /* Receive complete interrupt */\n+            if ((reg_isr & FXMAC_INTQUESR_RCOMP_MASK) != 0) {\n+                /* Clear RX status register RX complete indication but preserve\n+                 * error bits if there is any */\n+                write_reg(\n+                    (instance_p.config.base_address\n+                        + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, rx_queue_id))\n+                        as *mut u32,\n+                    FXMAC_INTQUESR_RCOMP_MASK,\n+                );\n+                FXmacRecvIsrHandler(instance_p);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 355 to 358)\n-            if (error_word & FXMAC_RXSR_BUFFNA_MASK) != 0\n-            {\n-                error!(\"Receive buffer not available\");\n-                //FXmacRecvHandler(instance_p);\n+\n+            /* Receive error conditions interrupt */\n+            if (reg_isr & FXMAC_IXR_RX_ERR_MASK) != 0 {\n+                let mut reg_ctrl: u32 =\n+                    read_reg((instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32);\n+                reg_ctrl &= !(FXMAC_NWCTRL_RXEN_MASK as u32);\n+\n+                write_reg(\n+                    (instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32,\n+                    reg_ctrl,\n+                );\n+\n+                /* Clear RX status register */\n+                let mut reg_rxsr =\n+                    read_reg((instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *const u32);\n+                write_reg(\n+                    (instance_p.config.base_address + FXMAC_RXSR_OFFSET) as *mut u32,\n+                    reg_rxsr,\n+                );\n+\n+                if ((reg_isr & FXMAC_IXR_RXUSED_MASK) != 0) {\n+                    reg_ctrl = read_reg(\n+                        (instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *const u32,\n+                    );\n+                    reg_ctrl |= FXMAC_NWCTRL_FLUSH_DPRAM_MASK;\n+\n+                    write_reg(\n+                        (instance_p.config.base_address + FXMAC_NWCTRL_OFFSET) as *mut u32,\n+                        reg_ctrl,\n+                    );\n+                }\n+\n+                /* Clear RX status register RX complete indication but preserve\n+                 * error bits if there is any */\n+                write_reg(\n+                    (instance_p.config.base_address\n+                        + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_INTQ1_STS_OFFSET, rx_queue_id))\n+                        as *mut u32,\n+                    FXMAC_INTQUESR_RXUBR_MASK,\n+                );\n+                FXmacRecvIsrHandler(instance_p);\n+\n+                if reg_rxsr != 0 {\n+                    FXmacErrorHandler(instance_p, FXMAC_RECV as u8, reg_rxsr);\n+                }\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 361 to 365)\n-         FXMAC_SEND => {\n-            if (error_word & FXMAC_TXSR_HRESPNOK_MASK) != 0\n-            {\n-                error!(\"Transmit DMA error\");\n-                FXmacHandleDmaTxError(instance_p);\n+    }\n+}\n+\n+/**\n+ * @name: FXmacQueueIrqDisable\n+ * @msg:  Disable queue irq\n+ * @param {FXmac} *instance_p a pointer to the instance to be worked on.\n+ * @param {u32} queue_num queue number\n+ * @param {u32} mask is interrupt disable value mask\n+ */\n+pub fn FXmacQueueIrqDisable(instance_p: &mut FXmac, queue_num: u32, mask: u32) {\n+    assert!(instance_p.is_ready == FT_COMPONENT_IS_READY as u32);\n+    assert!(instance_p.config.max_queue_num > queue_num);\n+\n+    if queue_num == 0 {\n+        write_reg(\n+            (instance_p.config.base_address + FXMAC_IDR_OFFSET) as *mut u32,\n+            mask & FXMAC_IXR_ALL_MASK,\n+        );\n+    } else {\n+        write_reg(\n+            (instance_p.config.base_address + FXMAC_INTQX_IDR_SIZE_OFFSET(queue_num as u64))\n+                as *mut u32,\n+            mask & FXMAC_IXR_ALL_MASK,\n+        );\n+    }\n+}\n+\n+/// FXmacQueueIrqEnable, Enable queue irq\n+pub fn FXmacQueueIrqEnable(instance_p: &mut FXmac, queue_num: u32, mask: u32) {\n+    assert!(instance_p.is_ready == FT_COMPONENT_IS_READY as u32);\n+    assert!(instance_p.config.max_queue_num > queue_num);\n+\n+    if queue_num == 0 {\n+        write_reg(\n+            (instance_p.config.base_address + FXMAC_IER_OFFSET) as *mut u32,\n+            mask & FXMAC_IXR_ALL_MASK,\n+        );\n+    } else {\n+        write_reg(\n+            (instance_p.config.base_address + FXMAC_INTQX_IER_SIZE_OFFSET(queue_num as u64))\n+                as *mut u32,\n+            mask & FXMAC_IXR_ALL_MASK,\n+        );\n+    }\n+}\n+\n+pub fn FXmacErrorHandler(instance_p: &mut FXmac, direction: u8, error_word: u32) {\n+    debug!(\n+        \"-> FXmacErrorHandler, direction={}, error_word={}\",\n+        direction, error_word\n+    );\n+    if error_word != 0 {\n+        match direction as u32 {\n+            FXMAC_RECV => {\n+                if (error_word & FXMAC_RXSR_HRESPNOK_MASK) != 0 {\n+                    error!(\"Receive DMA error\");\n+                    FXmacHandleDmaTxError(instance_p);\n+                }\n+                if (error_word & FXMAC_RXSR_RXOVR_MASK) != 0 {\n+                    error!(\"Receive over run\");\n+                    //FXmacRecvHandler(instance_p);\n+                }\n+                if (error_word & FXMAC_RXSR_BUFFNA_MASK) != 0 {\n+                    error!(\"Receive buffer not available\");\n+                    //FXmacRecvHandler(instance_p);\n+                }\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 367 to 370)\n-            if (error_word & FXMAC_TXSR_URUN_MASK) != 0\n-            {\n-                error!(\"Transmit under run\");\n-                FXmacHandleTxErrors(instance_p);\n+            FXMAC_SEND => {\n+                if (error_word & FXMAC_TXSR_HRESPNOK_MASK) != 0 {\n+                    error!(\"Transmit DMA error\");\n+                    FXmacHandleDmaTxError(instance_p);\n+                }\n+                if (error_word & FXMAC_TXSR_URUN_MASK) != 0 {\n+                    error!(\"Transmit under run\");\n+                    FXmacHandleTxErrors(instance_p);\n+                }\n+                if (error_word & FXMAC_TXSR_BUFEXH_MASK) != 0 {\n+                    error!(\"Transmit buffer exhausted\");\n+                    FXmacHandleTxErrors(instance_p);\n+                }\n+                if (error_word & FXMAC_TXSR_RXOVR_MASK) != 0 {\n+                    error!(\"Transmit retry excessed limits\");\n+                    FXmacHandleTxErrors(instance_p);\n+                }\n+                if (error_word & FXMAC_TXSR_FRAMERX_MASK) != 0 {\n+                    error!(\"Transmit collision\");\n+                    FXmacProcessSentBds(instance_p);\n+                }\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 372 to 375)\n-            if (error_word & FXMAC_TXSR_BUFEXH_MASK) != 0\n-            {\n-                error!(\"Transmit buffer exhausted\");\n-                FXmacHandleTxErrors(instance_p);\n+            _ => {\n+                error!(\"FXmacErrorHandler failed, unknown direction={}\", direction);\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 377 to 386)\n-            if (error_word & FXMAC_TXSR_RXOVR_MASK) != 0\n-            {\n-                error!(\"Transmit retry excessed limits\");\n-                FXmacHandleTxErrors(instance_p);\n-            }\n-            if (error_word & FXMAC_TXSR_FRAMERX_MASK) != 0\n-            {\n-                error!(\"Transmit collision\");\n-                FXmacProcessSentBds(instance_p);\n-            }\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 388 to 389)\n-         _ => { error!(\"FXmacErrorHandler failed, unknown direction={}\", direction); }\n-        }\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 396 to 396)\n-    write_reg((instance.config.base_address + FXMAC_IDR_OFFSET) as *mut u32, FXMAC_IXR_RXCOMPL_MASK);\n+    write_reg(\n+        (instance.config.base_address + FXMAC_IDR_OFFSET) as *mut u32,\n+        FXMAC_IXR_RXCOMPL_MASK,\n+    );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 403 to 405)\n- /// 网卡中断设置\n-pub fn FXmacSetupIsr(instance: &mut FXmac)\n-{\n+/// 网卡中断设置\n+pub fn FXmacSetupIsr(instance: &mut FXmac) {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 428 to 429)\n-    crate_interface::call_interface!(crate::KernelFunc::dma_request_irq(irq_num, xmac_intr_handler));\n-\n+    crate_interface::call_interface!(crate::KernelFunc::dma_request_irq(\n+        irq_num,\n+        xmac_intr_handler\n+    ));\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac_intr.rs (original lines from 431 to 431)\n+\n"
            ],
            "Clippy(Warn)": [
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n  --> src/fxmac_intr.rs:87:37\n   |\n87 |      assert!(instance_p.is_ready == FT_COMPONENT_IS_READY as u32);\n   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FT_COMPONENT_IS_READY`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac_intr.rs:103:63\n    |\n103 |      info!(\"+++++++++ IRQ num vector={}, Interrupt Status ISR={:#x}, tx_queue_id={}, rx_queue_id={}\", vector, reg_isr, tx_queue_id, rx_qu...\n    |                                                               ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac_intr.rs:181:93\n    |\n181 | ...32, (FXMAC_TXSR_TXCOMPL_MASK | FXMAC_TXSR_USEDREAD_MASK) as u32);\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `(FXMAC_TXSR_TXCOMPL_MASK | FXMAC_TXSR_USEDREAD_MASK)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac_intr.rs:207:94\n    |\n207 | ... u32, (FXMAC_RXSR_FRAMERX_MASK | FXMAC_RXSR_BUFFNA_MASK) as u32);\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `(FXMAC_RXSR_FRAMERX_MASK | FXMAC_RXSR_BUFFNA_MASK)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac_intr.rs:226:57\n    |\n226 |                      let mut reg_temp: u32 = reg_ctrl | FXMAC_NWCTRL_FLUSH_DPRAM_MASK as u32;\n    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FXMAC_NWCTRL_FLUSH_DPRAM_MASK`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac_intr.rs:227:34\n    |\n227 |                      reg_temp &= (!FXMAC_NWCTRL_RXEN_MASK) as u32;\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ (!FXMAC_NWCTRL_RXEN_MASK) }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac_intr.rs:231:44\n    |\n231 |                      reg_temp = reg_ctrl | FXMAC_NWCTRL_RXEN_MASK as u32;\n    |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FXMAC_NWCTRL_RXEN_MASK`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac_intr.rs:271:31\n    |\n271 |                  reg_ctrl &= !(FXMAC_NWCTRL_RXEN_MASK as u32);\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCTRL_RXEN_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac_intr.rs:310:37\n    |\n310 |      assert!(instance_p.is_ready == FT_COMPONENT_IS_READY as u32);\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FT_COMPONENT_IS_READY`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac_intr.rs:325:37\n    |\n325 |      assert!(instance_p.is_ready == FT_COMPONENT_IS_READY as u32);\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FT_COMPONENT_IS_READY`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n"
            ]
          }
        },
        {
          "file": "src/fxmac.rs",
          "features": "",
          "count": 36,
          "kinds": {
            "Clippy(Warn)": [
              "warning: this `else { if .. }` block can be collapsed\n   --> src/fxmac.rs:632:12\n    |\n632 |       } else {\n    |  ____________^\n633 | |         if direction == FXMAC_SEND {\n634 | |             write_reg(\n635 | |                 (FXMAC_IOBASE\n...   |\n648 | |     }\n    | |_____^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collapsible_else_if\n    = note: `#[warn(clippy::collapsible_else_if)]` on by default\nhelp: collapse nested if block\n    |\n632 ~     } else if direction == FXMAC_SEND {\n633 +         write_reg(\n634 +             (FXMAC_IOBASE\n635 +                 + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_TXQ1BASE_OFFSET, queue_num as u64))\n636 +                 as *mut u32,\n637 +             ((queue_p & ULONG64_LO_MASK) | flag_queue_p) as u32,\n638 +         );\n639 +     } else {\n640 +         write_reg(\n641 +             (FXMAC_IOBASE\n642 +                 + FXMAC_QUEUE_REGISTER_OFFSET(FXMAC_RXQ1BASE_OFFSET, queue_num as u64))\n643 +                 as *mut u32,\n644 +             ((queue_p & ULONG64_LO_MASK) | flag_queue_p) as u32,\n645 +         );\n646 +     }\n    |\n\n",
              "warning: manual implementation of an assign operation\n   --> src/fxmac.rs:244:5\n    |\n244 |     dmacrreg = dmacrreg | FXMAC_DMACR_INCR16_AHB_AXI_BURST; /* Attempt to use bursts of up to 16. */\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `dmacrreg |= FXMAC_DMACR_INCR16_AHB_AXI_BURST`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\n\n",
              "warning: this expression creates a reference which is immediately dereferenced by the compiler\n   --> src/fxmac.rs:260:34\n    |\n260 |         FXmac_SetHash(&mut xmac, &hwaddr);\n    |                                  ^^^^^^^ help: change this to: `hwaddr`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_borrow\n    = note: `#[warn(clippy::needless_borrow)]` on by default\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:304:52\n    |\n304 |     if (instance_p.config.network_default_config & FXMAC_TRANSMITTER_ENABLE_OPTION as u32) != 0 {\n    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FXMAC_TRANSMITTER_ENABLE_OPTION`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:310:27\n    |\n310 |                 reg_val | FXMAC_NWCTRL_TXEN_MASK as u32,\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FXMAC_NWCTRL_TXEN_MASK`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac.rs:319:55\n    |\n319 |         info!(\"Enable receiver, FXMAC_NWCTRL_OFFSET = {:#x}\", reg_val);\n    |                                                       ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:323:27\n    |\n323 |                 reg_val | FXMAC_NWCTRL_RXEN_MASK as u32,\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FXMAC_NWCTRL_RXEN_MASK`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac.rs:328:32\n    |\n328 |         \"FXMAC_NWCTRL_OFFSET = {:#x}\",\n    |                                ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac.rs:332:37\n    |\n332 |     info!(\"Enable TX and RX by Mask={:#x}\", instance_p.mask);\n    |                                     ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:361:17\n    |\n361 |     reg_val &= !(FXMAC_NWCTRL_RXEN_MASK as u32);\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCTRL_RXEN_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:362:17\n    |\n362 |     reg_val &= !(FXMAC_NWCTRL_TXEN_MASK as u32);\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCTRL_TXEN_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:411:49\n    |\n411 |     let netctrl = (FXMAC_NWCTRL_STATCLR_MASK & !(FXMAC_NWCTRL_LOOPBACK_LOCAL_MASK as u32))\n    |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCTRL_LOOPBACK_LOCAL_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:464:12\n    |\n464 |         & !((FXMAC_TRANSMITTER_ENABLE_OPTION | FXMAC_RECEIVER_ENABLE_OPTION) as u32);\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ (FXMAC_TRANSMITTER_ENABLE_OPTION | FXMAC_RECEIVER_ENABLE_OPTION) }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u64` -> `u64`)\n   --> src/fxmac.rs:550:46\n    |\n550 |     let read_regs = read_reg((FXMAC_IOBASE + FXMAC_DESIGNCFG_DEBUG1_OFFSET as u64) as *const u32);\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FXMAC_DESIGNCFG_DEBUG1_OFFSET`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/fxmac.rs:673:33\n    |\n673 |             \"Design ConfigReg1: {:#x} Has FXMAC_CAPS_ISR_CLEAR_ON_WRITE feature\",\n    |                                 ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:773:32\n    |\n773 |             reg_new_netcfg &= !(FXMAC_NWCFG_BCASTDI_MASK as u32);\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_BCASTDI_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:926:33\n    |\n926 |             reg_new_net_cfg &= !(FXMAC_NWCFG_1536RXEN_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_1536RXEN_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:931:33\n    |\n931 |             reg_new_net_cfg &= !(FXMAC_NWCFG_NVLANDISC_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_NVLANDISC_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:936:33\n    |\n936 |             reg_new_net_cfg &= !(FXMAC_NWCFG_FCS_REMOVE_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_FCS_REMOVE_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:941:33\n    |\n941 |             reg_new_net_cfg &= !(FXMAC_NWCFG_LENGTH_FIELD_ERROR_FRAME_DISCARD_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_LENGTH_FIELD_ERROR_FRAME_DISCARD_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:946:33\n    |\n946 |             reg_new_net_cfg &= !(FXMAC_NWCFG_PAUSE_ENABLE_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_PAUSE_ENABLE_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:951:33\n    |\n951 |             reg_new_net_cfg &= !(FXMAC_NWCFG_COPYALLEN_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_COPYALLEN_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:961:33\n    |\n961 |             reg_new_net_cfg &= !(FXMAC_NWCFG_UCASTHASHEN_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_UCASTHASHEN_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:966:33\n    |\n966 |             reg_new_net_cfg &= !(FXMAC_NWCFG_MCASTHASHEN_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_MCASTHASHEN_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:975:33\n    |\n975 |             reg_new_net_cfg &= !(FXMAC_NWCFG_RXCHKSUMEN_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_RXCHKSUMEN_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n   --> src/fxmac.rs:985:33\n    |\n985 |             reg_new_net_cfg &= !(FXMAC_NWCFG_JUMBO_MASK as u32);\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ FXMAC_NWCFG_JUMBO_MASK }`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n    --> src/fxmac.rs:1025:18\n     |\n1025 |                 !((FXMAC_NWCFG_SGMII_MODE_ENABLE_MASK | FXMAC_NWCFG_PCSSEL_MASK) as u32);\n     |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `{ (FXMAC_NWCFG_SGMII_MODE_ENABLE_MASK | FXMAC_NWCFG_PCSSEL_MASK) }`\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: casting to the same type is unnecessary (`u32` -> `u32`)\n    --> src/fxmac.rs:1108:22\n     |\n1108 |     if is_started == FT_COMPONENT_IS_STARTED as u32 {\n     |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `FT_COMPONENT_IS_STARTED`\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n    --> src/fxmac.rs:1180:22\n     |\n1180 |     debug!(\"Set MAC: {:x?} in hash table\", mac_address);\n     |                      ^^^^^\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n    --> src/fxmac.rs:1591:31\n     |\n1591 |     info!(\"FXMAC_GEM_HSMAC is {:#x}\", reg_value);\n     |                               ^^^^^\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n    --> src/fxmac.rs:1601:39\n     |\n1601 |         \"FXmacInitInterface, PHY MODE:{:?}\",\n     |                                       ^^^^\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n    --> src/fxmac.rs:1618:33\n     |\n1618 |         info!(\"usx interface is {:?}\", instance_p.config.interface);\n     |                                 ^^^^\n     |\n     = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
            ],
            "Unformatted": [
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac.rs (original lines from 58 to 58)\n-\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac.rs (original lines from 98 to 98)\n-    unsafe { core::ptr::read_volatile(crate_interface::call_interface!(crate::KernelFunc::phys_to_virt(src as usize)) as *const T) }\n+    unsafe {\n+        core::ptr::read_volatile(\n+            crate_interface::call_interface!(crate::KernelFunc::phys_to_virt(src as usize))\n+                as *const T,\n+        )\n+    }\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac.rs (original lines from 103 to 103)\n-        core::ptr::write_volatile(crate_interface::call_interface!(crate::KernelFunc::phys_to_virt(dst as usize)) as *mut T, value);\n+        core::ptr::write_volatile(\n+            crate_interface::call_interface!(crate::KernelFunc::phys_to_virt(dst as usize))\n+                as *mut T,\n+            value,\n+        );\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/fxmac.rs (original lines from 107 to 107)\n-pub fn xmac_init(hwaddr: &[u8; 6]) -> &'static mut FXmac { // i32\n+pub fn xmac_init(hwaddr: &[u8; 6]) -> &'static mut FXmac {\n+    // i32\n"
            ]
          }
        },
        {
          "file": "src/utils.rs",
          "features": "",
          "count": 9,
          "kinds": {
            "Clippy(Warn)": [
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n  --> src/utils.rs:27:67\n   |\n27 |                 error!(\"Failed to get PhytiumPi CPU Id from mpidr={:#x}\", mpidr);\n   |                                                                   ^^^^^\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n   = note: `#[warn(clippy::literal_string_with_formatting_args)]` on by default\n\n",
              "warning: manual implementation of an assign operation\n  --> src/utils.rs:97:9\n   |\n97 |         adr = adr & (!CACHE_LINE_ADDR_MASK);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `adr &= (!CACHE_LINE_ADDR_MASK)`\n   |\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\n   = note: `#[warn(clippy::assign_op_pattern)]` on by default\n\n",
              "warning: manual implementation of an assign operation\n   --> src/utils.rs:116:9\n    |\n116 |         adr = adr & (!CACHE_LINE_ADDR_MASK);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `adr &= (!CACHE_LINE_ADDR_MASK)`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\n\n",
              "warning: casting to the same type is unnecessary (`u64` -> `u64`)\n   --> src/utils.rs:139:9\n    |\n139 |         CNTFRQ_EL0.get() as u64\n    |         ^^^^^^^^^^^^^^^^^^^^^^^ help: try: `CNTFRQ_EL0.get()`\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_cast\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/utils.rs:202:39\n    |\n202 |     debug!(\"fxmac: virt_to_phys_fxmac {:#x}\", addr);\n    |                                       ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/utils.rs:210:39\n    |\n210 |     debug!(\"fxmac: phys_to_virt_fxmac {:#x}\", addr);\n    |                                       ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/utils.rs:232:37\n    |\n232 |     debug!(\"fxmac: dma alloc paddr: {:#x}, len={}\", paddr, len);\n    |                                     ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n",
              "warning: this looks like a formatting argument but it is not part of a formatting macro\n   --> src/utils.rs:241:36\n    |\n241 |     debug!(\"fxmac: dma free vaddr: {:#x}, pages={}\", vaddr, pages);\n    |                                    ^^^^^\n    |\n    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#literal_string_with_formatting_args\n\n"
            ],
            "Unformatted": [
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/utils.rs (original lines from 258 to 258)\n+\n"
            ]
          }
        },
        {
          "file": "src/lib.rs",
          "features": "",
          "count": 6,
          "kinds": {
            "Clippy(Warn)": [
              "warning: ambiguous glob re-exports\n  --> src/lib.rs:43:9\n   |\n43 | pub use fxmac::*;\n   |         ^^^^^^^^ the name `ULONG64_HI_MASK` in the value namespace is first re-exported here\n44 | pub use fxmac_dma::*;\n   |         ------------ but the name `ULONG64_HI_MASK` in the value namespace is also re-exported here\n   |\n   = note: `#[warn(ambiguous_glob_reexports)]` on by default\n\n",
              "warning: ambiguous glob re-exports\n  --> src/lib.rs:43:9\n   |\n43 | pub use fxmac::*;\n   |         ^^^^^^^^ the name `ULONG64_LO_MASK` in the value namespace is first re-exported here\n44 | pub use fxmac_dma::*;\n   |         ------------ but the name `ULONG64_LO_MASK` in the value namespace is also re-exported here\n\n"
            ],
            "Unformatted": [
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/lib.rs (original lines from 37 to 38)\n-mod utils;\n-mod fxmac_phy;\n+mod fxmac;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/lib.rs (original lines from 41 to 41)\n-mod fxmac;\n+mod fxmac_phy;\n+mod utils;\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/lib.rs (original lines from 52 to 52)\n-pub trait KernelFunc{\n+pub trait KernelFunc {\n",
              "file: /home/runner/check/batch_30/elliott10/fxmac_rs/src/lib.rs (original lines from 72 to 73)\n-    fn it_works() {\n-    }\n+    fn it_works() {}\n"
            ]
          }
        },
        {
          "file": "(virtual) semver-checks",
          "features": "",
          "count": 1,
          "kinds": {
            "Cargo": [
              "// pkg_name=fxmac_rs, checker=SemverChecks\n// toolchain=nightly-2025-01-18, target=aarch64-unknown-none-softfloat\n// features=\n// pkg_dir=/home/runner/check/batch_30/elliott10/fxmac_rs\n// cmd=cargo +nightly-2025-01-26-x86_64-unknown-linux-gnu semver-checks --target aarch64-unknown-none-softfloat \n// timestamp=2025-03-07 18:10:55.578855408 +08:00:00\n    Building fxmac_rs v0.2.0 (current)\n       Built [   3.345s] (current)\n     Parsing fxmac_rs v0.2.0 (current)\n      Parsed [   0.005s] (current)\nerror: fxmac_rs not found in registry (crates.io). For workarounds check https://github.com/obi1kenobi/cargo-semver-checks#does-the-crate-im-checking-have-to-be-published-on-cratesio\n"
            ]
          }
        },
        {
          "file": "[outdated direct dependencies]",
          "features": "",
          "count": 1,
          "kinds": {
            "Outdated": [
              "pkg=fxmac_rs, checker=Outdated\ntoolchain=nightly-2025-01-18, target=aarch64-unknown-none-softfloat\nfeatures=\npkg_dir=/home/runner/check/batch_30/elliott10/fxmac_rs\ncmd=cargo +nightly-2025-01-26-x86_64-unknown-linux-gnu outdated -R --exit-code=2\ntimestamp=2025-03-01 4:32:15.866030112 +08:00:00\n\nName  Project  Compat  Latest  Kind    Platform\n----  -------  ------  ------  ----    --------\nlog   0.4.22   0.4.26  0.4.26  Normal  ---\n"
            ]
          }
        },
        {
          "file": "[rap] Not supported to display yet.",
          "features": "",
          "count": 1,
          "kinds": {
            "Rapx": [
              "pkg=fxmac_rs, checker=Rapx\ntoolchain=nightly-2025-01-18, target=aarch64-unknown-none-softfloat\nfeatures=\npkg_dir=/home/runner/check/batch_30/elliott10/fxmac_rs\ncmd=cargo +nightly-2024-10-12 rapx -F -M -- --target aarch64-unknown-none-softfloat \ntimestamp=2025-03-01 4:32:15.658928601 +08:00:00\n\nwarning: Memory Leak detected.\n   --> src/utils.rs:229:17\n    |\n217 | pub(crate) fn dma_alloc_coherent(pages: usize) -> (usize, usize) {\n218 |     let paddr: Box<[u32]> = if pages == 1 {\n219 |         Box::new([0; 1024]) // 4096\n220 |     } else if pages == 8 {\n221 |         Box::new([0; 1024 * 8]) // 4096\n222 |     } else {\n223 |         warn!(\"Alloc {} pages failed\", pages);\n224 |         Box::new([0; 1024])\n225 |     };\n226 |\n227 |     let len = paddr.len();\n228 |\n229 |     let paddr = Box::into_raw(paddr) as *const u32 as usize;\n    |                 -------------------- Memory Leak Candidates.\n230 |     //let vaddr = phys_to_virt(paddr);\n231 |     let vaddr = paddr;\n232 |     debug!(\"fxmac: dma alloc paddr: {:#x}, len={}\", paddr, len);\n233 |\n234 |     (vaddr, paddr)\n235 | }\n    |\nOver visited: DefId(0:659 ~ fxmac_rs[2976]::fxmac_intr::FXmacIntrHandler)\nOver visited: DefId(0:750 ~ fxmac_rs[2976]::fxmac::FXmacSetOptions)\nOver visited: DefId(0:751 ~ fxmac_rs[2976]::fxmac::FXmacClearOptions)\nOver visited: DefId(0:762 ~ fxmac_rs[2976]::fxmac::FXmacSelectClk)\nOver visited: DefId(0:765 ~ fxmac_rs[2976]::fxmac::FXmacInitInterface)\n"
            ]
          }
        },
        {
          "file": "[semver checks]",
          "features": "",
          "count": 1,
          "kinds": {
            "Semver Violation": [
              "pkg=fxmac_rs, checker=SemverChecks\ntoolchain=nightly-2025-01-18, target=aarch64-unknown-none-softfloat\nfeatures=\npkg_dir=/home/runner/check/batch_30/elliott10/fxmac_rs\ncmd=cargo +nightly-2025-01-26-x86_64-unknown-linux-gnu semver-checks --target aarch64-unknown-none-softfloat \ntimestamp=2025-03-07 18:10:59.290603193 +08:00:00\n\n\nstdout:\n\nstderr:\n    Building fxmac_rs v0.2.0 (current)\n       Built [   3.345s] (current)\n     Parsing fxmac_rs v0.2.0 (current)\n      Parsed [   0.005s] (current)\nerror: fxmac_rs not found in registry (crates.io). For workarounds check https://github.com/obi1kenobi/cargo-semver-checks#does-the-crate-im-checking-have-to-be-published-on-cratesio\n"
            ]
          }
        }
      ]
    }
  ],
  "kinds_order": [
    "Cargo",
    "Clippy(Error)",
    "Clippy(Warn)",
    "Semver Violation",
    "Audit",
    "Mirai",
    "Rapx",
    "Rudra",
    "Lockbud(Probably)",
    "Lockbud(Possibly)",
    "Outdated",
    "Geiger",
    "Unformatted"
  ]
}