{
  "user": "arceos-hypervisor",
  "repo": "x86_vcpu",
  "timestamp": {
    "start": 1753581418590,
    "end": 1754186107221
  },
  "pkgs": {
    "x86_vcpu": {
      "version": "0.1.0",
      "dependencies": 19,
      "lib": true,
      "bin": false,
      "testcases": {
        "tests": [
          {
            "id": "x86_vcpu",
            "kind": "lib",
            "binary_name": "x86_vcpu",
            "testcases": [
              {
                "name": "msr::tests::test_fs_gs_base_msr_values",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "msr::tests::test_msr_as_u32_conversion",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "msr::tests::test_msr_copy_clone",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "msr::tests::test_msr_debug",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "msr::tests::test_msr_enum_values",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "msr::tests::test_msr_read_write_trait",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "msr::tests::test_system_call_msr_values",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "msr::tests::test_vmx_msr_ranges",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "regs::accessors::test::test_read_write_on_reg_r10",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "regs::accessors::test::test_read_write_on_reg_r11",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "regs::accessors::test::test_read_write_on_reg_r12",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "regs::accessors::test::test_read_write_on_reg_r13",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "regs::accessors::test::test_read_write_on_reg_r14",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "regs::accessors::test::test_read_write_on_reg_r15",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "regs::accessors::test::test_read_write_on_reg_r8",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "regs::accessors::test::test_read_write_on_reg_r9",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "regs::accessors::test::test_read_write_on_reg_rax",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "regs::accessors::test::test_read_write_on_reg_rbp",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "regs::accessors::test::test_read_write_on_reg_rbx",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "regs::accessors::test::test_read_write_on_reg_rcx",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "regs::accessors::test::test_read_write_on_reg_rdi",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "regs::accessors::test::test_read_write_on_reg_rdx",
                "status": "ok",
                "duration_ms": 5,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "regs::accessors::test::test_read_write_on_reg_rsi",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "test_utils::tests::test_mock_allocator",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::percpu::tests::test_multiple_cpu_states_independence",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::percpu::tests::test_vmx_per_cpu_state_debug",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::percpu::tests::test_vmx_per_cpu_state_default_values",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::percpu::tests::test_vmx_per_cpu_state_new",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::percpu::tests::test_vmx_per_cpu_state_size",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::structs::tests::test_debug_implementations",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": false,
                "miri_output": "    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.04s\n     Running unittests src/lib.rs (target/miri/x86_64-unknown-linux-gnu/debug/deps/x86_vcpu-22a1f51880a00623)\nwarning: unreachable expression\n    --> src/vmx/vcpu.rs:1061:9\n     |\n1058 |         unimplemented!(\"apic access\");\n     |         ----------------------------- any code following this expression is unreachable\n...\n1061 |         self.advance_rip(exit_info.exit_instruction_length as _)\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression\n     |\n     = note: `#[warn(unreachable_code)]` on by default\n\nwarning: unnecessary `unsafe` block\n   --> src/vmx/vcpu.rs:879:9\n    |\n879 |         unsafe {\n    |         ^^^^^^ unnecessary `unsafe` block\n...\n905 |         vmx_entry_with!(\"vmlaunch\")\n    |         --------------------------- in this macro invocation\n    |\n    = note: `#[warn(unused_unsafe)]` on by default\n    = note: this warning originates in the macro `vmx_entry_with` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: unnecessary `unsafe` block\n   --> src/vmx/vcpu.rs:879:9\n    |\n879 |         unsafe {\n    |         ^^^^^^ unnecessary `unsafe` block\n...\n913 |         vmx_entry_with!(\"vmresume\")\n    |         --------------------------- in this macro invocation\n    |\n    = note: this warning originates in the macro `vmx_entry_with` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: unnecessary `unsafe` block\n   --> src/vmx/vcpu.rs:923:9\n    |\n923 |         unsafe {\n    |         ^^^^^^ unnecessary `unsafe` block\n\nwarning: unused variable: `write`\n    --> src/vmx/vcpu.rs:1046:13\n     |\n1046 |         let write = match apic_access_exit_info.access_type {\n     |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_write`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `exit_info`\n    --> src/vmx/vcpu.rs:1043:38\n     |\n1043 |     fn handle_apic_access(&mut self, exit_info: &VmxExitInfo) -> AxResult {\n     |                                      ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_exit_info`\n\nwarning: integer-to-pointer cast\n   --> /home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memory_addr-0.4.0/src/addr.rs:491:9\n    |\n491 |         self.0 as *mut u8\n    |         ^^^^^^^^^^^^^^^^^ integer-to-pointer cast\n    |\n    = help: this program is using integer-to-pointer casts or (equivalently) `ptr::with_exposed_provenance`, which means that Miri might miss pointer bugs in this program\n    = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.with_exposed_provenance.html for more details on that operation\n    = help: to ensure that Miri does not miss bugs in your program, use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead\n    = help: you can then set `MIRIFLAGS=-Zmiri-strict-provenance` to ensure you are not relying on `with_exposed_provenance` semantics\n    = help: alternatively, `MIRIFLAGS=-Zmiri-permissive-provenance` disables this warning\n    = note: BACKTRACE on thread `vmx::structs::t`:\n    = note: inside `memory_addr::VirtAddr::as_mut_ptr` at /home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memory_addr-0.4.0/src/addr.rs:491:9: 491:26\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::as_mut_ptr` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:58:9: 58:57\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::fill` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:63:41: 63:58\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::alloc_zero` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:34:9: 34:18\nnote: inside `vmx::structs::IOBitmap::<test_utils::mock::MockMmHal>::passthrough_all`\n   --> src/vmx/structs.rs:52:32\n    |\n52  |             io_bitmap_a_frame: PhysFrame::alloc_zero()?,\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside `vmx::structs::tests::test_debug_implementations`\n   --> src/vmx/structs.rs:458:25\n    |\n458 |         let io_bitmap = IOBitmap::<MockMmHal>::passthrough_all().unwrap();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside closure\n   --> src/vmx/structs.rs:453:36\n    |\n452 |     #[test]\n    |     ------- in this procedural macro expansion\n453 |     fn test_debug_implementations() {\n    |                                    ^\n\nerror: Undefined Behavior: attempting a write access using <wildcard> at alloc270[0x8], but no exposed tags have suitable permission in the borrow stack for this location\n   --> /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:63:18\n    |\n63  |         unsafe { core::ptr::write_bytes(self.as_mut_ptr(), byte, PAGE_SIZE) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this error occurs as part of an access at alloc270[0x8..0x1008]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n    = note: BACKTRACE on thread `vmx::structs::t`:\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::fill` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:63:18: 63:76\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::alloc_zero` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:34:9: 34:18\nnote: inside `vmx::structs::IOBitmap::<test_utils::mock::MockMmHal>::passthrough_all`\n   --> src/vmx/structs.rs:52:32\n    |\n52  |             io_bitmap_a_frame: PhysFrame::alloc_zero()?,\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside `vmx::structs::tests::test_debug_implementations`\n   --> src/vmx/structs.rs:458:25\n    |\n458 |         let io_bitmap = IOBitmap::<MockMmHal>::passthrough_all().unwrap();\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside closure\n   --> src/vmx/structs.rs:453:36\n    |\n452 |     #[test]\n    |     ------- in this procedural macro expansion\n453 |     fn test_debug_implementations() {\n    |                                    ^\n\nnote: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n\nerror: aborting due to 1 previous error; 7 warnings emitted\n\nerror: test failed, to rerun pass `-p x86_vcpu --lib`\n\nCaused by:\n  process didn't exit successfully: `/home/runner/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/cargo-miri runner /tmp/os-checker-plugin-cargo/arceos-hypervisor/x86_vcpu/target/miri/x86_64-unknown-linux-gnu/debug/deps/x86_vcpu-22a1f51880a00623 x86_vcpu 'vmx::structs::tests::test_debug_implementations'` (exit status: 1)\nnote: test exited abnormally; to see the full output pass --nocapture to the harness.\n",
                "miri_timeout": false
              },
              {
                "name": "vmx::structs::tests::test_ept_pointer_creation",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::structs::tests::test_ept_pointer_flags",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::structs::tests::test_ept_pointer_from_table_phys",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::structs::tests::test_ept_pointer_from_unaligned_addr",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::structs::tests::test_ept_pointer_getters",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::structs::tests::test_feature_control_flags",
                "status": "ok",
                "duration_ms": 5,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::structs::tests::test_io_bitmap_creation",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": false,
                "miri_output": "    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.04s\n     Running unittests src/lib.rs (target/miri/x86_64-unknown-linux-gnu/debug/deps/x86_vcpu-22a1f51880a00623)\nwarning: unreachable expression\n    --> src/vmx/vcpu.rs:1061:9\n     |\n1058 |         unimplemented!(\"apic access\");\n     |         ----------------------------- any code following this expression is unreachable\n...\n1061 |         self.advance_rip(exit_info.exit_instruction_length as _)\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression\n     |\n     = note: `#[warn(unreachable_code)]` on by default\n\nwarning: unnecessary `unsafe` block\n   --> src/vmx/vcpu.rs:879:9\n    |\n879 |         unsafe {\n    |         ^^^^^^ unnecessary `unsafe` block\n...\n905 |         vmx_entry_with!(\"vmlaunch\")\n    |         --------------------------- in this macro invocation\n    |\n    = note: `#[warn(unused_unsafe)]` on by default\n    = note: this warning originates in the macro `vmx_entry_with` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: unnecessary `unsafe` block\n   --> src/vmx/vcpu.rs:879:9\n    |\n879 |         unsafe {\n    |         ^^^^^^ unnecessary `unsafe` block\n...\n913 |         vmx_entry_with!(\"vmresume\")\n    |         --------------------------- in this macro invocation\n    |\n    = note: this warning originates in the macro `vmx_entry_with` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: unnecessary `unsafe` block\n   --> src/vmx/vcpu.rs:923:9\n    |\n923 |         unsafe {\n    |         ^^^^^^ unnecessary `unsafe` block\n\nwarning: unused variable: `write`\n    --> src/vmx/vcpu.rs:1046:13\n     |\n1046 |         let write = match apic_access_exit_info.access_type {\n     |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_write`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `exit_info`\n    --> src/vmx/vcpu.rs:1043:38\n     |\n1043 |     fn handle_apic_access(&mut self, exit_info: &VmxExitInfo) -> AxResult {\n     |                                      ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_exit_info`\n\nwarning: integer-to-pointer cast\n   --> /home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memory_addr-0.4.0/src/addr.rs:491:9\n    |\n491 |         self.0 as *mut u8\n    |         ^^^^^^^^^^^^^^^^^ integer-to-pointer cast\n    |\n    = help: this program is using integer-to-pointer casts or (equivalently) `ptr::with_exposed_provenance`, which means that Miri might miss pointer bugs in this program\n    = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.with_exposed_provenance.html for more details on that operation\n    = help: to ensure that Miri does not miss bugs in your program, use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead\n    = help: you can then set `MIRIFLAGS=-Zmiri-strict-provenance` to ensure you are not relying on `with_exposed_provenance` semantics\n    = help: alternatively, `MIRIFLAGS=-Zmiri-permissive-provenance` disables this warning\n    = note: BACKTRACE on thread `vmx::structs::t`:\n    = note: inside `memory_addr::VirtAddr::as_mut_ptr` at /home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memory_addr-0.4.0/src/addr.rs:491:9: 491:26\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::as_mut_ptr` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:58:9: 58:57\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::fill` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:63:41: 63:58\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::alloc_zero` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:34:9: 34:18\nnote: inside `vmx::structs::IOBitmap::<test_utils::mock::MockMmHal>::passthrough_all`\n   --> src/vmx/structs.rs:52:32\n    |\n52  |             io_bitmap_a_frame: PhysFrame::alloc_zero()?,\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside `vmx::structs::tests::test_io_bitmap_creation`\n   --> src/vmx/structs.rs:336:34\n    |\n336 |         let passthrough_bitmap = IOBitmap::<MockMmHal>::passthrough_all();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside closure\n   --> src/vmx/structs.rs:331:33\n    |\n330 |     #[test]\n    |     ------- in this procedural macro expansion\n331 |     fn test_io_bitmap_creation() {\n    |                                 ^\n\nerror: Undefined Behavior: attempting a write access using <wildcard> at alloc270[0x8], but no exposed tags have suitable permission in the borrow stack for this location\n   --> /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:63:18\n    |\n63  |         unsafe { core::ptr::write_bytes(self.as_mut_ptr(), byte, PAGE_SIZE) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this error occurs as part of an access at alloc270[0x8..0x1008]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n    = note: BACKTRACE on thread `vmx::structs::t`:\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::fill` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:63:18: 63:76\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::alloc_zero` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:34:9: 34:18\nnote: inside `vmx::structs::IOBitmap::<test_utils::mock::MockMmHal>::passthrough_all`\n   --> src/vmx/structs.rs:52:32\n    |\n52  |             io_bitmap_a_frame: PhysFrame::alloc_zero()?,\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside `vmx::structs::tests::test_io_bitmap_creation`\n   --> src/vmx/structs.rs:336:34\n    |\n336 |         let passthrough_bitmap = IOBitmap::<MockMmHal>::passthrough_all();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside closure\n   --> src/vmx/structs.rs:331:33\n    |\n330 |     #[test]\n    |     ------- in this procedural macro expansion\n331 |     fn test_io_bitmap_creation() {\n    |                                 ^\n\nnote: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n\nerror: aborting due to 1 previous error; 7 warnings emitted\n\nerror: test failed, to rerun pass `-p x86_vcpu --lib`\n\nCaused by:\n  process didn't exit successfully: `/home/runner/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/cargo-miri runner /tmp/os-checker-plugin-cargo/arceos-hypervisor/x86_vcpu/target/miri/x86_64-unknown-linux-gnu/debug/deps/x86_vcpu-22a1f51880a00623 x86_vcpu 'vmx::structs::tests::test_io_bitmap_creation'` (exit status: 1)\nnote: test exited abnormally; to see the full output pass --nocapture to the harness.\n",
                "miri_timeout": false
              },
              {
                "name": "vmx::structs::tests::test_msr_bitmap_creation",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": false,
                "miri_output": "    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.04s\n     Running unittests src/lib.rs (target/miri/x86_64-unknown-linux-gnu/debug/deps/x86_vcpu-22a1f51880a00623)\nwarning: unreachable expression\n    --> src/vmx/vcpu.rs:1061:9\n     |\n1058 |         unimplemented!(\"apic access\");\n     |         ----------------------------- any code following this expression is unreachable\n...\n1061 |         self.advance_rip(exit_info.exit_instruction_length as _)\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression\n     |\n     = note: `#[warn(unreachable_code)]` on by default\n\nwarning: unnecessary `unsafe` block\n   --> src/vmx/vcpu.rs:879:9\n    |\n879 |         unsafe {\n    |         ^^^^^^ unnecessary `unsafe` block\n...\n905 |         vmx_entry_with!(\"vmlaunch\")\n    |         --------------------------- in this macro invocation\n    |\n    = note: `#[warn(unused_unsafe)]` on by default\n    = note: this warning originates in the macro `vmx_entry_with` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: unnecessary `unsafe` block\n   --> src/vmx/vcpu.rs:879:9\n    |\n879 |         unsafe {\n    |         ^^^^^^ unnecessary `unsafe` block\n...\n913 |         vmx_entry_with!(\"vmresume\")\n    |         --------------------------- in this macro invocation\n    |\n    = note: this warning originates in the macro `vmx_entry_with` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: unnecessary `unsafe` block\n   --> src/vmx/vcpu.rs:923:9\n    |\n923 |         unsafe {\n    |         ^^^^^^ unnecessary `unsafe` block\n\nwarning: unused variable: `write`\n    --> src/vmx/vcpu.rs:1046:13\n     |\n1046 |         let write = match apic_access_exit_info.access_type {\n     |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_write`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `exit_info`\n    --> src/vmx/vcpu.rs:1043:38\n     |\n1043 |     fn handle_apic_access(&mut self, exit_info: &VmxExitInfo) -> AxResult {\n     |                                      ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_exit_info`\n\nwarning: integer-to-pointer cast\n   --> /home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memory_addr-0.4.0/src/addr.rs:491:9\n    |\n491 |         self.0 as *mut u8\n    |         ^^^^^^^^^^^^^^^^^ integer-to-pointer cast\n    |\n    = help: this program is using integer-to-pointer casts or (equivalently) `ptr::with_exposed_provenance`, which means that Miri might miss pointer bugs in this program\n    = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.with_exposed_provenance.html for more details on that operation\n    = help: to ensure that Miri does not miss bugs in your program, use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead\n    = help: you can then set `MIRIFLAGS=-Zmiri-strict-provenance` to ensure you are not relying on `with_exposed_provenance` semantics\n    = help: alternatively, `MIRIFLAGS=-Zmiri-permissive-provenance` disables this warning\n    = note: BACKTRACE on thread `vmx::structs::t`:\n    = note: inside `memory_addr::VirtAddr::as_mut_ptr` at /home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memory_addr-0.4.0/src/addr.rs:491:9: 491:26\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::as_mut_ptr` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:58:9: 58:57\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::fill` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:63:41: 63:58\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::alloc_zero` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:34:9: 34:18\nnote: inside `vmx::structs::MsrBitmap::<test_utils::mock::MockMmHal>::passthrough_all`\n   --> src/vmx/structs.rs:111:20\n    |\n111 |             frame: PhysFrame::alloc_zero()?,\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside `vmx::structs::tests::test_msr_bitmap_creation`\n   --> src/vmx/structs.rs:357:34\n    |\n357 |         let passthrough_bitmap = MsrBitmap::<MockMmHal>::passthrough_all();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside closure\n   --> src/vmx/structs.rs:352:34\n    |\n351 |     #[test]\n    |     ------- in this procedural macro expansion\n352 |     fn test_msr_bitmap_creation() {\n    |                                  ^\n\nerror: Undefined Behavior: attempting a write access using <wildcard> at alloc270[0x8], but no exposed tags have suitable permission in the borrow stack for this location\n   --> /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:63:18\n    |\n63  |         unsafe { core::ptr::write_bytes(self.as_mut_ptr(), byte, PAGE_SIZE) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this error occurs as part of an access at alloc270[0x8..0x1008]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n    = note: BACKTRACE on thread `vmx::structs::t`:\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::fill` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:63:18: 63:76\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::alloc_zero` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:34:9: 34:18\nnote: inside `vmx::structs::MsrBitmap::<test_utils::mock::MockMmHal>::passthrough_all`\n   --> src/vmx/structs.rs:111:20\n    |\n111 |             frame: PhysFrame::alloc_zero()?,\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside `vmx::structs::tests::test_msr_bitmap_creation`\n   --> src/vmx/structs.rs:357:34\n    |\n357 |         let passthrough_bitmap = MsrBitmap::<MockMmHal>::passthrough_all();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside closure\n   --> src/vmx/structs.rs:352:34\n    |\n351 |     #[test]\n    |     ------- in this procedural macro expansion\n352 |     fn test_msr_bitmap_creation() {\n    |                                  ^\n\nnote: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n\nerror: aborting due to 1 previous error; 7 warnings emitted\n\nerror: test failed, to rerun pass `-p x86_vcpu --lib`\n\nCaused by:\n  process didn't exit successfully: `/home/runner/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/cargo-miri runner /tmp/os-checker-plugin-cargo/arceos-hypervisor/x86_vcpu/target/miri/x86_64-unknown-linux-gnu/debug/deps/x86_vcpu-22a1f51880a00623 x86_vcpu 'vmx::structs::tests::test_msr_bitmap_creation'` (exit status: 1)\nnote: test exited abnormally; to see the full output pass --nocapture to the harness.\n",
                "miri_timeout": false
              },
              {
                "name": "vmx::structs::tests::test_vmx_basic_constants",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::structs::tests::test_vmx_region_new",
                "status": "ok",
                "duration_ms": 5,
                "error": null,
                "miri_pass": false,
                "miri_output": "    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.04s\n     Running unittests src/lib.rs (target/miri/x86_64-unknown-linux-gnu/debug/deps/x86_vcpu-22a1f51880a00623)\nwarning: unreachable expression\n    --> src/vmx/vcpu.rs:1061:9\n     |\n1058 |         unimplemented!(\"apic access\");\n     |         ----------------------------- any code following this expression is unreachable\n...\n1061 |         self.advance_rip(exit_info.exit_instruction_length as _)\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression\n     |\n     = note: `#[warn(unreachable_code)]` on by default\n\nwarning: unnecessary `unsafe` block\n   --> src/vmx/vcpu.rs:879:9\n    |\n879 |         unsafe {\n    |         ^^^^^^ unnecessary `unsafe` block\n...\n905 |         vmx_entry_with!(\"vmlaunch\")\n    |         --------------------------- in this macro invocation\n    |\n    = note: `#[warn(unused_unsafe)]` on by default\n    = note: this warning originates in the macro `vmx_entry_with` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: unnecessary `unsafe` block\n   --> src/vmx/vcpu.rs:879:9\n    |\n879 |         unsafe {\n    |         ^^^^^^ unnecessary `unsafe` block\n...\n913 |         vmx_entry_with!(\"vmresume\")\n    |         --------------------------- in this macro invocation\n    |\n    = note: this warning originates in the macro `vmx_entry_with` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: unnecessary `unsafe` block\n   --> src/vmx/vcpu.rs:923:9\n    |\n923 |         unsafe {\n    |         ^^^^^^ unnecessary `unsafe` block\n\nwarning: unused variable: `write`\n    --> src/vmx/vcpu.rs:1046:13\n     |\n1046 |         let write = match apic_access_exit_info.access_type {\n     |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_write`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `exit_info`\n    --> src/vmx/vcpu.rs:1043:38\n     |\n1043 |     fn handle_apic_access(&mut self, exit_info: &VmxExitInfo) -> AxResult {\n     |                                      ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_exit_info`\n\nwarning: integer-to-pointer cast\n   --> /home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memory_addr-0.4.0/src/addr.rs:491:9\n    |\n491 |         self.0 as *mut u8\n    |         ^^^^^^^^^^^^^^^^^ integer-to-pointer cast\n    |\n    = help: this program is using integer-to-pointer casts or (equivalently) `ptr::with_exposed_provenance`, which means that Miri might miss pointer bugs in this program\n    = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.with_exposed_provenance.html for more details on that operation\n    = help: to ensure that Miri does not miss bugs in your program, use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead\n    = help: you can then set `MIRIFLAGS=-Zmiri-strict-provenance` to ensure you are not relying on `with_exposed_provenance` semantics\n    = help: alternatively, `MIRIFLAGS=-Zmiri-permissive-provenance` disables this warning\n    = note: BACKTRACE on thread `vmx::structs::t`:\n    = note: inside `memory_addr::VirtAddr::as_mut_ptr` at /home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memory_addr-0.4.0/src/addr.rs:491:9: 491:26\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::as_mut_ptr` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:58:9: 58:57\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::fill` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:63:41: 63:58\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::alloc_zero` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:34:9: 34:18\nnote: inside `vmx::structs::VmxRegion::<test_utils::mock::MockMmHal>::new`\n   --> src/vmx/structs.rs:25:21\n    |\n25  |         let frame = PhysFrame::alloc_zero()?;\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside `vmx::structs::tests::test_vmx_region_new`\n   --> src/vmx/structs.rs:294:22\n    |\n294 |         let region = VmxRegion::<MockMmHal>::new(0x12345, false);\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside closure\n   --> src/vmx/structs.rs:289:29\n    |\n288 |     #[test]\n    |     ------- in this procedural macro expansion\n289 |     fn test_vmx_region_new() {\n    |                             ^\n\nerror: Undefined Behavior: attempting a write access using <wildcard> at alloc270[0x8], but no exposed tags have suitable permission in the borrow stack for this location\n   --> /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:63:18\n    |\n63  |         unsafe { core::ptr::write_bytes(self.as_mut_ptr(), byte, PAGE_SIZE) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this error occurs as part of an access at alloc270[0x8..0x1008]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n    = note: BACKTRACE on thread `vmx::structs::t`:\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::fill` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:63:18: 63:76\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::alloc_zero` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:34:9: 34:18\nnote: inside `vmx::structs::VmxRegion::<test_utils::mock::MockMmHal>::new`\n   --> src/vmx/structs.rs:25:21\n    |\n25  |         let frame = PhysFrame::alloc_zero()?;\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside `vmx::structs::tests::test_vmx_region_new`\n   --> src/vmx/structs.rs:294:22\n    |\n294 |         let region = VmxRegion::<MockMmHal>::new(0x12345, false);\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside closure\n   --> src/vmx/structs.rs:289:29\n    |\n288 |     #[test]\n    |     ------- in this procedural macro expansion\n289 |     fn test_vmx_region_new() {\n    |                             ^\n\nnote: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n\nerror: aborting due to 1 previous error; 7 warnings emitted\n\nerror: test failed, to rerun pass `-p x86_vcpu --lib`\n\nCaused by:\n  process didn't exit successfully: `/home/runner/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/cargo-miri runner /tmp/os-checker-plugin-cargo/arceos-hypervisor/x86_vcpu/target/miri/x86_64-unknown-linux-gnu/debug/deps/x86_vcpu-22a1f51880a00623 x86_vcpu 'vmx::structs::tests::test_vmx_region_new'` (exit status: 1)\nnote: test exited abnormally; to see the full output pass --nocapture to the harness.\n",
                "miri_timeout": false
              },
              {
                "name": "vmx::structs::tests::test_vmx_region_new_with_shadow",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": false,
                "miri_output": "    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.04s\n     Running unittests src/lib.rs (target/miri/x86_64-unknown-linux-gnu/debug/deps/x86_vcpu-22a1f51880a00623)\nwarning: unreachable expression\n    --> src/vmx/vcpu.rs:1061:9\n     |\n1058 |         unimplemented!(\"apic access\");\n     |         ----------------------------- any code following this expression is unreachable\n...\n1061 |         self.advance_rip(exit_info.exit_instruction_length as _)\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression\n     |\n     = note: `#[warn(unreachable_code)]` on by default\n\nwarning: unnecessary `unsafe` block\n   --> src/vmx/vcpu.rs:879:9\n    |\n879 |         unsafe {\n    |         ^^^^^^ unnecessary `unsafe` block\n...\n905 |         vmx_entry_with!(\"vmlaunch\")\n    |         --------------------------- in this macro invocation\n    |\n    = note: `#[warn(unused_unsafe)]` on by default\n    = note: this warning originates in the macro `vmx_entry_with` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: unnecessary `unsafe` block\n   --> src/vmx/vcpu.rs:879:9\n    |\n879 |         unsafe {\n    |         ^^^^^^ unnecessary `unsafe` block\n...\n913 |         vmx_entry_with!(\"vmresume\")\n    |         --------------------------- in this macro invocation\n    |\n    = note: this warning originates in the macro `vmx_entry_with` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: unnecessary `unsafe` block\n   --> src/vmx/vcpu.rs:923:9\n    |\n923 |         unsafe {\n    |         ^^^^^^ unnecessary `unsafe` block\n\nwarning: unused variable: `write`\n    --> src/vmx/vcpu.rs:1046:13\n     |\n1046 |         let write = match apic_access_exit_info.access_type {\n     |             ^^^^^ help: if this is intentional, prefix it with an underscore: `_write`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `exit_info`\n    --> src/vmx/vcpu.rs:1043:38\n     |\n1043 |     fn handle_apic_access(&mut self, exit_info: &VmxExitInfo) -> AxResult {\n     |                                      ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_exit_info`\n\nwarning: integer-to-pointer cast\n   --> /home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memory_addr-0.4.0/src/addr.rs:491:9\n    |\n491 |         self.0 as *mut u8\n    |         ^^^^^^^^^^^^^^^^^ integer-to-pointer cast\n    |\n    = help: this program is using integer-to-pointer casts or (equivalently) `ptr::with_exposed_provenance`, which means that Miri might miss pointer bugs in this program\n    = help: see https://doc.rust-lang.org/nightly/std/ptr/fn.with_exposed_provenance.html for more details on that operation\n    = help: to ensure that Miri does not miss bugs in your program, use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead\n    = help: you can then set `MIRIFLAGS=-Zmiri-strict-provenance` to ensure you are not relying on `with_exposed_provenance` semantics\n    = help: alternatively, `MIRIFLAGS=-Zmiri-permissive-provenance` disables this warning\n    = note: BACKTRACE on thread `vmx::structs::t`:\n    = note: inside `memory_addr::VirtAddr::as_mut_ptr` at /home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/memory_addr-0.4.0/src/addr.rs:491:9: 491:26\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::as_mut_ptr` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:58:9: 58:57\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::fill` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:63:41: 63:58\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::alloc_zero` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:34:9: 34:18\nnote: inside `vmx::structs::VmxRegion::<test_utils::mock::MockMmHal>::new`\n   --> src/vmx/structs.rs:25:21\n    |\n25  |         let frame = PhysFrame::alloc_zero()?;\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside `vmx::structs::tests::test_vmx_region_new_with_shadow`\n   --> src/vmx/structs.rs:310:32\n    |\n310 |         let region_no_shadow = VmxRegion::<MockMmHal>::new(0x12345, false);\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside closure\n   --> src/vmx/structs.rs:305:41\n    |\n304 |     #[test]\n    |     ------- in this procedural macro expansion\n305 |     fn test_vmx_region_new_with_shadow() {\n    |                                         ^\n\nerror: Undefined Behavior: attempting a write access using <wildcard> at alloc270[0x8], but no exposed tags have suitable permission in the borrow stack for this location\n   --> /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:63:18\n    |\n63  |         unsafe { core::ptr::write_bytes(self.as_mut_ptr(), byte, PAGE_SIZE) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this error occurs as part of an access at alloc270[0x8..0x1008]\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n    = note: BACKTRACE on thread `vmx::structs::t`:\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::fill` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:63:18: 63:76\n    = note: inside `axaddrspace::PhysFrame::<test_utils::mock::MockMmHal>::alloc_zero` at /home/runner/.cargo/git/checkouts/axaddrspace-0a115128c9343544/2722b2c/src/frame.rs:34:9: 34:18\nnote: inside `vmx::structs::VmxRegion::<test_utils::mock::MockMmHal>::new`\n   --> src/vmx/structs.rs:25:21\n    |\n25  |         let frame = PhysFrame::alloc_zero()?;\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside `vmx::structs::tests::test_vmx_region_new_with_shadow`\n   --> src/vmx/structs.rs:310:32\n    |\n310 |         let region_no_shadow = VmxRegion::<MockMmHal>::new(0x12345, false);\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: inside closure\n   --> src/vmx/structs.rs:305:41\n    |\n304 |     #[test]\n    |     ------- in this procedural macro expansion\n305 |     fn test_vmx_region_new_with_shadow() {\n    |                                         ^\n\nnote: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n\nerror: aborting due to 1 previous error; 7 warnings emitted\n\nerror: test failed, to rerun pass `-p x86_vcpu --lib`\n\nCaused by:\n  process didn't exit successfully: `/home/runner/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/cargo-miri runner /tmp/os-checker-plugin-cargo/arceos-hypervisor/x86_vcpu/target/miri/x86_64-unknown-linux-gnu/debug/deps/x86_vcpu-22a1f51880a00623 x86_vcpu 'vmx::structs::tests::test_vmx_region_new_with_shadow'` (exit status: 1)\nnote: test exited abnormally; to see the full output pass --nocapture to the harness.\n",
                "miri_timeout": false
              },
              {
                "name": "vmx::structs::tests::test_vmx_region_uninit",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::vcpu::tests::test_bit_operations",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::vcpu::tests::test_constants",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::vcpu::tests::test_debug_implementations",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::vcpu::tests::test_general_registers_operations",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::vcpu::tests::test_get_tr_base_logic",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::vcpu::tests::test_vm_cpu_mode_enum",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::vcpu::tests::test_vmx_exit_reason_enum",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::vcpu::tests::vmx_vcpu_tests::test_access_width_operations",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::vcpu::tests::vmx_vcpu_tests::test_cpuid_constants",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::vcpu::tests::vmx_vcpu_tests::test_cr_flags_operations",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::vcpu::tests::vmx_vcpu_tests::test_edx_eax_operations",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::vcpu::tests::vmx_vcpu_tests::test_general_registers_clone",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::vcpu::tests::vmx_vcpu_tests::test_gla2gva_logic",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::vcpu::tests::vmx_vcpu_tests::test_interrupt_vector_validation",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::vcpu::tests::vmx_vcpu_tests::test_page_walk_info_struct",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              },
              {
                "name": "vmx::vcpu::tests::vmx_vcpu_tests::test_register_bit_operations",
                "status": "ok",
                "duration_ms": 4,
                "error": null,
                "miri_pass": true,
                "miri_output": null,
                "miri_timeout": false
              }
            ],
            "failed": 0,
            "duration_ms": 235
          }
        ],
        "failed": 0,
        "duration_ms": 235,
        "pkg_tests_count": 58,
        "workspace_tests_count": 58
      },
      "tests": 0,
      "examples": 0,
      "benches": 0,
      "authors": [
        "Mingxian Su <aarkegz@gmail.com>",
        "Keyang Hu <keyang.hu@qq.com>"
      ],
      "description": "x86 Virtual CPU implementation for the Arceos Hypervisor",
      "documentation": null,
      "readme": "README.md",
      "homepage": null,
      "keywords": [
        "x86",
        "vcpu",
        "hypervisor",
        "arceos"
      ],
      "categories": [
        "embedded",
        "no-std"
      ],
      "rust_version": null,
      "diag_total_count": 75,
      "last_commit_time": "2025-07-26T02:42:51Z",
      "release_count": null,
      "last_release_size": null,
      "last_release_time": null
    }
  }
}